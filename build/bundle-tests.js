'use strict';

var _head = require('lodash/head');
var _tail = require('lodash/tail');
var _sortBy = require('lodash/sortBy');
var _reduce = require('lodash/reduce');
var _map = require('lodash/map');
var _isEqual = require('lodash/isEqual');
var _find = require('lodash/find');
var _flatten = require('lodash/flatten');
var _uniq = require('lodash/uniq');
var _get = require('lodash/get');
var _each = require('lodash/each');
var _pick = require('lodash/pick');
var _isEmpty = require('lodash/isEmpty');
var _pickBy = require('lodash/pickBy');
var reselect = require('reselect');
var recompute = require('@jvitela/recompute');
var createCachedSelector = require('re-reselect');
var _isObject = require('lodash/isObject');
var _isMatch = require('lodash/isMatch');
var _filter = require('lodash/filter');
var _omitBy = require('lodash/omitBy');
var _uniqBy = require('lodash/uniqBy');
var _includes = require('lodash/includes');
var path = require('path');
var ptrUtils = require('@gisatcz/ptr-utils');
var _forIn = require('lodash/forIn');
var _forEach = require('lodash/forEach');
var _cloneDeep = require('lodash/cloneDeep');
var _values = require('lodash/values');
var _isArray = require('lodash/isArray');
var _omit = require('lodash/omit');
var moment = require('moment');
var _compact = require('lodash/compact');
var stringify = require('fast-stringify');
var ptrCore = require('@gisatcz/ptr-core');
var ptrTileGrid = require('@gisatcz/ptr-tile-grid');
var _intersection = require('lodash/intersection');
var chai = require('chai');
var slash = require('slash');
var _orderBy = require('lodash/orderBy');
var _flatMap = require('lodash/flatMap');
var _remove = require('lodash/remove');
var _chunk = require('lodash/chunk');
var _isUndefined = require('lodash/isUndefined');
var fetch$1 = require('isomorphic-fetch');
var queryString = require('query-string');
var _union = require('lodash/union');
var _without = require('lodash/without');
var _difference = require('lodash/difference');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _head__default = /*#__PURE__*/_interopDefaultLegacy(_head);
var _tail__default = /*#__PURE__*/_interopDefaultLegacy(_tail);
var _sortBy__default = /*#__PURE__*/_interopDefaultLegacy(_sortBy);
var _reduce__default = /*#__PURE__*/_interopDefaultLegacy(_reduce);
var _map__default = /*#__PURE__*/_interopDefaultLegacy(_map);
var _isEqual__default = /*#__PURE__*/_interopDefaultLegacy(_isEqual);
var _find__default = /*#__PURE__*/_interopDefaultLegacy(_find);
var _flatten__default = /*#__PURE__*/_interopDefaultLegacy(_flatten);
var _uniq__default = /*#__PURE__*/_interopDefaultLegacy(_uniq);
var _get__default = /*#__PURE__*/_interopDefaultLegacy(_get);
var _each__default = /*#__PURE__*/_interopDefaultLegacy(_each);
var _pick__default = /*#__PURE__*/_interopDefaultLegacy(_pick);
var _isEmpty__default = /*#__PURE__*/_interopDefaultLegacy(_isEmpty);
var _pickBy__default = /*#__PURE__*/_interopDefaultLegacy(_pickBy);
var createCachedSelector__default = /*#__PURE__*/_interopDefaultLegacy(createCachedSelector);
var _isObject__default = /*#__PURE__*/_interopDefaultLegacy(_isObject);
var _isMatch__default = /*#__PURE__*/_interopDefaultLegacy(_isMatch);
var _filter__default = /*#__PURE__*/_interopDefaultLegacy(_filter);
var _omitBy__default = /*#__PURE__*/_interopDefaultLegacy(_omitBy);
var _uniqBy__default = /*#__PURE__*/_interopDefaultLegacy(_uniqBy);
var _includes__default = /*#__PURE__*/_interopDefaultLegacy(_includes);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var _forIn__default = /*#__PURE__*/_interopDefaultLegacy(_forIn);
var _forEach__default = /*#__PURE__*/_interopDefaultLegacy(_forEach);
var _cloneDeep__default = /*#__PURE__*/_interopDefaultLegacy(_cloneDeep);
var _values__default = /*#__PURE__*/_interopDefaultLegacy(_values);
var _isArray__default = /*#__PURE__*/_interopDefaultLegacy(_isArray);
var _omit__default = /*#__PURE__*/_interopDefaultLegacy(_omit);
var moment__default = /*#__PURE__*/_interopDefaultLegacy(moment);
var _compact__default = /*#__PURE__*/_interopDefaultLegacy(_compact);
var stringify__default = /*#__PURE__*/_interopDefaultLegacy(stringify);
var _intersection__default = /*#__PURE__*/_interopDefaultLegacy(_intersection);
var slash__default = /*#__PURE__*/_interopDefaultLegacy(slash);
var _orderBy__default = /*#__PURE__*/_interopDefaultLegacy(_orderBy);
var _flatMap__default = /*#__PURE__*/_interopDefaultLegacy(_flatMap);
var _remove__default = /*#__PURE__*/_interopDefaultLegacy(_remove);
var _chunk__default = /*#__PURE__*/_interopDefaultLegacy(_chunk);
var _isUndefined__default = /*#__PURE__*/_interopDefaultLegacy(_isUndefined);
var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch$1);
var queryString__default = /*#__PURE__*/_interopDefaultLegacy(queryString);
var _union__default = /*#__PURE__*/_interopDefaultLegacy(_union);
var _without__default = /*#__PURE__*/_interopDefaultLegacy(_without);
var _difference__default = /*#__PURE__*/_interopDefaultLegacy(_difference);

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = o[Symbol.iterator]();
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];

  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }

  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");

  return typeof key === "symbol" ? key : String(key);
}

/**
 * TODO tests
 * Returns all indexes that fits filter and order
 * @param {*} indexes 
 * @param {*} filter 
 * @param {*} order 
 */
var getIndex = createCachedSelector__default['default']([function (indexes) {
  return indexes;
}, function (indexes, filter) {
  return filter;
}, function (indexes, filter, order) {
  return order;
}], function (indexes, filter, order) {
  if (indexes) {
    var index = _find__default['default'](indexes, function (index) {
      return isCorrespondingIndex(index, filter, order);
    });

    return index ? index : null;
  } else {
    return null;
  }
})(function (indexes, filter, order) {
  return "".concat(JSON.stringify(filter)).concat(JSON.stringify(order));
}); // TODO Test

function getUniqueIndexes(indexes) {
  if (!_isEmpty__default['default'](indexes)) {
    return indexes.reduce(function (uniqueIndexes, index) {
      if (_find__default['default'](uniqueIndexes, function (i) {
        return i && isCorrespondingIndex(index, i.filter, i.order);
      })) {
        return uniqueIndexes;
      }

      return [].concat(_toConsumableArray(uniqueIndexes), [index]);
    }, []);
  } else {
    return null;
  }
}
/**
 * Remove index from given indexes that fit to filter and order.
 * If index does not exists under filter, same instance of indexes has return.
 * @param indexes {Array} Array of indexes
 * @param filter {Object} 
 * @param order {Array}
 * @return {Array} New instance of indexes
 */


function removeIndex() {
  var indexes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var filter = arguments.length > 1 ? arguments[1] : undefined;
  var order = arguments.length > 2 ? arguments[2] : undefined;

  if (indexes && !_isEmpty__default['default'](indexes)) {
    var clearedIndexes = _reduce__default['default'](indexes, function (acc, index) {
      var indexToBeCleared = isCorrespondingIndex(index, filter, order);

      if (indexToBeCleared) {
        return acc;
      } else {
        return [].concat(_toConsumableArray(acc), [index]);
      }
    }, []);

    if (clearedIndexes.length === indexes.length) {
      return indexes;
    } else {
      return clearedIndexes;
    }
  } else {
    return indexes;
  }
}
/**
 * Create set of updated indexes state based on current state and given indexUpdate.
 * It produce updated indexes state in case of existing index for given filter and order.
 * If index with filter and order is not in the state yet, its add to indexes state.
 * @param state {Object}
 * @param filter {Object}
 * @param order {Array}
 * @param indexUpdate {Array}
 * @param changedOn {string}
 * @param indexesPath {string} name of a property where indexes are stored
 */


function getUpdatedIndexes(state, filter, order, indexUpdate, changedOn) {
  var indexesPath = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "indexes";
  var indexes = [];
  var selectedIndex = {};

  if (state[indexesPath]) {
    state[indexesPath].forEach(function (index) {
      if (_isEqual__default['default'](index.filter, filter) && _isEqual__default['default'](index.order, order)) {
        selectedIndex = index;
      } else {
        indexes.push(index);
      }
    });
  }

  var index;

  if (indexUpdate.length) {
    index = _objectSpread2({}, selectedIndex.index);
    indexUpdate.forEach(function (model, i) {
      if (model.key) {
        index[i] = model.key;
      } else {
        //spatial data by spatialDataSourceKey, levels and tiles
        //update spatialDataSourceKey
        for (var _i = 0, _Object$entries = Object.entries(model); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
              level = _Object$entries$_i[0],
              dataByTiles = _Object$entries$_i[1];

          if (index.hasOwnProperty(level) && index[level]) {
            //update data on level
            index[level] = _objectSpread2(_objectSpread2({}, index[level]), dataByTiles);
          } else {
            index[level] = _objectSpread2({}, dataByTiles);
          }
        }
      }
    });
  }

  selectedIndex = {
    filter: selectedIndex.filter || filter,
    order: selectedIndex.order || order,
    changedOn: changedOn,
    index: index || selectedIndex.index
  };
  indexes.push(selectedIndex);
  return indexes;
}

function isCorrespondingIndex(index, filter, order) {
  return _isEqual__default['default'](index.filter, filter) && _isEqual__default['default'](index.order, order);
}

function itemFitFilter(filter, item) {
  // null filter fit 
  if (filter === null) {
    return true;
  }

  var entries = Object.entries(filter);
  return entries.every(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    var itemHasFilterKey = item.data && item.data.hasOwnProperty(key);
    var itemHasFilterLinkKey = item.data && item.data.hasOwnProperty("".concat(key, "Key"));

    if (itemHasFilterKey) {
      //apply condition
      //"column0": "hleda se rovnost",
      //"column1": null,
      if (item.data && item.data[key] === value) {
        return true;
      } // "column2": {
      // 	"like": "hleda se podobnost, castecny vyskyt"
      // },


      if (_isObject__default['default'](value) && value['like']) {
        //now we dont deal like filter, refrest indexes
        return true;
      } // "column3": {
      // 	"in": ["existuje", "v", "poli", "prvku"]
      // },


      if (_isObject__default['default'](value) && value['in']) {
        return value["in"].includes(item.data[key]);
      } // "column4": {
      // 	"notin": ["neexistuje", "v", "poli", "prvku"]
      // }


      if (_isObject__default['default'](value) && value['notin']) {
        return !value.notin.includes(item.data[key]);
      }
    } //check if filter contains linking like scopeKey, viewKey, ...


    if (itemHasFilterLinkKey) {
      if (item.data && item.data["".concat(key, "Key")] === value) {
        return true;
      }
    } //if to filter fit return false


    return false;
  });
}

function mergeFilters(activeKeys, filterByActive, filter) {
  if (activeKeys && filterByActive) {
    var fullFilter = _objectSpread2({}, filter);

    if (filterByActive.application) {
      if (activeKeys.activeApplicationKey) {
        fullFilter.applicationKey = activeKeys.activeApplicationKey;
      }
    }

    if (filterByActive["case"]) {
      if (activeKeys.activeCaseKey) {
        fullFilter.caseKey = activeKeys.activeCaseKey;
      }
    }

    if (filterByActive.scope) {
      if (activeKeys.activeScopeKey) {
        fullFilter.scopeKey = activeKeys.activeScopeKey;
      }
    } // TODO add scenario, ...


    if (filterByActive.place) {
      if (activeKeys.activePlaceKey) {
        fullFilter.placeKey = activeKeys.activePlaceKey;
      } else if (activeKeys.activePlaceKeys) {
        fullFilter.placeKey = {
          "in": activeKeys.activePlaceKeys
        };
      }
    }

    if (filterByActive.period) {
      if (activeKeys.activePeriodKey) {
        fullFilter.periodKey = activeKeys.activePeriodKey;
      } else if (activeKeys.activePeriodKeys) {
        fullFilter.periodKey = {
          "in": activeKeys.activePeriodKeys
        };
      }
    }

    if (filterByActive.attribute) {
      if (activeKeys.activeAttributeKey) {
        fullFilter.attributeKey = activeKeys.activeAttributeKey;
      }
    }

    if (filterByActive.layerTemplate) {
      if (activeKeys.activeLayerTemplateKey) {
        fullFilter.layerTemplateKey = activeKeys.activeLayerTemplateKey;
      }
    }

    return _isEmpty__default['default'](fullFilter) ? null : fullFilter;
  } else {
    return filter;
  }
}
/**
 * Merge metadata defined by key with metadata keys defined by filterByActive
 * @param definedKeys {Object}
 * @param activeKeys {Object}
 * @return {Object|null}
 */


function mergeMetadataKeys(definedKeys, activeKeys) {
  if (definedKeys && activeKeys) {
    return _objectSpread2(_objectSpread2({}, activeKeys), definedKeys);
  } else {
    return definedKeys || activeKeys || null;
  }
}
/**
 * It converts modifiers from metadataKeys: ["A", "B"] to metadataKey: {in: ["A", "B"]}
 * @param modifiers {Object}
 * @return {Object|null}
 */


function convertModifiersToRequestFriendlyFormat(modifiers) {
  if (modifiers) {
    var modifiersForRequest = {};

    if (modifiers.scopeKey) {
      modifiersForRequest.scopeKey = modifiers.scopeKey;
    }

    if (modifiers.placeKeys) {
      modifiersForRequest.placeKey = {
        "in": modifiers.placeKeys
      };
    } else if (modifiers.placeKey) {
      modifiersForRequest.placeKey = modifiers.placeKey;
    }

    if (modifiers.caseKeys) {
      modifiersForRequest.caseKey = {
        "in": modifiers.caseKeys
      };
    } else if (modifiers.caseKey) {
      modifiersForRequest.caseKey = modifiers.caseKey;
    }

    if (modifiers.scenarioKeys) {
      modifiersForRequest.scenarioKey = {
        "in": modifiers.scenarioKeys
      };
    } else if (modifiers.scenarioKey) {
      modifiersForRequest.scenarioKey = modifiers.scenarioKey;
    }

    if (modifiers.periodKeys) {
      modifiersForRequest.periodKey = {
        "in": modifiers.periodKeys
      };
    } else if (modifiers.periodKey) {
      modifiersForRequest.periodKey = modifiers.periodKey;
    }

    return !_isEmpty__default['default'](modifiersForRequest) ? modifiersForRequest : null;
  } else {
    return null;
  }
}

var commonHelpers = {
  convertModifiersToRequestFriendlyFormat: convertModifiersToRequestFriendlyFormat,
  removeIndex: removeIndex,
  getIndex: getIndex,
  getUniqueIndexes: getUniqueIndexes,
  getUpdatedIndexes: getUpdatedIndexes,
  mergeFilters: mergeFilters,
  mergeMetadataKeys: mergeMetadataKeys,
  isCorrespondingIndex: isCorrespondingIndex,
  itemFitFilter: itemFitFilter
};

var activeScopeKey = function activeScopeKey(state) {
  return state.scopes.activeKey;
};
/**
 *
 * @param {*} getSubstate
 * @returns {Object}
 */


var getAllByKey = function getAllByKey(getSubstate) {
  return function (state) {
    return getSubstate(state).byKey;
  };
};
/**
 * 
 * @param {*} getSubstate 
 * @returns {Object}
 */


var getAllNotRemovedAsObject = function getAllNotRemovedAsObject(getSubstate) {
  return reselect.createSelector([getAllByKey(getSubstate)], function (byKey) {
    return _pickBy__default['default'](byKey, function (item) {
      return !item.hasOwnProperty('removed');
    });
  });
};

var getAllAsObject = getAllNotRemovedAsObject;
/**
 * 
 * @param {*} getSubstate 
 * @returns {Array|null}
 */

var getAll = function getAll(getSubstate) {
  return reselect.createSelector([getAllAsObject(getSubstate)], function (byKey) {
    return byKey ? Object.values(byKey) : null;
  });
};

function modelsFromIndex(models, index) {
  if (!index || !index.index) {
    return null;
  }

  var indexedModels = [];

  for (var i = 1; i <= index.count; i++) {
    var modelKey = index.index[i];

    if (modelKey) {
      var indexedModel = models[modelKey];

      if (indexedModel) {
        indexedModels.push(indexedModel);
      } else {
        indexedModels.push({
          key: modelKey
        });
      }
    } else {
      indexedModels.push(null);
    }
  }

  return nonEmptyArray(indexedModels);
}

function modelsFromIndex2(models, index) {
  if (!index || !index.index) {
    return null;
  }

  var indexedModels = [];

  for (var _i = 0, _Object$entries = Object.entries(index.index); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];

    if (value) {
      var indexedModel = models[value];

      if (indexedModel) {
        indexedModels.push(indexedModel);
      } else {
        indexedModels.push(null);
      }
    } else {
      indexedModels.push(null);
    }
  }

  return nonEmptyArray(indexedModels);
}

var getAllForActiveScope = function getAllForActiveScope(getSubstate) {
  return reselect.createSelector([getAllAsObject(getSubstate), getIndexes(getSubstate), activeScopeKey, function (state, order) {
    return order;
  }], function (models, indexes, activeScopeKey, order) {
    if (models && indexes && activeScopeKey) {
      var filter = {
        scopeKey: activeScopeKey
      };
      var index = commonHelpers.getIndex(indexes, filter, order);
      return modelsFromIndex(models, index);
    }

    return null;
  });
};

var getActiveKey = function getActiveKey(getSubstate) {
  return function (state) {
    return getSubstate(state).activeKey;
  };
};

var getActiveKeys = function getActiveKeys(getSubstate) {
  return function (state) {
    return getSubstate(state).activeKeys;
  };
};

var getActive = function getActive(getSubstate) {
  return reselect.createSelector([getAllAsObject(getSubstate), getActiveKey(getSubstate)], function (models, activeKey) {
    if (models && models[activeKey]) {
      return models[activeKey];
    } else {
      return null;
    }
  });
};

var getActiveModels = function getActiveModels(getSubstate) {
  return reselect.createSelector([getAllAsObject(getSubstate), getActiveKeys(getSubstate)], function (models, activeKeys) {
    var activeModels = [];

    if (models && !_isEmpty__default['default'](models) && activeKeys && !_isEmpty__default['default'](activeKeys)) {
      activeKeys.map(function (key) {
        var model = models[key];

        if (model) {
          activeModels.push(model);
        }
      });
    }

    return nonEmptyArray(activeModels);
  });
};

var getByFilterOrder = function getByFilterOrder(getSubstate) {
  return reselect.createSelector([getAllAsObject(getSubstate), getIndexes(getSubstate), function (state, filter) {
    return filter;
  }, function (state, filter, order) {
    return order;
  }], function (models, indexes, filter, order) {
    if (models && indexes) {
      var index = commonHelpers.getIndex(indexes, filter, order);
      return modelsFromIndex(models, index);
    } else {
      return null;
    }
  });
};

var getBatchByFilterOrder = function getBatchByFilterOrder(getSubstate) {
  return reselect.createSelector([getAllAsObject(getSubstate), getIndexes(getSubstate), function (state, filter) {
    return filter;
  }, function (state, filter, order) {
    return order;
  }], function (models, indexes, filter, order) {
    if (models && indexes) {
      var index = commonHelpers.getIndex(indexes, filter, order);
      return modelsFromIndex2(models, index);
    } else {
      return null;
    }
  });
};

var getIndexed = function getIndexed(getSubstate) {
  //todo proper memoization && unify with old getIndexedPage etc.
  return createCachedSelector__default['default']([getAllAsObject(getSubstate), getIndexes(getSubstate), getAllActiveKeys, function (state, filterByActive) {
    return filterByActive;
  }, function (state, filterByActive, filter) {
    return filter;
  }, function (state, filterByActive, filter, order) {
    return order;
  }, function (state, filterByActive, filter, order, start) {
    return start;
  }, function (state, filterByActive, filter, order, start, length) {
    return length;
  }], function (models, indexes, activeKeys, filterByActive, filter, order, start, length) {
    if (models && indexes) {
      var mergedFilter = commonHelpers.mergeFilters(activeKeys, filterByActive, filter);
      var index = commonHelpers.getIndex(indexes, mergedFilter, order);

      if (index && index.index) {
        var indexedModels = [];
        var end = Math.min(start + length - 1, index.count);

        for (var i = start; i <= end; i++) {
          var modelKey = index.index[i];

          if (modelKey) {
            var indexedModel = models[modelKey];

            if (indexedModel) {
              indexedModels.push(indexedModel);
            } else {
              indexedModels.push({
                key: modelKey
              });
            }
          } else {
            indexedModels.push(null);
          }
        }

        return indexedModels.length ? indexedModels : null;
      } else {
        return null;
      }
    } else {
      return null;
    }
  })(function (state, filterByActive, filter, order, start, length) {
    return "".concat(JSON.stringify(filterByActive), ":").concat(JSON.stringify(filter), ":").concat(JSON.stringify(order), ":").concat(start, ":").concat(length);
  });
};

var getByKey = function getByKey(getSubstate) {
  return createCachedSelector__default['default']([getAllAsObject(getSubstate), function (state, key) {
    return key;
  }], function (allData, key) {
    if (key && allData && !_isEmpty__default['default'](allData) && allData[key]) {
      return allData[key];
    } else {
      return null;
    }
  })(function (state, key) {
    return key;
  });
};

var getByKeysAsObject = function getByKeysAsObject(getSubstate) {
  return createCachedSelector__default['default']([getAllAsObject(getSubstate), function (state, keys) {
    return keys;
  }], function (allData, keys) {
    if (keys && keys.length && allData && !_isEmpty__default['default'](allData)) {
      var data = _pick__default['default'](allData, keys);

      return _isEmpty__default['default'](data) ? null : data;
    } else {
      return null;
    }
  })(function (state, keys) {
    return "".concat(keys);
  });
}; // TODO test + use getByKeysAsObject?


var getByKeys = function getByKeys(getSubstate) {
  return createCachedSelector__default['default']([getAllAsObject(getSubstate), function (state, keys) {
    return keys;
  }], function (allData, keys) {
    if (keys && keys.length && allData && !_isEmpty__default['default'](allData)) {
      var data = [];

      _each__default['default'](keys, function (key) {
        if (allData[key]) {
          data.push(allData[key]);
        }
      });

      return nonEmptyArray(data);
    } else {
      return null;
    }
  })(function (state, keys) {
    return "".concat(keys);
  });
};

var getDataByKey = function getDataByKey(getSubstate) {
  return reselect.createSelector([getByKey(getSubstate)], function (model) {
    if (model && model.data) {
      return model.data;
    } else {
      return null;
    }
  });
};

var getDeletePermissionByKey = function getDeletePermissionByKey(getSubstate) {
  return reselect.createSelector([getByKey(getSubstate)], function (model) {
    if (model && model.permissions) {
      return model.permissions.activeUser && model.permissions.activeUser["delete"] || model.permissions.guest && model.permissions.guest["delete"];
    } else {
      return false;
    }
  });
};

var getUpdatePermissionByKey = function getUpdatePermissionByKey(getSubstate) {
  return reselect.createSelector([getByKey(getSubstate)], function (model) {
    if (model && model.permissions) {
      return model.permissions.activeUser && model.permissions.activeUser.update || model.permissions.guest && model.permissions.guest.update;
    } else {
      return false;
    }
  });
};

var getEditedAll = function getEditedAll(getSubstate) {
  return function (state) {
    var data = getSubstate(state).editedByKey;
    return data ? Object.values(data) : null;
  };
};

var getEditedAllAsObject = function getEditedAllAsObject(getSubstate) {
  return function (state) {
    return getSubstate(state).editedByKey;
  };
};

var getEditedActive = function getEditedActive(getSubstate) {
  return reselect.createSelector([getEditedAllAsObject(getSubstate), getActiveKey(getSubstate)], function (models, activeKey) {
    if (models && models[activeKey]) {
      return models[activeKey];
    } else {
      return null;
    }
  });
};

var getEditedByKey = function getEditedByKey(getSubstate) {
  return function (state, key) {
    var allEditedData = getEditedAllAsObject(getSubstate)(state);

    if (key && allEditedData && !_isEmpty__default['default'](allEditedData) && allEditedData[key]) {
      return allEditedData[key];
    } else {
      return null;
    }
  };
};

var getEditedDataByKey = function getEditedDataByKey(getSubstate) {
  return reselect.createSelector([getEditedByKey(getSubstate)], function (model) {
    if (model && model.data) {
      return model.data;
    } else {
      return null;
    }
  });
};

var getEditedKeys = function getEditedKeys(getSubstate) {
  return reselect.createSelector([getEditedAll(getSubstate)], function (edited) {
    if (edited && !_isEmpty__default['default'](edited)) {
      return edited.map(function (model) {
        return model.key;
      });
    }

    return null;
  });
};

var getIndexes = function getIndexes(getSubstate) {
  return function (state) {
    return getSubstate(state).indexes;
  };
};

var getIndexesObserver = recompute.createObserver(function (state, getSubstate) {
  return getIndexes(getSubstate)(state);
});
/**
 * Get whole index by given filter and order
 * @param getSubstate
 */

var getIndex$1 = function getIndex(getSubstate) {
  return reselect.createSelector([getIndexes(getSubstate), function (state, filter) {
    return filter;
  }, function (state, filter, order) {
    return order;
  }], function (indexes, filter, order) {
    return commonHelpers.getIndex(indexes, filter, order);
  });
};
/**
 * Get indexes value from given state on given path.
 * Optional param indexPath has default value "indexes"
 */


var getIndexesByPath = function getIndexesByPath(getSubstate) {
  return function (state) {
    var indexPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'indexes';
    return _get__default['default'](getSubstate(state), indexPath);
  };
};
/**
 * Get whole index by given filter and order and optional indexPath
 * Beside getIndex indexPath is first optional parameter, filter and order folows.
 */


var getIndexByPath = function getIndexByPath(getSubstate) {
  return reselect.createSelector([getIndexesByPath(getSubstate), function (state, indexPath, filter) {
    return filter;
  }, function (state, indexPath, filter, order) {
    return order;
  }], function (indexes, filter, order) {
    return commonHelpers.getIndex(indexes, filter, order);
  });
};

var getIndex_recompute = function getIndex_recompute(getSubstate) {
  return recompute.createSelector(function (filter, order) {
    var indexes = getIndexesObserver(getSubstate);

    if (indexes) {
      return commonHelpers.getIndex(indexes, filter, order);
    } else {
      return null;
    }
  });
};

var getIndexChangedOn = function getIndexChangedOn(getSubstate) {
  return reselect.createSelector([getIndex$1(getSubstate)], function (index) {
    if (index && index.changedOn) {
      return index.changedOn;
    } else {
      return null;
    }
  });
};

var getIndexPage = function getIndexPage(getSubstate) {
  return reselect.createSelector([getIndex$1(getSubstate), function (state, filter, order, start) {
    return start;
  }, function (state, filter, order, start, length) {
    return length;
  }], function (index, start, length) {
    if (index && index.index) {
      var indexed = {};

      for (var o = start; o < start + length && o <= index.count; o++) {
        var key = index.index[o];
        indexed[o] = key ? key : null;
      }

      return indexed;
    } else {
      return null;
    }
  });
};
/**
 * Get a page of data
 * call with (state, filter, order, start, length)
 */


var getIndexedPage = function getIndexedPage(getSubstate) {
  return reselect.createSelector([getIndexPage(getSubstate), getAllAsObject(getSubstate)], function (page, models) {
    return page && page.length && page.map(function (key) {
      return models[key] || null;
    }) || null; //todo check loading
  });
};
/**
 * call with (state, filter, order)
 */


var getIndexTotal = function getIndexTotal(getSubstate) {
  return reselect.createSelector([getIndex$1(getSubstate)], function (index) {
    if (index && (index.count || index.count === 0)) {
      return index.count;
    } else {
      return null;
    }
  });
};
/**
 * 
 * @param {func} getSubstate 
 * @return {Array}
 */


var getIndexesByFilteredItem = function getIndexesByFilteredItem(getSubstate) {
  return reselect.createSelector([getIndexes(getSubstate), function (state, item) {
    return item;
  }], function (indexes, item) {
    if (!_isEmpty__default['default'](indexes)) {
      return indexes.filter(function (index) {
        return commonHelpers.itemFitFilter(index.filter, item);
      });
    } else {
      return null;
    }
  });
};
/**
 * @param {Array} array
 *
 * @returns {Array|null} Non empty array or null.
 */


function nonEmptyArray(array) {
  return array.length ? array : null;
}
/**
 * Compare keys with loaded models and return which keys need to be loaded
 */


var getKeysToLoad = function getKeysToLoad(getSubstate) {
  return reselect.createSelector([getAllAsObject(getSubstate), function (state, keys) {
    return keys;
  }], function (models, keys) {
    if (keys && keys.length) {
      if (!models) {
        return keys;
      } else {
        return nonEmptyArray(keys.filter(function (key) {
          return !models[key] || models[key].outdated;
        }));
      }
    } else {
      return null;
    }
  });
};

var getUsedKeys = function getUsedKeys(getSubstate) {
  return function (state) {
    var inUse = getSubstate(state).inUse.keys;

    if (inUse) {
      var keys = _uniq__default['default'](_flatten__default['default'](Object.values(inUse)));

      return keys.length ? keys : null;
    } else {
      return null;
    }
  };
};

var getIndexedDataUses = function getIndexedDataUses(getSubstate) {
  return function (state) {
    if (getSubstate(state) && getSubstate(state).inUse) {
      return getSubstate(state).inUse.indexes;
    } else {
      return null;
    }
  };
};

var getAllActiveKeys = reselect.createSelector([function (state) {
  return state.scopes && state.scopes.activeKey;
}, function (state) {
  return state.cases && state.cases.activeKey;
}, function (state) {
  return state.cases && state.cases.activeKeys;
}, function (state) {
  return state.scenarios && state.scenarios.activeKey;
}, function (state) {
  return state.scenarios && state.scenarios.activeKeys;
}, function (state) {
  return state.places && state.places.activeKey;
}, function (state) {
  return state.places && state.places.activeKeys;
}, function (state) {
  return state.periods && state.periods.activeKey;
}, function (state) {
  return state.periods && state.periods.activeKeys;
}, function (state) {
  return state.attributes && state.attributes.activeKey;
}, function (state) {
  return state.attributes && state.attributes.activeKeys;
}, function (state) {
  return state.layerTemplates && state.layerTemplates.activeKey;
}, function (state) {
  return state.areaTreeLevelKeys && state.areaTreeLevelKeys.activeKey;
}, function (state) {
  return state.specific && state.specific.apps;
}, function (state) {
  return state.app && state.app.key;
}], function (activeScopeKey, activeCaseKey, activeCaseKeys, activeScenarioKey, activeScenarioKeys, activePlaceKey, activePlaceKeys, activePeriodKey, activePeriodKeys, activeAttributeKey, activeAttributeKeys, activeLayerTemplateKey, activeAreaTreeLevelKey, apps, appKey) {
  var activeKeys = {
    activeScopeKey: activeScopeKey || null,
    activeCaseKey: activeCaseKey || null,
    activeCaseKeys: activeCaseKeys || null,
    activeScenarioKey: activeScenarioKey || null,
    activeScenarioKeys: activeScenarioKeys || null,
    activePlaceKey: activePlaceKey || null,
    activePlaceKeys: activePlaceKeys || null,
    activePeriodKey: activePeriodKey || null,
    activePeriodKeys: activePeriodKeys || null,
    activeAttributeKey: activeAttributeKey || null,
    activeAttributeKeys: activeAttributeKeys || null,
    activeLayerTemplateKey: activeLayerTemplateKey || null,
    activeAreaTreeLevelKey: activeAreaTreeLevelKey || null
  }; // for BO usage

  if (apps) {
    activeKeys.activeApplicationKey = apps.activeKey;
  } else if (appKey) {
    activeKeys.activeApplicationKey = appKey;
  }

  return activeKeys;
});
var getActiveKeysByFilterByActive = createCachedSelector__default['default']([getAllActiveKeys, function (state, filterByActive) {
  return filterByActive;
}], function (activeKeys, filterByActive) {
  if (filterByActive && !_isEmpty__default['default'](filterByActive)) {
    var keys = {};

    if (filterByActive.scope && activeKeys.activeScopeKey) {
      keys.scopeKey = activeKeys.activeScopeKey;
    }

    if (filterByActive.place) {
      if (activeKeys.activePlaceKey) {
        keys.placeKey = activeKeys.activePlaceKey;
      } else if (activeKeys.activePlaceKeys) {
        keys.placeKeys = activeKeys.activePlaceKeys;
      }
    }

    if (filterByActive.scenario) {
      if (activeKeys.activeScenarioKey) {
        keys.scenarioKey = activeKeys.activeScenarioKey;
      } else if (activeKeys.activeScenarioKeys) {
        keys.scenarioKeys = activeKeys.activeScenarioKeys;
      }
    }

    if (filterByActive["case"]) {
      if (activeKeys.activeCaseKey) {
        keys.caseKey = activeKeys.activeCaseKey;
      } else if (activeKeys.activeCaseKeys) {
        keys.caseKeys = activeKeys.activeCaseKeys;
      }
    }

    if (filterByActive.period) {
      if (activeKeys.activePeriodKey) {
        keys.periodKey = activeKeys.activePeriodKey;
      } else if (activeKeys.activePeriodKeys) {
        keys.periodKeys = activeKeys.activePeriodKeys;
      }
    }

    if (filterByActive.layerTemplate && activeKeys.activeLayerTemplateKey) {
      keys.layerTemplateKey = activeKeys.activeLayerTemplateKey;
    }

    if (filterByActive.areaTreeLevel && activeKeys.activeAreaTreeLevelKey) {
      keys.areaTreeLevelKey = activeKeys.activeAreaTreeLevelKey;
    }

    if (filterByActive.application && activeKeys.activeApplicationKey) {
      keys.applicationKey = activeKeys.activeApplicationKey;
    }

    return !_isEmpty__default['default'](keys) ? keys : null;
  } else {
    return null;
  }
})(function (state, filterByActive) {
  return JSON.stringify(filterByActive);
});
var getActiveKeysByFilterByActiveObserver = recompute.createObserver(getActiveKeysByFilterByActive);

var getUsedIndexPages = function getUsedIndexPages(getSubstate) {
  return reselect.createSelector([getIndexedDataUses(getSubstate), getAllActiveKeys], function (indexedDataUses, activeKeys) {
    var groupedUses = [];
    var finalUsedIndexes = [];

    if (!_isEmpty__default['default'](indexedDataUses)) {
      _each__default['default'](indexedDataUses, function (usedIndexes) {
        usedIndexes.forEach(function (usedIndex) {
          var mergedFilter = commonHelpers.mergeFilters(activeKeys, usedIndex.filterByActive, usedIndex.filter);

          var existingIndex = _find__default['default'](groupedUses, function (use) {
            return _isEqual__default['default'](use.filter, mergedFilter) && _isEqual__default['default'](use.order, usedIndex.order);
          });

          if (existingIndex) {
            existingIndex.inUse.push({
              start: usedIndex.start,
              length: usedIndex.length
            });
          } else {
            groupedUses.push({
              filter: mergedFilter,
              order: usedIndex.order,
              inUse: [{
                start: usedIndex.start,
                length: usedIndex.length
              }]
            });
          }
        });
      });
    }

    _each__default['default'](groupedUses, function (index) {
      if (index.inUse && Object.keys(index.inUse).length) {
        finalUsedIndexes.push({
          filter: index.filter,
          order: index.order,
          uses: _mergeIntervals(Object.values(index.inUse))
        });
      }
    });

    return finalUsedIndexes.length ? finalUsedIndexes : null;
  });
};

var getUsesForIndex = function getUsesForIndex(getSubstate) {
  return createCachedSelector__default['default'](getIndexedDataUses(getSubstate), function (state, filter) {
    return filter;
  }, function (state, filter, order) {
    return order;
  }, getAllActiveKeys, function (indexedDataUses, filter, order, activeKeys) {
    var index = null;

    if (!_isEmpty__default['default'](indexedDataUses)) {
      _each__default['default'](indexedDataUses, function (usedIndexes) {
        _each__default['default'](usedIndexes, function (usedIndex) {
          var mergedFilter = commonHelpers.mergeFilters(activeKeys, usedIndex.filterByActive, usedIndex.filter);

          if (_isEqual__default['default'](filter, mergedFilter) && _isEqual__default['default'](order, usedIndex.order)) {
            if (index) {
              index.inUse.push({
                start: usedIndex.start,
                length: usedIndex.length
              });
            } else {
              index = {
                filter: filter,
                order: usedIndex.order,
                inUse: [{
                  start: usedIndex.start,
                  length: usedIndex.length
                }]
              };
            }
          }
        });
      });
    }

    if (index) {
      return {
        filter: index.filter,
        order: index.order,
        uses: _mergeIntervals(Object.values(index.inUse))
      };
    } else {
      return null;
    }
  })(function (state, filter, order) {
    var stringOrder = JSON.stringify(order);
    var stringFilter = JSON.stringify(_map__default['default'](filter, function (value, key) {
      return "".concat(key, ":").concat(value);
    }).sort());
    return "".concat(stringOrder, ":").concat(stringFilter);
  });
};

var getUsesWithActiveDependency = function getUsesWithActiveDependency(getSubstate) {
  /**
   * @param state {Object}
   * @param filterByActive {Object} Something like {scope: true}
   */
  return reselect.createSelector([getIndexedDataUses(getSubstate), getAllActiveKeys, function (state, filterByActive) {
    return filterByActive;
  }],
  /**
   * @param indexedDataUses {Object} inUse.indexes
   * @param activeKeys {Object} active keys of all metadata
   * @param filterByActive {Object} given metadata type active key for filtering (e.g. {scope: true})
   */
  function (indexedDataUses, activeKeys, filterByActive) {
    var groupedUses = []; // uses grouped by filter

    var usedIndexes = [];

    if (filterByActive && !_isEmpty__default['default'](indexedDataUses)) {
      // loop through components
      _map__default['default'](indexedDataUses, function (componentUsedIndexes) {
        // loop through uses for component
        _map__default['default'](componentUsedIndexes, function (usedIndex) {
          if (_reduce__default['default'](filterByActive, function (accumulator, value, index) {
            return accumulator && value && usedIndex.filterByActive && usedIndex.filterByActive[index];
          }, true)) {
            // if usedIndex.filterByActive has all the properties of filterByActive
            var mergedFilter = commonHelpers.mergeFilters(activeKeys, usedIndex.filterByActive, usedIndex.filter);

            var existingIndex = _find__default['default'](groupedUses, function (use) {
              return _isEqual__default['default'](use.filter, mergedFilter) && _isEqual__default['default'](use.order, usedIndex.order);
            });

            if (existingIndex) {
              existingIndex.inUse.push({
                start: usedIndex.start,
                length: usedIndex.length
              });
            } else {
              groupedUses.push({
                filter: mergedFilter,
                order: usedIndex.order,
                inUse: [{
                  start: usedIndex.start,
                  length: usedIndex.length
                }]
              });
            }
          }
        });
      }); // loop through uses grouped by filter and merge intervals


      _map__default['default'](groupedUses, function (index) {
        if (index.inUse && Object.keys(index.inUse).length) {
          usedIndexes.push({
            filter: index.filter,
            order: index.order,
            uses: _mergeIntervals(Object.values(index.inUse))
          });
        }
      });

      return usedIndexes.length ? usedIndexes : null;
    } else {
      return null;
    }
  });
};

var getStateToSave = function getStateToSave(getSubstate) {
  return function (state) {
    var activeKey = getSubstate(state).activeKey;

    if (activeKey) {
      return {
        activeKey: activeKey
      };
    }

    var activeKeys = getSubstate(state).activeKeys;

    if (activeKeys) {
      return {
        activeKeys: activeKeys
      };
    }

    return {};
  };
};

function isInterval(interval) {
  return interval && interval.start && interval.length;
}

function intervalsOverlap(earlier, later) {
  return later.start <= earlier.start + earlier.length;
}

var _mergeIntervals = function _mergeIntervals(intervals) {
  var validIntervals = intervals.filter(isInterval);

  var sortedIntervals = _sortBy__default['default'](validIntervals, ['start', 'length']);

  if (sortedIntervals.length === 0) {
    return null;
  } //merge intervals


  return _tail__default['default'](sortedIntervals).reduce(function (mergedIntervals, interval) {
    var last = mergedIntervals.pop();

    if (intervalsOverlap(last, interval)) {
      //merge last & current
      var end = Math.max(last.start + last.length, interval.start + interval.length);
      return [].concat(_toConsumableArray(mergedIntervals), [{
        start: last.start,
        length: end - last.start
      }]);
    } else {
      //add both
      return [].concat(_toConsumableArray(mergedIntervals), [last, interval]);
    }
  }, [_head__default['default'](sortedIntervals)]);
};

var commonSelectors = {
  getActive: getActive,
  getActiveModels: getActiveModels,
  getActiveKey: getActiveKey,
  getActiveKeys: getActiveKeys,
  getActiveKeysByFilterByActive: getActiveKeysByFilterByActive,
  getAll: getAll,
  getAllActiveKeys: getAllActiveKeys,
  getAllAsObject: getAllAsObject,
  getAllForActiveScope: getAllForActiveScope,
  getByFilterOrder: getByFilterOrder,
  getBatchByFilterOrder: getBatchByFilterOrder,
  getByKey: getByKey,
  getByKeysAsObject: getByKeysAsObject,
  getByKeys: getByKeys,
  getDataByKey: getDataByKey,
  getDeletePermissionByKey: getDeletePermissionByKey,
  getEditedActive: getEditedActive,
  getEditedAll: getEditedAll,
  getEditedAllAsObject: getEditedAllAsObject,
  getEditedByKey: getEditedByKey,
  getEditedDataByKey: getEditedDataByKey,
  getEditedKeys: getEditedKeys,
  getIndex: getIndex$1,
  getIndexByPath: getIndexByPath,
  getIndex_recompute: getIndex_recompute,
  getIndexed: getIndexed,
  getIndexes: getIndexes,
  getIndexChangedOn: getIndexChangedOn,
  getIndexPage: getIndexPage,
  getIndexedPage: getIndexedPage,
  getIndexTotal: getIndexTotal,
  getIndexesByFilteredItem: getIndexesByFilteredItem,
  getKeysToLoad: getKeysToLoad,
  getStateToSave: getStateToSave,
  getUpdatePermissionByKey: getUpdatePermissionByKey,
  getUsesForIndex: getUsesForIndex,
  getUsedIndexPages: getUsedIndexPages,
  getUsedKeys: getUsedKeys,
  getUsesWithActiveDependency: getUsesWithActiveDependency,
  _mergeIntervals: _mergeIntervals,
  // recompute observers
  getActiveKeysByFilterByActiveObserver: getActiveKeysByFilterByActiveObserver
};

var getSubstate$1 = function getSubstate(state) {
  return state._deprecatedSelections;
};

var getActive$1 = commonSelectors.getActive(getSubstate$1);
var getActiveKey$1 = commonSelectors.getActiveKey(getSubstate$1);
var _deprecatedSelections = {
  getActive: getActive$1,
  getActiveKey: getActiveKey$1,
  getSubstate: getSubstate$1
};

var mergeFeaturesWithAttributesCache = new ptrUtils.CacheFifo(20);
var getMergedFilterFromLayerStateAndActiveMetadataKeys = createCachedSelector__default['default']([function (layer) {
  return layer;
}, function (layer, activeMetadataKeys) {
  return activeMetadataKeys;
}, function (layer, activeMetadataKeys, modifiersPath) {
  return modifiersPath;
}], function (layer, activeMetadataKeys, modifiersPath) {
  var filter = _objectSpread2({}, layer[modifiersPath]);

  if (layer.layerTemplateKey) {
    filter.layerTemplateKey = layer.layerTemplateKey;
  }

  if (layer.areaTreeLevelKey) {
    filter.areaTreeLevelKey = layer.areaTreeLevelKey;
  } //todo fail on conflict between metadataModifiers & filterByActive ?
  //todo special filterByActive for attribute data


  var activeFilter = {};

  if (layer.filterByActive) {
    var active = layer.filterByActive;

    if (active.attribute && activeMetadataKeys.activeAttributeKey) {
      activeFilter.attributeKey = activeMetadataKeys.activeAttributeKey;
    }

    if (active["case"] && activeMetadataKeys.activeCaseKey) {
      activeFilter.caseKey = activeMetadataKeys.activeCaseKey;
    }

    if (active.layerTemplate && activeMetadataKeys.activeLayerTemplateKey) {
      activeFilter.layerTemplateKey = activeMetadataKeys.activeLayerTemplateKey;
    }

    if (active.areaTreeLevelKey && activeMetadataKeys.areaTreeLevelKey) {
      activeFilter.areaTreeLevelKey = activeMetadataKeys.areaTreeLevelKey;
    } // TODO what if multiple periods


    if (active.period && activeMetadataKeys.activePeriodKey) {
      activeFilter.periodKey = activeMetadataKeys.activePeriodKey;
    } // TODO what if multiple places


    if (active.place && activeMetadataKeys.activePlaceKey) {
      activeFilter.placeKey = activeMetadataKeys.activePlaceKey;
    }

    if (active.scenario && activeMetadataKeys.activeScenarioKey) {
      activeFilter.scenarioKey = activeMetadataKeys.activeScenarioKey;
    }

    if (active.scope && activeMetadataKeys.activeScopeKey) {
      activeFilter.scopeKey = activeMetadataKeys.activeScopeKey;
    }
  }

  return _objectSpread2(_objectSpread2({}, filter), activeFilter);
})(function (layer, activeMetadataKeys) {
  return "".concat(layer, "_").concat(activeMetadataKeys);
});
var getBackgroundLayersWithFilter = createCachedSelector__default['default']([commonSelectors.getAllActiveKeys, function (state, layerState) {
  return layerState;
}, function (state, layerState, layerKey) {
  return layerKey;
}], function (activeMetadataKeys, layerState, layerKey) {
  layerState = JSON.parse(layerState);
  return [{
    key: layerKey,
    filter: getMergedFilterFromLayerStateAndActiveMetadataKeys(layerState, activeMetadataKeys, 'metadataModifiers')
  }];
})(function (state, layerState, layerKey) {
  return "".concat(layerState, ":").concat(layerKey);
});
var getLayersWithFilter = createCachedSelector__default['default']([commonSelectors.getAllActiveKeys, function (state, layersState) {
  return layersState;
}], function (activeMetadataKeys, layersState) {
  layersState = JSON.parse(layersState);

  if (layersState && layersState.length) {
    return _map__default['default'](layersState, function (layer) {
      return {
        key: layer.key,
        filter: getMergedFilterFromLayerStateAndActiveMetadataKeys(layer, activeMetadataKeys, 'metadataModifiers'),
        attributeFilter: getMergedFilterFromLayerStateAndActiveMetadataKeys(layer, activeMetadataKeys, 'attributeMetadataModifiers')
      };
    });
  } else {
    return null;
  }
})(function (state, layersState) {
  return layersState;
});
/**
 * Create layer deffinition on the base of mandatory parameters.
 * Returns object that is input for Layer from @gisatcz/ptr-maps.
 * @param {string} layerKey 
 * @param {Object} dataSource 
 * @param {?string} fidColumnName Requided for vector layers
 * @param {Number} index Layer order in dataSources
 * @param {Object} layerState 
 * @param {?Object} style 
 * @param {Array} attributeDataSources 
 * @param {Object} selections 
 * @param {Object} layerTemplate 
 * @param {Object} period 
 */

var prepareLayerByDataSourceType = function prepareLayerByDataSourceType(layerKey, dataSource, fidColumnName, index, layerState, style, attributeDataSources, selections, layerTemplate, period) {
  var _layerTemplate$data, _layerTemplate$data2;

  var layerOptions = layerState && layerState.options;
  var dataSourceData = dataSource.data;

  var attribution = dataSourceData.attribution,
      nameInternal = dataSourceData.nameInternal,
      type = dataSourceData.type,
      tableName = dataSourceData.tableName,
      layerName = dataSourceData.layerName,
      features = dataSourceData.features,
      selected = dataSourceData.selected,
      options = _objectWithoutProperties(dataSourceData, ["attribution", "nameInternal", "type", "tableName", "layerName", "features", "selected"]); // TODO data source strucutre


  if (type === 'wmts') {
    options.url = options.urls[0];
  } else if (type === 'wms') {
    var _options = options,
        url = _options.url,
        params = _options.params,
        configuration = _options.configuration,
        rest = _objectWithoutProperties(_options, ["url", "params", "configuration"]);

    var singleTile = configuration && configuration.hasOwnProperty('singleTile') ? configuration.singleTile : false;
    options = {
      params: _objectSpread2(_objectSpread2({}, params), {}, {
        layers: rest.layers,
        styles: rest.styles
      }),
      singleTile: singleTile,
      url: url
    };
  } else if (type === 'vector' && features) {
    if (attributeDataSources) {
      features = mergeFeaturesWithAttributes(layerKey, features, attributeDataSources, fidColumnName);
    }

    if (selections && layerOptions !== null && layerOptions !== void 0 && layerOptions.selected) {
      selected = prepareSelection(selections, layerOptions.selected);
    }

    options = _objectSpread2(_objectSpread2({}, layerOptions), {}, {
      features: features,
      selected: selected,
      fidColumnName: fidColumnName
    }); // TODO type=geoserver

    if (style && style.data && style.data.source === 'definition') {
      options.style = style.data.definition;
    }
  }

  if (period) {
    options.period = period;
  }

  return {
    key: layerKey + '_' + index,
    name: layerState.name || (layerTemplate === null || layerTemplate === void 0 ? void 0 : (_layerTemplate$data = layerTemplate.data) === null || _layerTemplate$data === void 0 ? void 0 : _layerTemplate$data.nameDisplay),
    description: layerTemplate === null || layerTemplate === void 0 ? void 0 : (_layerTemplate$data2 = layerTemplate.data) === null || _layerTemplate$data2 === void 0 ? void 0 : _layerTemplate$data2.description,
    layerKey: layerKey,
    opacity: layerState && layerState.opacity || 1,
    type: type,
    options: options
  };
};

function prepareSelection(selections, layerSelections) {
  var populatedSelections = {};

  _forIn__default['default'](layerSelections, function (value, key) {
    var selectionData = selections === null || selections === void 0 ? void 0 : selections[key].data;

    if (selectionData) {
      var style = selectionData.style; // TODO hovered style

      var color = selectionData.color;
      var hoveredColor = selectionData.hoveredColor;

      if (selectionData.featureKeysFilter) {
        populatedSelections[key] = {
          keys: selectionData.featureKeysFilter.keys
        };

        if (style) {
          populatedSelections[key].style = style;
          populatedSelections[key].hoveredStyle = style;
        } else {
          populatedSelections[key].style = {
            outlineColor: color,
            outlineWidth: 2
          };
          populatedSelections[key].hoveredStyle = {
            outlineColor: hoveredColor,
            outlineWidth: 2
          };
        }
      } //TODO other selection types

    }
  });

  return populatedSelections;
}

function mergeFeaturesWithAttributes(layerKey, features, attributeDataSources, fidColumnName) {
  var cacheKey = JSON.stringify(layerKey);
  var cache = mergeFeaturesWithAttributesCache.findByKey(cacheKey);
  var finalFeaturesObject = {};

  if (cache && cache.features === features) {
    finalFeaturesObject = cache.finalFeaturesObject;
  } else {
    features.forEach(function (feature) {
      var key = feature.properties[fidColumnName];
      finalFeaturesObject[key] = _objectSpread2({}, feature);
    });
  }

  attributeDataSources.forEach(function (attributeDataSource) {
    var featuresWithAttributes = attributeDataSource.dataSource.data.features;

    if (featuresWithAttributes) {
      featuresWithAttributes.forEach(function (featureWithAttributes) {
        var featureKey = featureWithAttributes.properties[fidColumnName];

        _forIn__default['default'](featureWithAttributes.properties, function (value, key) {
          finalFeaturesObject[featureKey].properties[key] = value;
        });
      });
    }
  });
  mergeFeaturesWithAttributesCache.addOrUpdate({
    cacheKey: cacheKey,
    features: features,
    finalFeaturesObject: finalFeaturesObject
  });
  return Object.values(finalFeaturesObject);
}

function getLayersStateWithoutFeatures(layersState) {
  var withoutFeatures = [];

  _each__default['default'](layersState, function (layerState) {
    var _layerState$options;

    if (layerState !== null && layerState !== void 0 && (_layerState$options = layerState.options) !== null && _layerState$options !== void 0 && _layerState$options.features) {
      withoutFeatures.push(_objectSpread2(_objectSpread2({}, layerState), {}, {
        options: _objectSpread2(_objectSpread2({}, layerState.options), {}, {
          features: null
        })
      }));
    } else {
      withoutFeatures.push(layerState);
    }
  });

  return withoutFeatures;
}

var mapHelpers = {
  getBackgroundLayersWithFilter: getBackgroundLayersWithFilter,
  getLayersWithFilter: getLayersWithFilter,
  getLayersStateWithoutFeatures: getLayersStateWithoutFeatures,
  prepareLayerByDataSourceType: prepareLayerByDataSourceType,
  prepareSelection: prepareSelection
};

var getSubstate$2 = function getSubstate(state) {
  return state.layerTemplates;
};

var getActiveKey$2 = commonSelectors.getActiveKey(getSubstate$2);
var getAll$1 = commonSelectors.getAll(getSubstate$2);
var getAllAsObject$1 = commonSelectors.getAllAsObject(getSubstate$2);
var getByKey$1 = commonSelectors.getByKey(getSubstate$2);
var getDataByKey$1 = commonSelectors.getDataByKey(getSubstate$2);
var getDeletePermissionByKey$1 = commonSelectors.getDeletePermissionByKey(getSubstate$2);
var getEditedDataByKey$1 = commonSelectors.getEditedDataByKey(getSubstate$2);
var getUpdatePermissionByKey$1 = commonSelectors.getUpdatePermissionByKey(getSubstate$2);
var getFilteredTemplatesGroupedByLayerKey = createCachedSelector__default['default']([getAllAsObject$1, function (state, layersState) {
  return layersState;
}], function (layerTemplates, layersState) {
  if (layerTemplates && !_isEmpty__default['default'](layerTemplates) && layersState) {
    var layerTemplatesByLayerKey = {};
    layersState.forEach(function (layer) {
      if (layer.filter.layerTemplateKey) {
        layerTemplatesByLayerKey[layer.key] = layerTemplates[layer.filter.layerTemplateKey];
      }
    });
    return layerTemplatesByLayerKey;
  } else {
    return null;
  }
})(function (state, layersState) {
  return layersState.map(function (l) {
    return l.filter && l.filter.layerTemplateKey;
  }).join(',');
});
var getFilteredTemplatesGroupedByLayerTemplateKey = createCachedSelector__default['default']([getAllAsObject$1, function (state, layersState) {
  return layersState;
}], function (layerTemplates, layersState) {
  if (layerTemplates && !_isEmpty__default['default'](layerTemplates) && layersState) {
    var layerTemplatesByLayerKey = {};
    layersState.forEach(function (layer) {
      if (layer.filter.layerTemplateKey) {
        layerTemplatesByLayerKey[layer.filter.layerTemplateKey] = layerTemplates[layer.filter.layerTemplateKey];
      }
    });
    return layerTemplatesByLayerKey;
  } else {
    return null;
  }
})(function (state, layersState) {
  return layersState.map(function (l) {
    return l.filter && l.filter.layerTemplateKey;
  }).join(',');
});
var LayerTemplates = {
  getActiveKey: getActiveKey$2,
  getAll: getAll$1,
  getAllAsObject: getAllAsObject$1,
  getByKey: getByKey$1,
  getDataByKey: getDataByKey$1,
  getDeletePermissionByKey: getDeletePermissionByKey$1,
  getEditedDataByKey: getEditedDataByKey$1,
  getIndexed: commonSelectors.getIndexed(getSubstate$2),
  getUpdatePermissionByKey: getUpdatePermissionByKey$1,
  getFilteredTemplatesGroupedByLayerKey: getFilteredTemplatesGroupedByLayerKey,
  getFilteredTemplatesGroupedByLayerTemplateKey: getFilteredTemplatesGroupedByLayerTemplateKey,
  getSubstate: getSubstate$2
};

var getSubstate$3 = function getSubstate(state) {
  return state.spatialVectorDataSources;
};

var getAll$2 = commonSelectors.getAll(getSubstate$3);
var getAllAsObject$2 = commonSelectors.getAllAsObject(getSubstate$3);
var getByKey$2 = commonSelectors.getByKey(getSubstate$3);
var getBatchByFilterOrder$1 = commonSelectors.getBatchByFilterOrder(getSubstate$3);
var getDataByKey$2 = commonSelectors.getDataByKey(getSubstate$3);

var getEditedFeatures = function getEditedFeatures(state) {
  return state.spatialDataSources.vector.editedFeaturesBySourceKey;
};

var noMemoGetFeaturesBySourceKey = function noMemoGetFeaturesBySourceKey(state, props) {
  return state.spatialDataSources.vector.featuresBySourceKey[props.dataSourceKey];
};

var noMemoGetEditedFeaturesBySourceKey = function noMemoGetEditedFeaturesBySourceKey(state, props) {
  return state.spatialDataSources.vector.editedFeaturesBySourceKey[props.dataSourceKey];
};

var noMemoGetSelectedFeaturesKeysBySourceKey = function noMemoGetSelectedFeaturesKeysBySourceKey(state, props) {
  return state.spatialDataSources.vector.selectedFeaturesKeysBySourceKey[props.dataSourceKey];
};

var noMemoGetSelectedFeaturesBySourceKey = function noMemoGetSelectedFeaturesBySourceKey(state, props) {
  return _filter__default['default'](noMemoGetFeaturesBySourceKey(state, props), function (feature) {
    return _includes__default['default'](noMemoGetSelectedFeaturesKeysBySourceKey(state, props), feature.key);
  });
};

var vectorSelectors = {
  noMemoGetFeaturesBySourceKey: noMemoGetFeaturesBySourceKey,
  noMemoGetEditedFeaturesBySourceKey: noMemoGetEditedFeaturesBySourceKey,
  noMemoGetSelectedFeaturesBySourceKey: noMemoGetSelectedFeaturesBySourceKey,
  getBatchByFilterOrder: getBatchByFilterOrder$1,
  getSubstate: getSubstate$3,
  getEditedFeatures: getEditedFeatures,
  getAll: getAll$2,
  getAllAsObject: getAllAsObject$2,
  getByKey: getByKey$2,
  getDataByKey: getDataByKey$2
};

var getSubstate$4 = function getSubstate(state) {
  return state.areaRelations;
};

var getAll$3 = commonSelectors.getAll(getSubstate$4);
/**
 * @return {Array|null}
 */

var getAllData = reselect.createSelector([getAll$3], function (relations) {
  if (relations) {
    return _map__default['default'](relations, function (relation) {
      return relation.data;
    });
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param filter {Object}
 * @returns {Array|null}
 */

var getFilteredData = reselect.createSelector([getAllData, function (state, filter) {
  return filter;
}], function (relations, filter) {
  if (relations && relations.length > 0 && filter && !_isEmpty__default['default'](filter)) {
    return _filter__default['default'](relations, filter);
  } else {
    return null;
  }
});
/**
 * @returns {Object}
 */

var getFilteredDataSourceKeysGroupedByLayerKey = createCachedSelector__default['default']([getAll$3, function (state, layers) {
  return layers;
}], function (relations, layers) {
  if (relations && relations.length) {
    var filteredGroupedByLayerKey = {};

    _forEach__default['default'](layers, function (layer) {
      var filteredRelations = _filter__default['default'](relations, {
        'data': layer.filter
      });

      if (filteredRelations.length) {
        filteredGroupedByLayerKey[layer.key] = filteredRelations.map(function (relation) {
          return {
            spatialDataSourceKey: relation.data.spatialDataSourceKey,
            fidColumnName: relation.data.fidColumnName
          };
        });
      }
    });

    return !_isEmpty__default['default'](filteredGroupedByLayerKey) ? filteredGroupedByLayerKey : null;
  } else {
    return null;
  }
})(function (state, layers) {
  return JSON.stringify(layers);
});
var AreaRelations = {
  getSubstate: getSubstate$4,
  getFilteredData: getFilteredData,
  getFilteredDataSourceKeysGroupedByLayerKey: getFilteredDataSourceKeysGroupedByLayerKey
};

var getSubstate$5 = function getSubstate(state) {
  return state.spatialRelations;
};

var getAll$4 = commonSelectors.getAll(getSubstate$5);
var getByKey$3 = commonSelectors.getByKey(getSubstate$5);
var getByKeys$1 = commonSelectors.getByKeys(getSubstate$5);
/**
 * @return {Array|null}
 */

var getAllData$1 = reselect.createSelector([getAll$4], function (relations) {
  if (relations) {
    return _map__default['default'](relations, function (relation) {
      return relation.data;
    });
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param filter {Object}
 * @returns {Array|null}
 */

var getFilteredData$1 = reselect.createSelector([getAllData$1, function (state, filter) {
  return filter;
}], function (relations, filter) {
  if (relations && relations.length > 0 && filter && !_isEmpty__default['default'](filter)) {
    return _filter__default['default'](relations, filter);
  } else {
    return null;
  }
});
/**
 * @returns {Object}
 */

var getFilteredDataSourceKeysGroupedByLayerKey$1 = createCachedSelector__default['default']([getAll$4, function (state, layers) {
  return layers;
}], function (relations, layers) {
  if (relations && relations.length) {
    var filteredGroupedByLayerKey = {};

    _forEach__default['default'](layers, function (layer) {
      var filteredRelations = _filter__default['default'](relations, {
        'data': layer.filter
      });

      if (filteredRelations.length) {
        filteredGroupedByLayerKey[layer.key] = filteredRelations.map(function (relation) {
          return {
            spatialDataSourceKey: relation.data.spatialDataSourceKey,
            fidColumnName: relation.data.fidColumnName
          };
        });
      }
    });

    return !_isEmpty__default['default'](filteredGroupedByLayerKey) ? filteredGroupedByLayerKey : null;
  } else {
    return null;
  }
})(function (state, layers) {
  return JSON.stringify(layers);
});
/**
 * @returns {Object}
 */

var getFilteredDataGroupedByLayerTemplateKey = createCachedSelector__default['default']([getAll$4, function (state, layers) {
  return layers;
}], function (relations, layers) {
  if (relations && relations.length) {
    var filteredGroupedByLayerKey = {};

    _forEach__default['default'](layers, function (layer) {
      var filteredRelations = _filter__default['default'](relations, {
        'data': layer.filter
      });

      var layerTemplateKey = layer.filter.layerTemplateKey;

      if (layerTemplateKey && filteredRelations.length) {
        filteredGroupedByLayerKey[layerTemplateKey] = filteredRelations;
      }
    });

    return !_isEmpty__default['default'](filteredGroupedByLayerKey) ? filteredGroupedByLayerKey : null;
  } else {
    return null;
  }
})(function (state, layersState) {
  return layersState.map(function (l) {
    return l.filter && l.filter.layerTemplateKey;
  }).join(',');
});
/********************************
 DEPRECATED
 ********************************/

/**
 * Collect and prepare relations for given filters grouped by layer key
 *
 * @param state {Object}
 * @param layers {Array | null} Collection of layers data. Each object in collection contains filter property (it is used for selecting of relations) and data property (which contains data about layer from map state - e.g. key).
 */

var getFilteredDataGroupedByLayerKey = reselect.createSelector([getAllData$1, function (state, layers) {
  return layers;
}],
/**
 * @param relations {Array | null} list of all relations data
 * @param layers {Array | null}
 * @return {Object | null} Selected relations grouped by layer key
 */
function (relations, layers) {
  if (layers && !_isEmpty__default['default'](layers)) {
    var groupedRelations = {};
    layers.forEach(function (layer) {
      var layerKey = layer.key || layer.data && layer.data.key;

      if (layerKey) {
        if (relations && relations.length) {
          var filter = _cloneDeep__default['default'](layer.filter); //TODO
          //sapatial data should not be filtered by period and attributeKey


          delete filter.attributeKey;

          var filteredRelations = _filter__default['default'](relations, filter);

          if (!_isEmpty__default['default'](filteredRelations)) {
            groupedRelations[layerKey] = filteredRelations;
          } else {
            groupedRelations[layerKey] = [null];
          }
        } else {
          groupedRelations[layerKey] = [null];
        }
      }
    });
    return !_isEmpty__default['default'](groupedRelations) ? groupedRelations : null;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param filter {Object}
 */

var getDataSourceKeysFiltered = reselect.createSelector([getFilteredData$1], function (filteredRelations) {
  if (filteredRelations && filteredRelations.length) {
    return _map__default['default'](filteredRelations, function (relation) {
      return relation.spatialDataSourceKey;
    });
  } else {
    return null;
  }
});
/**
 * Filter spatialRelationsData by layerTemplateKeys.
 *
 * @param state {Object}
 * @param layerTemplateKeys {Array | null} Array of layerTemplateKeys.
 */

var getDataSourceRelationsByLayerTemplateKeys = reselect.createSelector([getAllData$1, function (state, layerTemplateKeys) {
  return layerTemplateKeys;
}], function (allData, layerTemplateKeys) {
  if (allData && !_isEmpty__default['default'](allData) && layerTemplateKeys && !_isEmpty__default['default'](layerTemplateKeys)) {
    var filtered = allData.filter(function (i) {
      return layerTemplateKeys.includes(i.layerTemplateKey);
    });
    return !_isEmpty__default['default'](filtered) ? filtered : null;
  } else {
    return null;
  }
}); // TODO wtf?

/**
 * Collect and prepare data relations grouped by layer key
 *
 * @param state {Object}
 * @param layers {Array | null} Collection of layers data. Each object in collection contains filter property (it is used for selecting of relations) and data property (which contains data about layer from map state - e.g. key).
 */

var getDataSourceRelationsGroupedByLayerKey = reselect.createSelector([getFilteredDataGroupedByLayerKey],
/**
 * @param groupedRelations {null | Object} Relations grouped by layer key
 * @return {null | Object} Data sources keys grouped by layer key
 */
function (groupedRelations) {
  if (groupedRelations) {
    var groupedDataSourceKeys = {};

    _forIn__default['default'](groupedRelations, function (relationsData, layerKey) {
      groupedDataSourceKeys[layerKey] = relationsData;
    });

    return !_isEmpty__default['default'](groupedDataSourceKeys) ? groupedDataSourceKeys : null;
  } else {
    return null;
  }
});
/**
 * Collect and prepare data sources keys grouped by layer key
 *
 * @param state {Object}
 * @param layers {Array | null} Collection of layers data. Each object in collection contains filter property (it is used for selecting of relations) and data property (which contains data about layer from map state - e.g. key).
 */

var getDataSourceKeysGroupedByLayerKey = reselect.createSelector([getDataSourceRelationsGroupedByLayerKey],
/**
 * @param groupedRelations {null | Object} Relations grouped by layer key
 * @return {null | Object} Data sources keys grouped by layer key
 */
function (groupedRelations) {
  if (groupedRelations) {
    var groupedRelationsDataSource = {};

    for (var _i = 0, _Object$entries = Object.entries(groupedRelations); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      groupedRelationsDataSource[key] = value.map(function (r) {
        return r ? r.spatialDataSourceKey : null;
      });
    }

    return groupedRelationsDataSource;
  } else {
    return null;
  }
});
/**
 * Collect and prepare data sources keys grouped by layer key
 *
 * @param state {Object}
 * @param layers {Array | null} Collection of layers data. Each object in collection contains filter property (it is used for selecting of relations) and data property (which contains data about layer from map state - e.g. key).
 */

var getDataSourceRelationsForLayerKey = reselect.createSelector([getDataSourceRelationsGroupedByLayerKey, function (state, layers) {
  return layers;
}, //FIXME -> create selector for layers
function (state, layerKey) {
  return layerKey;
}],
/**
 * @param groupedRelations {null | Object} Relations grouped by layer key
 * @return {null | Object} Data sources keys grouped by layer key
 */
function (groupedRelations, layerKey) {
  if (groupedRelations) {
    return groupedRelations[layerKey] || null;
  } else {
    return null;
  }
});
var SpatialRelations = {
  getSubstate: getSubstate$5,
  getByKey: getByKey$3,
  getByKeys: getByKeys$1,
  getAllData: getAllData$1,
  getFilteredData: getFilteredData$1,
  getFilteredDataSourceKeysGroupedByLayerKey: getFilteredDataSourceKeysGroupedByLayerKey$1,
  getFilteredDataGroupedByLayerTemplateKey: getFilteredDataGroupedByLayerTemplateKey,
  // Deprecated
  getDataSourceKeysFiltered: getDataSourceKeysFiltered,
  getDataSourceKeysGroupedByLayerKey: getDataSourceKeysGroupedByLayerKey,
  getDataSourceRelationsGroupedByLayerKey: getFilteredDataGroupedByLayerKey,
  getDataSourceRelationsByLayerTemplateKeys: getDataSourceRelationsByLayerTemplateKeys,
  getDataSourceRelationsForLayerKey: getDataSourceRelationsForLayerKey,
  getFilteredDataGroupedByLayerKey: getFilteredDataGroupedByLayerKey
};

var getSubstate$6 = function getSubstate(state) {
  return state.spatialData;
};

var getAllAsObject$3 = commonSelectors.getAllAsObject(getSubstate$6);
var getByKey$4 = commonSelectors.getByKey(getSubstate$6);
var SpatialData = {
  getAllAsObject: getAllAsObject$3,
  getByKey: getByKey$4,
  getSubstate: getSubstate$6
};

var getSubstate$7 = function getSubstate(state) {
  return state.spatialDataSources;
};

var getAllAsObject$4 = commonSelectors.getAllAsObject(getSubstate$7);
var getByKeys$2 = commonSelectors.getByKeys(getSubstate$7);
var getByKey$5 = commonSelectors.getByKey(getSubstate$7);
var getFilteredSourcesGroupedByLayerKey = createCachedSelector__default['default']([getAllAsObject$4, SpatialRelations.getFilteredDataSourceKeysGroupedByLayerKey, AreaRelations.getFilteredDataSourceKeysGroupedByLayerKey, SpatialData.getAllAsObject], function (dataSources, spatialRelationsDataSourceKeysGroupedByLayerKey, areaRelationsDataSourceKeysGroupedByLayerKey, spatialData) {
  var dataSourceKeysGroupedByLayerKey = {};

  if (areaRelationsDataSourceKeysGroupedByLayerKey) {
    dataSourceKeysGroupedByLayerKey = _objectSpread2(_objectSpread2({}, dataSourceKeysGroupedByLayerKey), areaRelationsDataSourceKeysGroupedByLayerKey);
  }

  if (spatialRelationsDataSourceKeysGroupedByLayerKey) {
    dataSourceKeysGroupedByLayerKey = _objectSpread2(_objectSpread2({}, dataSourceKeysGroupedByLayerKey), spatialRelationsDataSourceKeysGroupedByLayerKey);
  }

  if (dataSourceKeysGroupedByLayerKey && !_isEmpty__default['default'](dataSources)) {
    var dataSourcesGroupedByLayerKey = {};

    _forIn__default['default'](dataSourceKeysGroupedByLayerKey, function (dataSourceKeysAndFidColumns, layerKey) {
      dataSourcesGroupedByLayerKey[layerKey] = [];

      _forEach__default['default'](dataSourceKeysAndFidColumns, function (dataSourceKeyAndFidColumn) {
        if (dataSources[dataSourceKeyAndFidColumn.spatialDataSourceKey]) {
          var finalDataSource = _objectSpread2({}, dataSources[dataSourceKeyAndFidColumn.spatialDataSourceKey]);

          var data = spatialData[dataSourceKeyAndFidColumn.spatialDataSourceKey];

          if (data && data.spatialData && data.spatialData.features) {
            finalDataSource.data.features = data.spatialData.features;
          }

          dataSourcesGroupedByLayerKey[layerKey].push({
            dataSource: finalDataSource,
            fidColumnName: dataSourceKeyAndFidColumn.fidColumnName
          });
        }
      });
    });

    return dataSourcesGroupedByLayerKey;
  } else {
    return null;
  }
})(function (state, layers) {
  return JSON.stringify(layers);
});
/**************************************************
 DEPRECATED
 **************************************************/

/**
 * Collect and prepare data sources grouped by layer key
 *
 * @param state {Object}
 * @param layers {Array} Collection of layers data. Each object in collection contains filter property (it is used for selecting of relations) and data property (which contains data about layer from map state - e.g. key).
 */

var getFilteredGroupedByLayerKey = reselect.createSelector([getAllAsObject$4, SpatialRelations.getDataSourceKeysGroupedByLayerKey, SpatialRelations.getDataSourceRelationsGroupedByLayerKey],
/**
 * @param dataSources {null | Object} all available data sources
 * @param groupedKeys {null | Object} Data sources keys grouped by layer key
 * @return {null | Object} Data sources grouped by layer key
 */
function (dataSources, groupedKeys, groupedRelations) {
  if (groupedKeys && Object.keys(dataSources).length) {
    var groupedSources = {};

    _forIn__default['default'](groupedKeys, function (keys, layerKey) {
      var sources = [];
      keys.forEach(function (key) {
        if (key && dataSources && !_isEmpty__default['default'](dataSources) && dataSources[key] && !_isEmpty__default['default'](groupedRelations) && groupedRelations[layerKey]) {
          sources.push(_objectSpread2(_objectSpread2({}, dataSources[key]), {}, {
            spatialRelationData: _find__default['default'](groupedRelations[layerKey], function (o) {
              return o.spatialDataSourceKey === key;
            }) || null
          }));
        } else {
          sources.push(null);
        }
      });
      groupedSources[layerKey] = sources;
    });

    return groupedSources;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param filter {Object}
 * @returns {Array|null}
 */

var getFilteredData$2 = reselect.createSelector([getAllAsObject$4, function (state, filter) {
  return filter;
}], function (spatialDataSources, filter) {
  if (spatialDataSources && spatialDataSources.length > 0 && filter && !_isEmpty__default['default'](filter)) {
    return _filter__default['default'](spatialDataSources, filter);
  } else {
    return null;
  }
});
var SpatialDataSources = {
  getSubstate: getSubstate$7,
  getByKey: getByKey$5,
  getByKeys: getByKeys$2,
  getFilteredSourcesGroupedByLayerKey: getFilteredSourcesGroupedByLayerKey,
  // Deprecated
  getFilteredGroupedByLayerKey: getFilteredGroupedByLayerKey,
  getFilteredData: getFilteredData$2,
  vector: vectorSelectors
};

var getSubstate$8 = function getSubstate(state) {
  return state.attributeRelations;
};

var getAll$5 = commonSelectors.getAll(getSubstate$8);
var getIndexed$1 = commonSelectors.getIndexed(getSubstate$8);
var getFilteredDataSourceKeysWithFidColumn = createCachedSelector__default['default']([getAll$5, function (state, filter) {
  return filter;
}], function (relations, filter) {
  if (relations && relations.length) {
    // TODO more sophisticated filtering
    var attributeKeys = filter.attributeKey["in"] || [filter.attributeKey];

    var filterWithoutAttributes = _omit__default['default'](filter, 'attributeKey');

    var preFilteredRelations = _filter__default['default'](relations, {
      'data': filterWithoutAttributes
    });

    var filteredRelations = _filter__default['default'](preFilteredRelations, function (relation) {
      if (relation.data.attributeKey) {
        return !!_includes__default['default'](attributeKeys, relation.data.attributeKey);
      } else {
        return true;
      }
    });

    if (filteredRelations.length) {
      return filteredRelations.map(function (relation) {
        return {
          attributeDataSourceKey: relation.data.attributeDataSourceKey,
          attributeKey: relation.data.attributeKey,
          periodKey: relation.data.periodKey,
          fidColumnName: relation.data.fidColumnName
        };
      });
    } else {
      return null;
    }
  } else {
    return null;
  }
})(function (state, filter) {
  return JSON.stringify(filter);
});
var getFilteredDataSourceKeysWithFidColumnGroupedByLayerKey = createCachedSelector__default['default']([getAll$5, function (state, layersWithFilter) {
  return layersWithFilter;
}, function (state, layersWithFilter, layersState) {
  return layersState;
}], function (relations, layersWithFilter, layersState) {
  if (relations && relations.length) {
    var filteredGroupedByLayerKey = {};

    _forEach__default['default'](layersWithFilter, function (layer) {
      var layerState = _find__default['default'](layersState, {
        key: layer.key
      });

      var attributeKeys = layerState.attributeKeys;

      if (attributeKeys) {
        // TODO more sophisticated filtering
        var preFilteredRelations = _filter__default['default'](relations, {
          'data': layer.attributeFilter
        });

        var filteredRelations = _filter__default['default'](preFilteredRelations, function (relation) {
          if (relation.data.attributeKey) {
            return !!_includes__default['default'](attributeKeys, relation.data.attributeKey);
          } else {
            return true;
          }
        });

        if (filteredRelations.length) {
          filteredGroupedByLayerKey[layer.key] = filteredRelations.map(function (relation) {
            return {
              attributeDataSourceKey: relation.data.attributeDataSourceKey,
              attributeKey: relation.data.attributeKey,
              fidColumnName: relation.data.fidColumnName
            };
          });
        }
      } else {
        return null;
      }
    });

    return !_isEmpty__default['default'](filteredGroupedByLayerKey) ? filteredGroupedByLayerKey : null;
  } else {
    return null;
  }
})(function (state, layersWithFilter, layersState, layersStateAsString) {
  return layersStateAsString;
}); // DEPRECATED ---------------------

var getAllData$2 = reselect.createSelector([getAll$5], function (relations) {
  if (relations) {
    return _map__default['default'](relations, function (relation) {
      return relation.data;
    });
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param filter {Object}
 */

var getFiltered = reselect.createSelector([getAllData$2, function (state, filter) {
  return filter;
}], function (relations, filter) {
  if (relations && relations.length > 0 && filter && !_isEmpty__default['default'](filter)) {
    return _filter__default['default'](relations, filter);
  } else {
    return null;
  }
});
var getFilteredRelations = createCachedSelector__default['default']([getAllData$2, function (state, filter) {
  return filter;
}], function (relations, filter) {
  if (relations && relations.length > 0 && filter && !_isEmpty__default['default'](filter)) {
    return _filter__default['default'](relations, function (relation) {
      var fitsFilter = true;

      _forIn__default['default'](filter, function (value, key) {
        if (relation.hasOwnProperty(key)) {
          if (_isObject__default['default'](value) && value["in"] && _isArray__default['default'](value["in"])) {
            if (!_includes__default['default'](value["in"], relation[key])) {
              fitsFilter = false;
            }
          } else if (relation[key] !== value) {
            fitsFilter = false;
          }
        }
      });

      return fitsFilter;
    });
  } else {
    return null;
  }
})(function (state, filter, cacheKey) {
  if (cacheKey) {
    return JSON.stringify(filter) + ':' + JSON.stringify(cacheKey);
  } else {
    return JSON.stringify(filter);
  }
});
var getDataSourcesFromFilteredRelations = createCachedSelector__default['default']([getFilteredRelations], function (filteredRelations) {
  if (filteredRelations) {
    return filteredRelations.map(function (relation) {
      return {
        attributeDataSourceKey: relation.attributeDataSourceKey,
        fidColumnName: relation.fidColumnName
      };
    });
  } else {
    return null;
  }
})(function (state, filter, cacheKey) {
  return "".concat(JSON.stringify(filter), ":").concat(JSON.stringify(cacheKey));
});
/**
 * @param state {Object}
 * @param filter {Object}
 * 
 * filter
 * {
 * 	layerTemplateKey
 *	scopeKey
 *	periodKey
 *	caseKey
 *	scenarioKey
 *	placeKey
 *	attributeKey
 * }
 */

var getDataSourceKeyFiltered = reselect.createSelector([getFiltered], function (filteredRelations) {
  if (filteredRelations && !_isEmpty__default['default'](filteredRelations)) {
    //relation is only for one data, so return first
    return filteredRelations[0].dataSourceKey;
  } else {
    return null;
  } // if (filteredRelations && filteredRelations.length) {
  // 	return _.find(filteredRelations, relation => relation.dataSourceKey);
  // } else {
  // 	return null;
  // }

});
/**
 * Collect and prepare relations for given filters grouped by layer key
 *
 * @param state {Object}
 * @param layers {Array | null} Collection of layers data. Each object in collection contains filter property (it is used for selecting of relations) and data property (which contains data about layer from map state - e.g. key).
 */

var getFilteredDataGroupedByLayerKey$1 = reselect.createSelector([getAllData$2, function (state, layers) {
  return layers;
}],
/**
 * @param relations {Array | null} list of all relations data
 * @param layers {Array | null}
 * @return {Object | null} Selected relations grouped by layer key
 */
function (relations, layers) {
  if (layers && !_isEmpty__default['default'](layers)) {
    var groupedRelations = {};
    layers.forEach(function (layer) {
      if (layer.data && layer.data.key) {
        if (relations) {
          var filteredRelations = _filter__default['default'](relations, layer.filter);

          if (!_isEmpty__default['default'](filteredRelations)) {
            groupedRelations[layer.data.key] = filteredRelations;
          } else {
            groupedRelations[layer.data.key] = [null];
          }
        } else {
          groupedRelations[layer.data.key] = [null];
        }
      }
    });
    return !_isEmpty__default['default'](groupedRelations) ? groupedRelations : null;
  } else {
    return null;
  }
});
/**
 * Collect and prepare data relations grouped by layer key
 *
 * @param state {Object}
 * @param layers {Array | null} Collection of layers data. Each object in collection contains filter property (it is used for selecting of relations) and data property (which contains data about layer from map state - e.g. key).
 */

var getDataSourceRelationsGroupedByLayerKey$1 = reselect.createSelector([getFilteredDataGroupedByLayerKey$1],
/**
 * @param groupedRelations {null | Object} Relations grouped by layer key
 * @return {null | Object} Data sources keys grouped by layer key
 */
function (groupedRelations) {
  if (groupedRelations) {
    var groupedDataSourceKeys = {};

    _forIn__default['default'](groupedRelations, function (relationsData, layerKey) {
      groupedDataSourceKeys[layerKey] = relationsData;
    });

    return !_isEmpty__default['default'](groupedDataSourceKeys) ? groupedDataSourceKeys : null;
  } else {
    return null;
  }
});
/**
 * Collect and prepare data sources keys grouped by layer key
 *
 * @param state {Object}
 * @param layers {Array | null} Collection of layers data. Each object in collection contains filter property (it is used for selecting of relations) and data property (which contains data about layer from map state - e.g. key).
 */

var getDataSourceKeysGroupedByLayerKey$1 = reselect.createSelector([getDataSourceRelationsGroupedByLayerKey$1],
/**
 * @param groupedRelations {null | Object} Relations grouped by layer key
 * @return {null | Object} Data sources keys grouped by layer key
 */
function (groupedRelations) {
  if (groupedRelations) {
    var groupedRelationsDataSource = {};

    for (var _i = 0, _Object$entries = Object.entries(groupedRelations); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      groupedRelationsDataSource[key] = value.map(function (r) {
        return r ? r.attributeDataSourceKey : null;
      });
    }

    return groupedRelationsDataSource;
  } else {
    return null;
  }
});
var selectors = {
  getFilteredDataSourceKeysWithFidColumn: getFilteredDataSourceKeysWithFidColumn,
  getFilteredDataSourceKeysWithFidColumnGroupedByLayerKey: getFilteredDataSourceKeysWithFidColumnGroupedByLayerKey,
  getIndexed: getIndexed$1,
  getAllData: getAllData$2,
  getDataSourceKeyFiltered: getDataSourceKeyFiltered,
  getFiltered: getFiltered,
  getFilteredRelations: getFilteredRelations,
  getFilteredDataGroupedByLayerKey: getFilteredDataGroupedByLayerKey$1,
  getDataSourceRelationsGroupedByLayerKey: getDataSourceRelationsGroupedByLayerKey$1,
  getDataSourceKeysGroupedByLayerKey: getDataSourceKeysGroupedByLayerKey$1,
  getDataSourcesFromFilteredRelations: getDataSourcesFromFilteredRelations,
  getSubstate: getSubstate$8
};

var getSubstate$9 = function getSubstate(state) {
  return state.attributeData;
};

var getAllAsObject$5 = commonSelectors.getAllAsObject(getSubstate$9);
var getBatchByFilterOrder$2 = commonSelectors.getBatchByFilterOrder(getSubstate$9);
var getByKey$6 = commonSelectors.getByKey(getSubstate$9); // DEPRECATED -------------------------------------------

/**
 * Collect and prepare data sources grouped by layer key
 *
 * @param state {Object}
 * @param filter {Object}
 *	 @param attributeKey {string}
 *	 @param scopeKey {string}
 *	 @param periodKey {string}
 *	 @param caseKey {string}
 *	 @param scenarioKey {string}
 *	 @param placeKey {string}
 */

var getFiltered$1 = reselect.createSelector([getAllAsObject$5, selectors.getDataSourceKeyFiltered],
/**
 * @param dataSources {null | Object} all available data sources
 * @param dataSourceKey {String} Data sources key
 * @return {null | Object} Data source
 */
function (dataSources, dataSourceKey) {
  if (dataSourceKey && dataSources && !_isEmpty__default['default'](dataSources) && dataSources[dataSourceKey]) {
    return dataSources[dataSourceKey];
  } else {
    return null;
  }
});
var getFilteredGroupedByFid = createCachedSelector__default['default']([getAllAsObject$5, selectors.getDataSourcesFromFilteredRelations], function (allDataSources, filtered) {
  if (allDataSources && !_isEmpty__default['default'](allDataSources) && filtered) {
    var data = {};

    _map__default['default'](filtered, function (filteredSource) {
      var source = allDataSources[filteredSource.attributeDataSourceKey];
      var keySource = filteredSource.fidColumnName;
      var nameSource = filteredSource.fidColumnName;

      if (source && source.attributeData && source.attributeData.features) {
        var features = source.attributeData.features;

        _map__default['default'](features, function (feature) {
          var key = feature.properties[keySource];

          var _feature$properties = feature.properties,
              keyName = _feature$properties[keySource],
              props = _objectWithoutProperties(_feature$properties, [keySource].map(_toPropertyKey));

          var values = [];
          var existingKey = data[key];

          _map__default['default'](props, function (value, key) {
            if (existingKey) {
              existingKey.data.values.push({
                key: key,
                value: value
              });
            } else {
              values.push({
                key: key,
                value: value
              });
            }
          });

          if (!existingKey) {
            data[key] = {
              key: key,
              data: {
                name: feature.properties[nameSource],
                values: values
              }
            };
          }
        });
      }
    });

    return _values__default['default'](data);
  } else {
    return null;
  }
})(function (state, mergedFilter) {
  return "".concat(JSON.stringify(mergedFilter));
});
var getNamesByFid = createCachedSelector__default['default']([getAllAsObject$5, selectors.getDataSourcesFromFilteredRelations], function (allDataSources, filtered) {
  if (allDataSources && !_isEmpty__default['default'](allDataSources) && filtered) {
    var data = {};

    if (filtered.length === 1) {
      var filteredSource = filtered[0];
      var source = allDataSources[filteredSource.attributeDataSourceKey];
      var keySource = filteredSource.fidColumnName;

      if (source && source.attributeData && source.attributeData.features) {
        var features = source.attributeData.features;

        _map__default['default'](features, function (feature) {
          var key = feature.properties[keySource];

          var _feature$properties2 = feature.properties,
              keyName = _feature$properties2[keySource],
              props = _objectWithoutProperties(_feature$properties2, [keySource].map(_toPropertyKey));

          data[key] = {
            key: key,
            data: {
              name: _values__default['default'](props)[0]
            }
          };
        });
      }

      return _values__default['default'](data);
    } else {
      return null;
    }
  } else {
    return null;
  }
})(function (state, filter, cacheKey) {
  return "".concat(JSON.stringify(filter), ":").concat(JSON.stringify(cacheKey));
});
/**
 * Collect and prepare data sources grouped by layer key
 *
 * @param state {Object}
 * @param layers {Array} Collection of layers data. Each object in collection contains filter property (it is used for selecting of relations) and data property (which contains data about layer from map state - e.g. key).
 */

var getFilteredGroupedByLayerKey$1 = reselect.createSelector([getAllAsObject$5, selectors.getDataSourceKeysGroupedByLayerKey, selectors.getDataSourceRelationsGroupedByLayerKey],
/**
 * @param dataSources {null | Object} all available data sources
 * @param groupedKeys {null | Object} Data sources keys grouped by layer key
 * @return {null | Object} Data sources grouped by layer key
 */
function (dataSources, groupedKeys, groupedRelations) {
  if (groupedKeys) {
    var groupedSources = {};

    _forIn__default['default'](groupedKeys, function (keys, layerKey) {
      var sources = [];

      _map__default['default'](keys, function (key) {
        if (key && dataSources && !_isEmpty__default['default'](dataSources) && dataSources[key] && !_isEmpty__default['default'](groupedRelations) && groupedRelations[layerKey]) {
          sources.push(_objectSpread2(_objectSpread2({}, dataSources[key]), {}, {
            attributeRelationData: _find__default['default'](groupedRelations[layerKey], function (o) {
              return o.attributeDataSourceKey === key;
            }) || null
          }));
        } else {
          sources.push(null);
        }
      });

      groupedSources[layerKey] = sources;
    });

    return groupedSources;
  } else {
    return null;
  }
});
var selectors$1 = {
  getSubstate: getSubstate$9,
  getAllAsObject: getAllAsObject$5,
  getByKey: getByKey$6,
  getFiltered: getFiltered$1,
  getBatchByFilterOrder: getBatchByFilterOrder$2,
  getFilteredGroupedByLayerKey: getFilteredGroupedByLayerKey$1,
  getFilteredGroupedByFid: getFilteredGroupedByFid,
  getNamesByFid: getNamesByFid
};

var getSubstate$a = function getSubstate(state) {
  return state.attributeDataSources;
};

var getAllAsObject$6 = commonSelectors.getAllAsObject(getSubstate$a);
var getBatchByFilterOrder$3 = commonSelectors.getBatchByFilterOrder(getSubstate$a);
var getByKey$7 = commonSelectors.getByKey(getSubstate$a);
var getByKeys$3 = commonSelectors.getByKeys(getSubstate$a);
var getFilteredDataSources = createCachedSelector__default['default']([getAllAsObject$6, selectors.getFilteredDataSourceKeysWithFidColumn, selectors$1.getAllAsObject, function (state, filter) {
  return filter;
}], function (dataSources, dataSourcesWithFidColumn, attributeData, filter) {
  if (!_isEmpty__default['default'](dataSourcesWithFidColumn) && attributeData && dataSources) {
    var finalDataSources = [];

    _forEach__default['default'](dataSourcesWithFidColumn, function (dataSourceWithFidColumn) {
      var key = dataSourceWithFidColumn.attributeDataSourceKey;

      var finalDataSource = _objectSpread2({}, dataSources[key]);

      var data = attributeData[key];

      if (data && data.attributeData && data.attributeData.features) {
        finalDataSource.data.features = data.attributeData.features.map(function (feature) {
          var _properties;

          return {
            properties: (_properties = {}, _defineProperty(_properties, dataSourceWithFidColumn.attributeKey, feature.properties[finalDataSource.data.columnName]), _defineProperty(_properties, dataSourceWithFidColumn.fidColumnName, feature.properties[dataSourceWithFidColumn.fidColumnName]), _properties)
          };
        });
      }

      finalDataSources.push({
        dataSource: finalDataSource,
        attributeKey: dataSourceWithFidColumn.attributeKey,
        periodKey: dataSourceWithFidColumn.periodKey,
        fidColumnName: dataSourceWithFidColumn.fidColumnName
      });
    });

    return finalDataSources.length ? finalDataSources : null;
  } else {
    return null;
  }
})(function (state, filter) {
  return JSON.stringify(filter);
});
var getFilteredDataSourcesGroupedByLayerKey = createCachedSelector__default['default']([selectors.getFilteredDataSourceKeysWithFidColumnGroupedByLayerKey, getAllAsObject$6, selectors$1.getAllAsObject, function (state, layersWithFilter, layersState) {
  return layersState;
}], function (dataSourcesDataByLayerKey, dataSources, attributeData, layersState) {
  if (dataSourcesDataByLayerKey && !_isEmpty__default['default'](dataSources)) {
    var dataSourcesGroupedByLayerKey = {};

    _forIn__default['default'](dataSourcesDataByLayerKey, function (dataSourceKeysAndFidColumns, layerKey) {
      dataSourcesGroupedByLayerKey[layerKey] = [];

      _forEach__default['default'](dataSourceKeysAndFidColumns, function (dataSourceKeyAndFidColumn) {
        if (dataSources[dataSourceKeyAndFidColumn.attributeDataSourceKey]) {
          var finalDataSource = _objectSpread2({}, dataSources[dataSourceKeyAndFidColumn.attributeDataSourceKey]);

          var data = attributeData[dataSourceKeyAndFidColumn.attributeDataSourceKey];

          if (data && data.attributeData && data.attributeData.features) {
            finalDataSource.data.features = data.attributeData.features.map(function (feature) {
              var _properties2;

              return {
                properties: (_properties2 = {}, _defineProperty(_properties2, dataSourceKeyAndFidColumn.attributeKey, feature.properties[finalDataSource.data.columnName]), _defineProperty(_properties2, dataSourceKeyAndFidColumn.fidColumnName, feature.properties[dataSourceKeyAndFidColumn.fidColumnName]), _properties2)
              };
            });
          }

          dataSourcesGroupedByLayerKey[layerKey].push({
            dataSource: finalDataSource,
            attributeKey: dataSourceKeyAndFidColumn.attributeKey,
            fidColumnName: dataSourceKeyAndFidColumn.fidColumnName
          });
        }
      });
    });

    return dataSourcesGroupedByLayerKey;
  } else {
    return null;
  }
})(function (state, layersWithFilter, layersState, layersStateAsString) {
  return layersStateAsString;
});
/**
 * Collect and prepare data sources grouped by layer key
 *
 * @param state {Object}
 * @param filter {Object}
 *	 @param attributeKey {string}
 *	 @param scopeKey {string}
 *	 @param periodKey {string}
 *	 @param caseKey {string}
 *	 @param scenarioKey {string}
 *	 @param placeKey {string}
 */

var getFiltered$2 = reselect.createSelector([getAllAsObject$6, selectors.getDataSourceKeyFiltered],
/**
 * @param dataSources {null | Object} all available data sources
 * @param dataSourceKey {String} Data sources key
 * @return {null | Object} Data source
 */
function (dataSources, dataSourceKey) {
  if (dataSourceKey && dataSources && !_isEmpty__default['default'](dataSources) && dataSources[dataSourceKey]) {
    return dataSources[dataSourceKey];
  } else {
    return null;
  }
});
/**
 * Collect and prepare data sources grouped by layer key
 *
 * @param state {Object}
 * @param layers {Array} Collection of layers data. Each object in collection contains filter property (it is used for selecting of relations) and data property (which contains data about layer from map state - e.g. key).
 */

var getFilteredGroupedByLayerKey$2 = reselect.createSelector([getAllAsObject$6, selectors.getDataSourceKeysGroupedByLayerKey, selectors.getDataSourceRelationsGroupedByLayerKey],
/**
 * @param dataSources {null | Object} all available data sources
 * @param groupedKeys {null | Object} Data sources keys grouped by layer key
 * @return {null | Object} Data sources grouped by layer key
 */
function (dataSources, groupedKeys, groupedRelations) {
  if (groupedKeys) {
    var groupedSources = {};

    _forIn__default['default'](groupedKeys, function (keys, layerKey) {
      var sources = [];

      _map__default['default'](keys, function (key) {
        if (key && dataSources && !_isEmpty__default['default'](dataSources) && dataSources[key] && !_isEmpty__default['default'](groupedRelations) && groupedRelations[layerKey]) {
          sources.push(_objectSpread2(_objectSpread2({}, dataSources[key]), {}, {
            attributeRelationData: _find__default['default'](groupedRelations[layerKey], function (o) {
              return o.attributeDataSourceKey === key;
            }) || null
          }));
        } else {
          sources.push(null);
        }
      });

      groupedSources[layerKey] = sources;
    });

    return groupedSources;
  } else {
    return null;
  }
});
var selectors$2 = {
  getSubstate: getSubstate$a,
  getFilteredDataSources: getFilteredDataSources,
  getFilteredDataSourcesGroupedByLayerKey: getFilteredDataSourcesGroupedByLayerKey,
  getFiltered: getFiltered$2,
  getBatchByFilterOrder: getBatchByFilterOrder$3,
  getFilteredGroupedByLayerKey: getFilteredGroupedByLayerKey$2,
  getByKey: getByKey$7,
  getByKeys: getByKeys$3
};

var getKey = function getKey(state) {
  return state.app.key;
};

var getCompleteConfiguration = function getCompleteConfiguration(state) {
  return state.app.configuration;
};

var getCompleteLocalConfiguration = function getCompleteLocalConfiguration(state) {
  return state.app.localConfiguration;
};

var getConfiguration = reselect.createSelector([getCompleteConfiguration, function (state, path) {
  return path;
}], function (configuration, path) {
  return _get__default['default'](configuration, path, null);
});
var getLocalConfiguration = reselect.createSelector([getCompleteLocalConfiguration, function (state, path) {
  return path;
}], function (localConfiguration, path) {
  return _get__default['default'](localConfiguration, path, null);
});
var selectors$3 = {
  getKey: getKey,
  getConfiguration: getConfiguration,
  getCompleteConfiguration: getCompleteConfiguration,
  getLocalConfiguration: getLocalConfiguration,
  getCompleteLocalConfiguration: getCompleteLocalConfiguration
};

var getSubstate$b = function getSubstate(state) {
  return state.styles;
};

var getAll$6 = commonSelectors.getAll(getSubstate$b);
var getAllAsObject$7 = commonSelectors.getAllAsObject(getSubstate$b);
var getByKey$8 = commonSelectors.getByKey(getSubstate$b);
var getByKeyObserver = recompute.createObserver(getByKey$8);
var getDefinitionByKey = recompute.createSelector(function (key) {
  var _style$data;

  var style = getByKeyObserver(key);
  return (style === null || style === void 0 ? void 0 : (_style$data = style.data) === null || _style$data === void 0 ? void 0 : _style$data.definition) || null;
});
var getGroupedByLayerKey = createCachedSelector__default['default']([getAllAsObject$7, function (state, layersState) {
  return layersState;
}], function (styles, layersState) {
  if (styles && !_isEmpty__default['default'](styles) && layersState) {
    var stylesByLayerKey = {};
    layersState.forEach(function (layer) {
      if (layer.styleKey) {
        stylesByLayerKey[layer.key] = styles[layer.styleKey];
      }
    });
    return stylesByLayerKey;
  } else {
    return null;
  }
})(function (state, layerState, layersStateAsString) {
  return layersStateAsString;
});
var Styles = {
  getAll: getAll$6,
  getAllAsObject: getAllAsObject$7,
  getByKey: getByKey$8,
  getDefinitionByKey: getDefinitionByKey,
  getIndexed: commonSelectors.getIndexed(getSubstate$b),
  getGroupedByLayerKey: getGroupedByLayerKey,
  getSubstate: getSubstate$b
};

var getSubstate$c = function getSubstate(state) {
  return state.selections;
};

var getActive$2 = commonSelectors.getActive(getSubstate$c);
var getActiveKey$3 = commonSelectors.getActiveKey(getSubstate$c);
var getAllAsObject$8 = commonSelectors.getAllAsObject(getSubstate$c);
var getAll$7 = commonSelectors.getAll(getSubstate$c);
var getAllAsObjectWithStyles = reselect.createSelector([getAllAsObject$8, Styles.getAllAsObject], function (selections, allStyles) {
  if (selections) {
    if (allStyles) {
      var selectionsWithStyles = {};

      _forIn__default['default'](selections, function (selection, key) {
        var _selection$data;

        var styleKey = (_selection$data = selection.data) === null || _selection$data === void 0 ? void 0 : _selection$data.styleKey;

        if (styleKey && allStyles[styleKey]) {
          var _allStyles$styleKey$d, _allStyles$styleKey$d2, _allStyles$styleKey$d3, _allStyles$styleKey$d4;

          var selectionStyle = (_allStyles$styleKey$d = allStyles[styleKey].data) === null || _allStyles$styleKey$d === void 0 ? void 0 : (_allStyles$styleKey$d2 = _allStyles$styleKey$d.definition) === null || _allStyles$styleKey$d2 === void 0 ? void 0 : (_allStyles$styleKey$d3 = _allStyles$styleKey$d2.rules) === null || _allStyles$styleKey$d3 === void 0 ? void 0 : (_allStyles$styleKey$d4 = _allStyles$styleKey$d3[0].styles) === null || _allStyles$styleKey$d4 === void 0 ? void 0 : _allStyles$styleKey$d4[0]; // TODO get first style of first rule for now

          if (selectionStyle) {
            selectionsWithStyles[key] = _objectSpread2(_objectSpread2({}, selection), {}, {
              data: _objectSpread2(_objectSpread2({}, selection.data), {}, {
                style: selectionStyle
              })
            });
          } else {
            selectionsWithStyles[key] = selection;
          }
        } else {
          selectionsWithStyles[key] = selection;
        }
      });

      return selectionsWithStyles;
    } else {
      return selections;
    }
  } else {
    return null;
  }
});
var getByKeyObserver$1 = recompute.createObserver(function (state, key) {
  return state.selections.byKey[key];
});
var prepareSelectionByLayerStateSelected = recompute.createSelector(function (layerStateSelected) {
  var populatedSelections = {};

  _forIn__default['default'](layerStateSelected, function (value, key) {
    var selection = getByKeyObserver$1(key);
    var selectionData = selection === null || selection === void 0 ? void 0 : selection.data;

    if (selectionData) {
      var style = selectionData.style;
      var hoveredStyle = selectionData.hoveredStyle || style;
      var color = selectionData.color;
      var hoveredColor = selectionData.hoveredColor || color;

      if (selectionData.featureKeysFilter) {
        populatedSelections[key] = {
          keys: selectionData.featureKeysFilter.keys
        };

        if (style) {
          populatedSelections[key].style = style;
          populatedSelections[key].hoveredStyle = hoveredStyle;
        } else {
          populatedSelections[key].style = {
            outlineColor: color,
            outlineWidth: 2
          };
          populatedSelections[key].hoveredStyle = {
            outlineColor: hoveredColor,
            outlineWidth: 2
          };
        }
      } //TODO other selection types

    }
  });

  return populatedSelections;
});
var Selections = {
  getActiveKey: getActiveKey$3,
  getActive: getActive$2,
  getAll: getAll$7,
  getAllAsObject: getAllAsObject$8,
  getAllAsObjectWithStyles: getAllAsObjectWithStyles,
  prepareSelectionByLayerStateSelected: prepareSelectionByLayerStateSelected
};

var getSubstate$d = function getSubstate(state) {
  return state.periods;
};

var getAll$8 = commonSelectors.getAll(getSubstate$d);
var getAllAsObject$9 = commonSelectors.getAllAsObject(getSubstate$d);
var getAllForActiveScope$1 = commonSelectors.getAllForActiveScope(getSubstate$d);
var getActive$3 = commonSelectors.getActive(getSubstate$d);
var getActiveKey$4 = commonSelectors.getActiveKey(getSubstate$d);
var getActiveKeys$1 = commonSelectors.getActiveKeys(getSubstate$d);
var getActiveModels$1 = commonSelectors.getActiveModels(getSubstate$d);
var getByKey$9 = commonSelectors.getByKey(getSubstate$d);
var getByKeys$4 = commonSelectors.getByKeys(getSubstate$d);
var getDataByKey$3 = commonSelectors.getDataByKey(getSubstate$d);
var getDeletePermissionByKey$2 = commonSelectors.getDeletePermissionByKey(getSubstate$d);
var getEditedDataByKey$2 = commonSelectors.getEditedDataByKey(getSubstate$d);
var getIndexed$2 = commonSelectors.getIndexed(getSubstate$d);
var getUpdatePermissionByKey$2 = commonSelectors.getUpdatePermissionByKey(getSubstate$d);
var getKeysByAttributeRelations = createCachedSelector__default['default']([selectors.getFilteredRelations], function (filteredRelations) {
  if (filteredRelations) {
    return _map__default['default'](filteredRelations, function (relation) {
      return relation.periodKey;
    });
  } else {
    return null;
  }
})(function (state, filter, cacheKey) {
  return JSON.stringify(filter) + ':' + JSON.stringify(cacheKey);
});
/**
 * Both start and end time must be defined, otherwise all available periods are returned.
 */

var getByFullPeriodAsObject = createCachedSelector__default['default']([getAllAsObject$9, function (state, start) {
  return start;
}, function (state, start, end) {
  return end;
}], function (periods, start, end) {
  if (periods && start && end) {
    return _pickBy__default['default'](periods, function (period) {
      var periodStart = period.data && period.data.start;
      var periodEnd = period.data && period.data.end;

      if (periodStart && periodEnd) {
        return moment__default['default'](periodStart).isBetween(start, end, null, '[]') && moment__default['default'](periodEnd).isBetween(start, end, null, '[]');
      } else if (periodStart) {
        return moment__default['default'](periodStart).isBetween(start, end, null, '[]');
      } else if (periodEnd) {
        return moment__default['default'](periodEnd).isBetween(start, end, null, '[]');
      } else {
        return true;
      }
    });
  } else {
    return periods;
  }
})(function (state, start, end) {
  return "".concat(start, "_").concat(end);
});
var getFilteredGroupedByLayerTemplateKey = createCachedSelector__default['default']([getAllAsObject$9, SpatialRelations.getFilteredDataGroupedByLayerTemplateKey, function (state, layersState) {
  return layersState;
}], function (periods, spatialRelationsDataGroupedByLayerTemplateKey, layersState) {
  if (periods && !_isEmpty__default['default'](periods) && spatialRelationsDataGroupedByLayerTemplateKey && !_isEmpty__default['default'](spatialRelationsDataGroupedByLayerTemplateKey) && layersState) {
    var periodsByLayerKey = {};

    for (var _i = 0, _Object$entries = Object.entries(spatialRelationsDataGroupedByLayerTemplateKey); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          layerTemplateKey = _Object$entries$_i[0],
          spatialRelations = _Object$entries$_i[1];

      periodsByLayerKey[layerTemplateKey] = spatialRelations.map(function (spatialRelation) {
        if (periods[spatialRelation.data.periodKey]) {
          return periods[spatialRelation.data.periodKey];
        }
      });
      periodsByLayerKey[layerTemplateKey].filter(function (i) {
        return i;
      }); //filter empty
    }

    return periodsByLayerKey;
  } else {
    return null;
  }
})(function (state, layersState) {
  return layersState.map(function (l) {
    return l.filter && l.filter.layerTemplateKey;
  }).join(',');
});
var getFilteredGroupedByLayerKey$3 = createCachedSelector__default['default']([getAllAsObject$9, SpatialRelations.getFilteredDataGroupedByLayerKey, function (state, layersState) {
  return layersState;
}], function (periods, spatialRelationsDataGroupedByLayerKey, layersState) {
  if (periods && !_isEmpty__default['default'](periods) && spatialRelationsDataGroupedByLayerKey && !_isEmpty__default['default'](spatialRelationsDataGroupedByLayerKey) && layersState) {
    var periodsByLayerKey = {};

    for (var _i2 = 0, _Object$entries2 = Object.entries(spatialRelationsDataGroupedByLayerKey); _i2 < _Object$entries2.length; _i2++) {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
          layerKey = _Object$entries2$_i[0],
          spatialRelations = _Object$entries2$_i[1];

      periodsByLayerKey[layerKey] = spatialRelations.map(function (spatialRelation) {
        if (periods[spatialRelation.periodKey]) {
          return periods[spatialRelation.periodKey];
        }
      });
      periodsByLayerKey[layerKey].filter(function (i) {
        return i;
      }); //filter empty
    }

    return periodsByLayerKey;
  } else {
    return null;
  }
})(function (state, layersState) {
  return layersState.map(function (l) {
    return l.key;
  }).join(',');
});
var Periods = {
  getActive: getActive$3,
  getActiveKey: getActiveKey$4,
  getActiveKeys: getActiveKeys$1,
  getActiveModels: getActiveModels$1,
  getAll: getAll$8,
  getAllAsObject: getAllAsObject$9,
  getAllForActiveScope: getAllForActiveScope$1,
  getByKey: getByKey$9,
  getByKeys: getByKeys$4,
  getByFullPeriodAsObject: getByFullPeriodAsObject,
  getDataByKey: getDataByKey$3,
  getDeletePermissionByKey: getDeletePermissionByKey$2,
  getEditedDataByKey: getEditedDataByKey$2,
  getFilteredGroupedByLayerTemplateKey: getFilteredGroupedByLayerTemplateKey,
  getFilteredGroupedByLayerKey: getFilteredGroupedByLayerKey$3,
  getIndexed: getIndexed$2,
  getKeysByAttributeRelations: getKeysByAttributeRelations,
  getUpdatePermissionByKey: getUpdatePermissionByKey$2,
  getSubstate: getSubstate$d,
  // TODO handle old selectors export
  getActivePeriod: getActive$3,
  getPeriods: getAll$8
};

var defaultMapView = {
  center: {
    lat: 50.099577,
    lon: 14.425960
  },
  boxRange: 10000000,
  tilt: 0,
  roll: 0,
  heading: 0
};
var mapConstants = {
  defaultMapView: defaultMapView
};
var getBackgroundLayerCache = new ptrUtils.CacheFifo(10);
var getLayersCache = new ptrUtils.CacheFifo(10);
/* ===== Basic selectors ==================== */

var getSubstate$e = function getSubstate(state) {
  return state._deprecatedMaps;
};

var getMapsAsObject = function getMapsAsObject(state) {
  return state._deprecatedMaps.maps;
};

var getMapSetsAsObject = function getMapSetsAsObject(state) {
  return state._deprecatedMaps.sets;
};

var getActiveSetKey = function getActiveSetKey(state) {
  return state._deprecatedMaps.activeSetKey;
};

var getActiveMapKey = function getActiveMapKey(state) {
  return state._deprecatedMaps.activeMapKey;
};

var getActiveMap = reselect.createSelector([getMapsAsObject, getActiveMapKey], function (maps, activeKey) {
  if (maps && !_isEmpty__default['default'](maps) && activeKey && maps[activeKey]) {
    return maps[activeKey];
  } else {
    return null;
  }
});
var getMaps = reselect.createSelector([getMapsAsObject], function (maps) {
  if (maps && !_isEmpty__default['default'](maps)) {
    return Object.values(maps);
  } else {
    return null;
  }
});
var getMapSets = reselect.createSelector([getMapSetsAsObject], function (sets) {
  if (sets && !_isEmpty__default['default'](sets)) {
    return Object.values(sets);
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapByKey = createCachedSelector__default['default']([getMapsAsObject, function (state, key) {
  return key;
}], function (maps, key) {
  if (maps && !_isEmpty__default['default'](maps) && key) {
    return maps[key] ? maps[key] : null;
  } else {
    return null;
  }
})(function (state, key) {
  return key;
});
var getMapLayersByMapKey = reselect.createSelector([getMapByKey], function (map) {
  return map && map.data && map.data.layers || null;
});
/**
 * @param state {Object}
 * @param setKey {string}
 */

var getMapSetByKey = reselect.createSelector([getMapSetsAsObject, function (state, key) {
  return key;
}], function (sets, key) {
  if (sets && !_isEmpty__default['default'](sets) && key) {
    return sets[key] ? sets[key] : null;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapSetByMapKey = reselect.createSelector([getMapSets, function (state, mapKey) {
  return mapKey;
}], function (sets, mapKey) {
  if (sets && !_isEmpty__default['default'](sets) && mapKey) {
    var setForMap = null;
    sets.forEach(function (set) {
      if (set.maps && _includes__default['default'](set.maps, mapKey)) {
        setForMap = set;
      }
    });
    return setForMap;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param setKey {string}
 */

var getMapSetMapKeys = reselect.createSelector([getMapSetByKey], function (set) {
  if (set && set.maps && set.maps.length) {
    return set.maps;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapBackgroundLayerStateByMapKey = reselect.createSelector([getMapByKey], function (map) {
  if (map && map.data && map.data.backgroundLayer) {
    return map.data.backgroundLayer;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapLayersStateByMapKey = reselect.createSelector([getMapByKey], function (map) {
  if (map && map.data && map.data.layers) {
    return map.data.layers;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapMetadataModifiersByMapKey = reselect.createSelector([getMapByKey], function (map) {
  if (map && map.data && map.data.metadataModifiers) {
    return map.data.metadataModifiers;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapFilterByActiveByMapKey = reselect.createSelector([getMapByKey], function (map) {
  if (map && map.data && map.data.filterByActive) {
    return map.data.filterByActive;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapSetBackgroundLayerStateByMapKey = reselect.createSelector([getMapSetByMapKey], function (set) {
  if (set && set.data && set.data.backgroundLayer) {
    return set.data.backgroundLayer;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapSetLayersStateByMapKey = reselect.createSelector([getMapSetByMapKey], function (set) {
  if (set && set.data && set.data.layers) {
    return set.data.layers;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapSetMetadataModifiersByMapKey = reselect.createSelector([getMapSetByMapKey], function (set) {
  if (set && set.data && set.data.metadataModifiers) {
    return set.data.metadataModifiers;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapSetFilterByActiveByMapKey = reselect.createSelector([getMapSetByMapKey], function (set) {
  if (set && set.data && set.data.filterByActive) {
    return set.data.filterByActive;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapSetKey {string}
 */

var getMapSetLayersStateBySetKey = reselect.createSelector([getMapSetByKey], function (set) {
  if (set && set.data && set.data.layers) {
    return set.data.layers;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapKey {string}
 * @param layerKey {string}
 */

var getMapLayerByMapKeyAndLayerKey = reselect.createSelector([getMapLayersStateByMapKey, function (state, mapKey, layerKey) {
  return layerKey;
}], function (layers, layerKey) {
  if (layers && layerKey) {
    return layers.find(function (l) {
      return l.key === layerKey;
    });
  } else {
    return null;
  }
});
/* ===== Combined selectors ==================== */

/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getFilterByActiveByMapKey = createCachedSelector__default['default']([getMapFilterByActiveByMapKey, getMapSetFilterByActiveByMapKey], function (mapFilter, setFilter) {
  return (setFilter || mapFilter) && _objectSpread2(_objectSpread2({}, setFilter), mapFilter);
})(function (state, mapKey) {
  return mapKey;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getBackgroundLayerStateByMapKey = createCachedSelector__default['default']([getMapBackgroundLayerStateByMapKey, getMapSetBackgroundLayerStateByMapKey], function (mapBackgroundLayer, setBackgroundLayer) {
  return mapBackgroundLayer || setBackgroundLayer;
})(function (state, mapKey) {
  return "".concat(mapKey);
});
/**
 * @param state {Object}
 * @param mapKey {string}
 * @return {Object} Merged layer state from mapState and mapSetState with metadataModifiers and filterByActive.
 */

var getLayersStateByMapKey = createCachedSelector__default['default']([getMapLayersStateByMapKey, getMapSetLayersStateByMapKey, getMapMetadataModifiersByMapKey, getMapSetMetadataModifiersByMapKey, getFilterByActiveByMapKey], function (mapLayers, setLayers, mapMetadataModifiers, setMetadataModifiers, mapFilterByActive) {
  if (mapLayers || setLayers) {
    var layers = [].concat(_toConsumableArray(setLayers || []), _toConsumableArray(mapLayers || []));
    var modifiers = {};

    if (setMetadataModifiers) {
      modifiers = setMetadataModifiers;
    }

    modifiers = _objectSpread2(_objectSpread2({}, modifiers), mapMetadataModifiers);
    layers = layers.map(function (layer) {
      var layerMetadataModifiers = layer.metadataModifiers ? _objectSpread2(_objectSpread2({}, modifiers), layer.metadataModifiers) : modifiers;
      var layerFilterByActive = layer.filterByActive ? _objectSpread2(_objectSpread2({}, mapFilterByActive), layer.filterByActive) : mapFilterByActive;
      return _objectSpread2(_objectSpread2({}, layer), {}, {
        metadataModifiers: layerMetadataModifiers,
        filterByActive: layerFilterByActive
      });
    }); // TODO return error for duplicates?

    return _uniqBy__default['default'](layers, 'key');
  } else {
    return null;
  }
})(function (state, mapKey) {
  return mapKey;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getAllLayersStateByMapKey = reselect.createSelector([getBackgroundLayerStateByMapKey, getLayersStateByMapKey], function (backgroundLayer, layers) {
  if (layers || backgroundLayer) {
    layers = layers || [];

    if (backgroundLayer) {
      // TODO do not create new object for background layer on change in layers
      backgroundLayer = _objectSpread2(_objectSpread2({}, backgroundLayer), {}, {
        key: 'pantherBackgroundLayer'
      });
      return [backgroundLayer].concat(_toConsumableArray(layers));
    }

    return layers;
  } else {
    return null;
  }
});
/**
 * Get active map key for set. Either local, or global.
 *
 * @param state {Object}
 * @param setKey {string}
 */

var getMapSetActiveMapKey = reselect.createSelector([getActiveMapKey, getMapSetByKey], function (mapKey, set) {
  if (set) {
    var mapKeyInSet = _includes__default['default'](set.maps, mapKey);

    return set.activeMapKey || mapKeyInSet && mapKey || null;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getView = createCachedSelector__default['default']([getMapByKey, getMapSetByMapKey], function (map, set) {
  if (map) {
    if (set) {
      var mapView = map.data && map.data.view; // omit synced view params from map

      if (set.sync && !_isEmpty__default['default'](set.sync)) {
        mapView = _omitBy__default['default'](mapView, function (viewValue, viewKey) {
          return set.sync[viewKey];
        });
      }

      var mapSetView = set.data && set.data.view;
      var view = ptrUtils.map.view.mergeViews(mapConstants.defaultMapView, mapSetView, mapView);
      return !_isEmpty__default['default'](view) ? view : null;
    } else {
      var _view = map.data && map.data.view;

      return ptrUtils.map.view.mergeViews(mapConstants.defaultMapView, _view);
    }
  } else {
    return null;
  }
})(function (state, mapKey) {
  return mapKey;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getViewLimits = createCachedSelector__default['default']([getMapByKey, getMapSetByMapKey], function (map, set) {
  if (map) {
    if (set) {
      var _map$data, _set$data;

      var mapViewLimits = (_map$data = map.data) === null || _map$data === void 0 ? void 0 : _map$data.viewLimits;
      var mapSetViewLimits = (_set$data = set.data) === null || _set$data === void 0 ? void 0 : _set$data.viewLimits;
      var viewLimits = ptrUtils.map.view.mergeViews(mapSetViewLimits, mapViewLimits);
      return !_isEmpty__default['default'](viewLimits) ? viewLimits : null;
    } else {
      var _map$data2;

      return (_map$data2 = map.data) === null || _map$data2 === void 0 ? void 0 : _map$data2.viewLimits;
    }
  } else {
    return null;
  }
})(function (state, mapKey) {
  return mapKey;
});
/**
 * @param state {Object}
 * @param setKey {string}
 */

var getMapSetView = reselect.createSelector([getMapSetByKey], function (set) {
  if (set) {
    var setView = set.data && set.data.view;
    return ptrUtils.map.view.mergeViews(mapConstants.defaultMapView, setView);
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param setKey {string}
 */

var getMapSetViewLimits = reselect.createSelector([getMapSetByKey], function (set) {
  var _set$data2;

  return (set === null || set === void 0 ? void 0 : (_set$data2 = set.data) === null || _set$data2 === void 0 ? void 0 : _set$data2.viewLimits) || null;
});
var getMapSetActiveMapView = reselect.createSelector([getMapSetActiveMapKey, getMapSetByKey, getMapsAsObject], function (mapKey, set, maps) {
  var map = maps[mapKey];

  if (map) {
    if (set) {
      var mapView = map.data && map.data.view; // omit synced view params from map

      if (set.sync && !_isEmpty__default['default'](set.sync)) {
        mapView = _omitBy__default['default'](mapView, function (viewValue, viewKey) {
          return set.sync[viewKey];
        });
      }

      var mapSetView = set.data && set.data.view;
      var view = ptrUtils.map.view.mergeViews(mapConstants.defaultMapView, mapSetView, mapView);
      return !_isEmpty__default['default'](view) ? view : null;
    } else {
      var _view2 = map.data && map.data.view;

      return ptrUtils.map.view.mergeViews(mapConstants.defaultMapView, _view2);
    }
  } else {
    return null;
  }
});
/* ===== Complex selectors ========================= */
// TODO cache?

var getBackgroundLayer = function getBackgroundLayer(state, layerState) {
  if (layerState) {
    if (layerState.type) {
      // TODO helper
      return layerState;
    } else {
      var layerKey = 'pantherBackgroundLayer'; // TODO valid approach to stringify parameter?

      var layersWithFilter = mapHelpers.getBackgroundLayersWithFilter(state, JSON.stringify(layerState), layerKey);
      var dataSourcesByLayerKey = SpatialDataSources.getFilteredSourcesGroupedByLayerKey(state, layersWithFilter);

      if (dataSourcesByLayerKey && dataSourcesByLayerKey[layerKey]) {
        // TODO experimental
        var cacheKey = JSON.stringify(layersWithFilter);
        var cache = getBackgroundLayerCache.findByKey(cacheKey);
        var layerDataSources = dataSourcesByLayerKey[layerKey];

        if (cache && cache.layersWithFilter === layersWithFilter && cache.layerDataSources === layerDataSources) {
          return cache.mapLayers;
        } else {
          var mapLayers = _map__default['default'](dataSourcesByLayerKey[layerKey], function (dataSourceWithFidColumn, index) {
            return mapHelpers.prepareLayerByDataSourceType(layerKey, dataSourceWithFidColumn.dataSource, dataSourceWithFidColumn.fidColumnName, index);
          });

          getBackgroundLayerCache.addOrUpdate({
            cacheKey: cacheKey,
            layersWithFilter: layersWithFilter,
            layerDataSources: layerDataSources,
            mapLayers: mapLayers
          });
          return mapLayers;
        }
      } else {
        return null;
      }
    }
  } else {
    return null;
  }
}; // TODO cache?

/**
 * @param state {Object}
 * @param mapKey {string}
 * @return {Array}
 */


var getMapBackgroundLayer = function getMapBackgroundLayer(state, mapKey) {
  var layerState = getBackgroundLayerStateByMapKey(state, mapKey);
  return getBackgroundLayer(state, layerState);
};
/**
 * Use this function for getting layer deffinition if layer is defined in state.
 * Check if dataSources for layerKey are loaded and defined otherwise return null.
 * Returns object that is input for Layer from @gisatcz/ptr-maps.
 * @param {Object} state App state
 * @param {Object} layerState Merged layer state from mapState and mapSetState with metadataModifiers and filterByActive.
 * @param {Object} dataSourcesByLayerKey dataSources related to layerState.key
 * @param {Object} attributeDataSourcesByLayerKey attributeDataSources related to layerState.key
 * @param {Object} stylesByLayerKey styles related to layerState.key
 * @param {Object} selections selections related to layerState.key
 * @param {Object} layerTemplatesByLayerKey layerTemplates related to layerState.key
 * @param {Object} periodsByLayerKey periods related to layerState.key
 */


var getLayerFromState = function getLayerFromState(state, layerState, dataSourcesByLayerKey, attributeDataSourcesByLayerKey, stylesByLayerKey, selections, layerTemplatesByLayerKey, periodsByLayerKey) {
  var layerKey = layerState.key;
  var dataSources = dataSourcesByLayerKey[layerKey];
  var attributeDataSources = attributeDataSourcesByLayerKey && attributeDataSourcesByLayerKey[layerKey];
  var style = stylesByLayerKey && stylesByLayerKey[layerKey];
  var layerTemplate = layerTemplatesByLayerKey && layerTemplatesByLayerKey[layerKey];
  var period = periodsByLayerKey && periodsByLayerKey[layerKey];
  var layer = null;

  if (dataSources && dataSources.length) {
    dataSources.forEach(function (dataSourceWithFidColumn, index) {
      var dataSource = dataSourceWithFidColumn && dataSourceWithFidColumn.dataSource;
      var fidColumnName = dataSourceWithFidColumn && dataSourceWithFidColumn.fidColumnName; // TODO remove - quick solution for geoinv

      var currentApp = selectors$3.getKey(state);

      if (currentApp === 'tacrGeoinvaze') {
        var apiGeoserverWMSProtocol = selectors$3.getLocalConfiguration(state, 'apiGeoserverWMSProtocol');
        var apiGeoserverWMSHost = selectors$3.getLocalConfiguration(state, 'apiGeoserverWMSHost');
        var apiGeoserverWMSPath = selectors$3.getLocalConfiguration(state, 'apiGeoserverWMSPath');

        if (dataSource && dataSource.data && dataSource.data.layerName && (dataSource.data.type === "vector" || dataSource.data.type === "raster")) {
          layer = {
            key: layerKey + '_' + dataSource.key,
            layerKey: layerKey,
            type: "wms",
            options: {
              url: apiGeoserverWMSProtocol + "://" + path.join(apiGeoserverWMSHost, apiGeoserverWMSPath),
              params: {
                layers: dataSource.data.layerName
              }
            }
          };
        } else {
          layer = mapHelpers.prepareLayerByDataSourceType(layerKey, dataSource, fidColumnName, index);
        }
      } else if (dataSource && dataSource.data) {
        layer = mapHelpers.prepareLayerByDataSourceType(layerKey, dataSource, fidColumnName, index, layerState, style, attributeDataSources, selections, layerTemplate, period);
      }
    });
  }

  return layer;
}; // TODO caching is experimental

/**
 * Returns Array of objects that is input for Layer from @gisatcz/ptr-maps.
 * @param {Object} state App state
 * @param {Array} layersState 
 */


var getLayers = function getLayers(state, layersState) {
  // TODO valid approach to stringify parameter?
  var layersStateAsString = JSON.stringify(mapHelpers.getLayersStateWithoutFeatures(layersState));
  var layersWithFilter = mapHelpers.getLayersWithFilter(state, layersStateAsString);

  if (layersWithFilter && layersWithFilter.length) {
    var dataSourcesByLayerKey = SpatialDataSources.getFilteredSourcesGroupedByLayerKey(state, layersWithFilter);
    var layerTemplatesByLayerKey = LayerTemplates.getFilteredTemplatesGroupedByLayerKey(state, layersWithFilter);
    var attributeDataSourcesByLayerKey = selectors$2.getFilteredDataSourcesGroupedByLayerKey(state, layersWithFilter, layersState, layersStateAsString);
    var stylesByLayerKey = Styles.getGroupedByLayerKey(state, layersState, layersStateAsString);
    var selections = Selections.getAllAsObjectWithStyles(state);
    var periodsByLayerKey = Periods.getFilteredGroupedByLayerKey(state, layersWithFilter);
    var cacheKey = JSON.stringify(layersWithFilter);
    var cache = getLayersCache.findByKey(cacheKey);

    if (cache && cache.layersWithFilter === layersWithFilter && cache.dataSourcesByLayerKey === dataSourcesByLayerKey && cache.layerTemplatesByLayerKey === layerTemplatesByLayerKey && cache.stylesByLayerKey === stylesByLayerKey && cache.attributeDataSourcesByLayerKey === attributeDataSourcesByLayerKey && cache.selections === selections && cache.periodsByLayerKey === periodsByLayerKey) {
      return cache.mapLayers;
    } else {
      var mapLayers = [];
      layersState.forEach(function (layerState) {
        if (layerState.layerTemplateKey && dataSourcesByLayerKey && !_isEmpty__default['default'](dataSourcesByLayerKey)) {
          var layer = getLayerFromState(state, layerState, dataSourcesByLayerKey, attributeDataSourcesByLayerKey, stylesByLayerKey, selections, layerTemplatesByLayerKey, periodsByLayerKey);

          if (layer) {
            mapLayers.push(layer);
          }
        } else if (layerState.type) {
          var _layerState$options;

          var _layer = (_layerState$options = layerState.options) !== null && _layerState$options !== void 0 && _layerState$options.selected ? _objectSpread2(_objectSpread2({}, layerState), {}, {
            options: _objectSpread2(_objectSpread2({}, layerState.options), {}, {
              selected: mapHelpers.prepareSelection(selections, layerState.options.selected)
            })
          }) : layerState;

          mapLayers.push(_layer);
        }
      });
      getLayersCache.addOrUpdate({
        cacheKey: cacheKey,
        layersWithFilter: layersWithFilter,
        dataSourcesByLayerKey: dataSourcesByLayerKey,
        layerTemplatesByLayerKey: layerTemplatesByLayerKey,
        attributeDataSourcesByLayerKey: attributeDataSourcesByLayerKey,
        mapLayers: mapLayers,
        stylesByLayerKey: stylesByLayerKey,
        selections: selections,
        periodsByLayerKey: periodsByLayerKey
      });
      return mapLayers;
    }
  } else {
    return null;
  }
}; // TODO cache?

/**
 * @param state {Object}
 * @param mapKey {string}
 * @return {Array}
 */


var getMapLayers = function getMapLayers(state, mapKey) {
  var layersState = getLayersStateByMapKey(state, mapKey);
  return getLayers(state, layersState);
};
/* ===============================================
   Deprecated
   =============================================== */


var getMapByMetadata_deprecated = reselect.createSelector([getMaps, function (state, metadata) {
  return metadata;
}], function (maps, metadata) {
  if (maps && metadata) {
    var filtered = _filter__default['default'](maps, function (map) {
      if (map.data && map.data.metadataModifiers) {
        return _isMatch__default['default'](map.data.metadataModifiers, metadata);
      } else {
        return false;
      }
    });

    if (filtered && filtered.length) {
      return filtered[0]; //TODO what if more maps are selected based on filter
    } else {
      return null;
    }
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getNavigator_deprecated = reselect.createSelector([getMapByKey, getMapSetByMapKey], function (map, set) {
  if (map) {
    if (set) {
      var mapNavigator = map.data && map.data.worldWindNavigator;
      var mapSetNavigator = set.data && set.data.worldWindNavigator;

      var navigator = _objectSpread2(_objectSpread2({}, mapSetNavigator), mapNavigator);

      return !_isEmpty__default['default'](navigator) ? navigator : null;
    } else {
      var _navigator = map.data && map.data.worldWindNavigator;

      return _navigator && !_isEmpty__default['default'](_navigator) ? _navigator : null;
    }
  } else {
    return null;
  }
});
var getMapSetNavigatorRange_deprecated = reselect.createSelector([getMapSetByKey], function (set) {
  if (set) {
    return set.data && set.data.worldWindNavigator && set.data.worldWindNavigator.range;
  } else {
    return null;
  }
});
/**
 * Collect and prepare data for map component
 *
 * @param state {Object}
 * @param layers {Array} Collection of layers data. Each object in collection contains filter property (it is used for selecting of relations) and data property (which contains data about layer from map state - e.g. key).
 */

var getLayers_deprecated = reselect.createSelector([SpatialDataSources.getFilteredGroupedByLayerKey, selectors$1.getFilteredGroupedByLayerKey, selectors$3.getCompleteLocalConfiguration, function (state, layers) {
  return layers;
}],
/**
 * @param groupedSources {null | Object} Data sources grouped by layer key
 * @param layers {null | Array}
 * @return {null | Array} Collection of layers data for map component
 */
function (groupedSpatialSources, groupedAttributeSources, localConfig, layers) {
  // FIXME - more complex
  if (groupedSpatialSources && groupedAttributeSources && layers) {
    return layers.map(function (layer) {
      return getLayerConfiguration(localConfig, layer, groupedSpatialSources[layer.data.key], groupedAttributeSources[layer.data.key]);
    });
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getBackgroundLayerStateByMapKey_deprecated = reselect.createSelector([getMapByKey, getMapSetByMapKey, commonSelectors.getAllActiveKeys], function (map, set, activeKeys) {
  var layerTemplate = null;
  var filter = {
    place: null,
    period: null,
    "case": null,
    scenario: null
  };

  if (map && map.data && map.data.backgroundLayer) {
    layerTemplate = map.data.backgroundLayer;
  } else if (set && set.data && set.data.backgroundLayer) {
    layerTemplate = set.data.backgroundLayer;
  }

  if (layerTemplate) {
    return getFiltersForUse_deprecated(_objectSpread2(_objectSpread2({}, filter), {}, {
      layerTemplate: layerTemplate.layerTemplate,
      key: layerTemplate.key
    }), activeKeys);
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getLayersStateByMapKey_deprecated = reselect.createSelector([getMapByKey, getMapSetByMapKey, commonSelectors.getAllActiveKeys, function (state, mapKey, useActiveMetadataKeys) {
  return useActiveMetadataKeys;
}], function (map, mapSet, activeKeys, useActiveMetadataKeys) {
  var setLayers = mapSet && mapSet.data && mapSet.data.layers || null;
  var mapLayers = map && map.data && map.data.layers || null;

  if (map && (mapLayers || setLayers)) {
    var layers = [].concat(_toConsumableArray(setLayers || []), _toConsumableArray(mapLayers || []));
    var modifiers = {};

    if (mapSet) {
      var a = mapSet.data.metadataModifiers;
      modifiers = _objectSpread2(_objectSpread2({}, modifiers), mapSet.data.metadataModifiers);
    }

    modifiers = _objectSpread2(_objectSpread2({}, modifiers), map.data.metadataModifiers);
    layers = layers.map(function (layer) {
      return getFiltersForUse_deprecated(_objectSpread2(_objectSpread2({}, modifiers), layer), activeKeys, useActiveMetadataKeys);
    });
    return layers;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getAllLayersStateByMapKey_deprecated = reselect.createSelector([getLayersStateByMapKey_deprecated, getBackgroundLayerStateByMapKey_deprecated], function (layersState, backgroundLayerState) {
  var backgroundLayerData = backgroundLayerState ? [getLayerState(backgroundLayerState)] : [];
  var layersData = layersState ? layersState.map(getLayerState) : [];
  return _construct(Array, _toConsumableArray(layersData).concat(backgroundLayerData));
});
/**
 * @param state {Object}
 * @param mapSetKey {string}
 * @returns {Array<Map> | null}
 */

var getMapsByMapSetKey_deprecated = reselect.createSelector([getMapsAsObject, getMapSetMapKeys], function (maps, mapSetMapsKeys) {
  if (maps && !_isEmpty__default['default'](maps) && mapSetMapsKeys && !_isEmpty__default['default'](mapSetMapsKeys)) {
    return mapSetMapsKeys.map(function (k) {
      return maps[k];
    });
  } else {
    return null;
  }
});
var getLayersStateByMapSetKey_deprecated = reselect.createSelector([getMapSetByKey, getMapsByMapSetKey_deprecated, commonSelectors.getAllActiveKeys], function (mapSet, maps, activeKeys) {
  var mapsLayersState = {};
  var setLayers = mapSet && mapSet.data && mapSet.data.layers || null;

  if (maps) {
    maps.forEach(function (map) {
      var mapLayers = map && map.data && map.data.layers || null;

      if (map && (mapLayers || setLayers)) {
        var layers = [].concat(_toConsumableArray(setLayers || []), _toConsumableArray(mapLayers || []));
        var modifiers = {};

        if (mapSet) {
          var a = mapSet.data.metadataModifiers;
          modifiers = _objectSpread2(_objectSpread2({}, modifiers), mapSet.data.metadataModifiers);
        }

        modifiers = _objectSpread2(_objectSpread2({}, modifiers), map.data.metadataModifiers); //TODO
        //specific for FUORE

        var useMetadata = {
          scope: true,
          attribute: true,
          period: true
        };
        layers = layers.map(function (layer) {
          return getFiltersForUse_deprecated(_objectSpread2(_objectSpread2({}, modifiers), layer), activeKeys, useMetadata);
        });
        mapsLayersState[map.key] = layers;
      }
    });
  }

  return mapsLayersState;
}); // ----- helpers ------

var getLayerState = function getLayerState(layer) {
  return {
    filter: layer.mergedFilter,
    data: layer.layer
  };
};

var getLayerConfiguration = function getLayerConfiguration(localConfig, layer, spatialSourcesForLayer, attributeSourcesForLayer) {
  // let spatialSourcesForLayer = groupedSpatialSources[layer.data.key];
  var layerConfig = null;

  if (spatialSourcesForLayer) {
    //TODO
    //take only first datasource for now
    // spatialSourcesForLayer.forEach(source => {
    [spatialSourcesForLayer[0]].forEach(function (source) {
      var key = "".concat(layer.data.key);
      var mapServerConfig = {
        wmsMapServerUrl: "".concat(localConfig.apiGeoserverWMSProtocol, "://").concat(localConfig.apiGeoserverWMSHost, "/").concat(localConfig.apiGeoserverWMSPath),
        wfsMapServerUrl: "".concat(localConfig.apiGeoserverWFSProtocol, "://").concat(localConfig.apiGeoserverWFSHost, "/").concat(localConfig.apiGeoserverWFSPath)
      };

      if (source) {
        key += "-".concat(source.key);
        layerConfig = _objectSpread2(_objectSpread2({}, source.data), {}, {
          spatialDataSourceKey: source.key,
          spatialRelationsData: source.spatialRelationData,
          key: key,
          mapServerConfig: mapServerConfig
        });
      } else {
        layerConfig = {
          key: key,
          mapServerConfig: mapServerConfig
        };
      }
    });
  } //add attribute relations data


  if (attributeSourcesForLayer && layerConfig) {
    attributeSourcesForLayer.forEach(function (source) {
      if (source) {
        var attributeLayerTemplateKey = source.attributeRelationData && source.attributeRelationData.layerTemplateKey;

        if (attributeLayerTemplateKey) {
          layerConfig.attributeRelationsData = source.attributeRelationData;
        }
      }
    });
  }

  return layerConfig;
};
/**
 * Prepare filters for use from layers state
 * @param layer {Object} layer state
 * @param activeKeys {Object} Metadata active keys
 * @param useMetadata {Object}
 * @return {{filter, filterByActive, mergedFilter, layer}}
 */


function getFiltersForUse_deprecated(layer, activeKeys, useMetadata) {
  var filter = {};
  var filterByActive = {};
  var mergedFilter = {};

  if (layer && layer.hasOwnProperty('scope')) {
    filter.scopeKey = layer.scope;
  } else if (!useMetadata || useMetadata && useMetadata.scope) {
    filterByActive.scope = true;

    if (activeKeys && activeKeys.activeScopeKey) {
      mergedFilter.scopeKey = activeKeys.activeScopeKey;
    }
  }

  if (layer && layer.hasOwnProperty('place')) {
    filter.placeKey = layer.place;
  } else if (!useMetadata || useMetadata && useMetadata.place) {
    filterByActive.place = true;

    if (activeKeys && activeKeys.activePlaceKey) {
      mergedFilter.placeKey = activeKeys.activePlaceKey;
    }
  }

  if (layer && layer.hasOwnProperty('period')) {
    filter.periodKey = layer.period;
  } else if (!useMetadata || useMetadata && useMetadata.period) {
    filterByActive.period = true;

    if (activeKeys && activeKeys.activePeriodKey) {
      mergedFilter.periodKey = activeKeys.activePeriodKey;
    }
  }

  if (layer && layer.hasOwnProperty('case')) {
    filter.caseKey = layer["case"];
  } else if (!useMetadata || useMetadata && useMetadata["case"]) {
    filterByActive["case"] = true;

    if (activeKeys && activeKeys.activeCaseKey) {
      mergedFilter.caseKey = activeKeys.activeCaseKey;
    }
  }

  if (layer && layer.hasOwnProperty('scenario')) {
    filter.scenarioKey = layer.scenario;
  } else if (!useMetadata || useMetadata && useMetadata.scenario) {
    filterByActive.scenario = true;

    if (activeKeys && activeKeys.activeScenarioKey) {
      mergedFilter.scenarioKey = activeKeys.activeScenarioKey;
    }
  }

  if (layer && layer.hasOwnProperty('layerTemplate')) {
    filter.layerTemplateKey = layer.layerTemplate;
  }

  if (layer && layer.hasOwnProperty('attribute')) {
    filter.attributeKey = layer.attribute;
  } else if (!useMetadata || useMetadata && useMetadata.attribute) {
    filterByActive.attribute = true;

    if (activeKeys && activeKeys.activeAttributeKey) {
      mergedFilter.attributeKey = activeKeys.activeAttributeKey;
    }
  }

  mergedFilter = _objectSpread2(_objectSpread2({}, filter), mergedFilter);
  return {
    layer: layer ? layer : null,
    filter: filter,
    filterByActive: filterByActive,
    mergedFilter: mergedFilter
  };
}

var _deprecatedMaps = {
  getActiveMap: getActiveMap,
  getActiveMapKey: getActiveMapKey,
  getActiveSetKey: getActiveSetKey,
  getAllLayersStateByMapKey: getAllLayersStateByMapKey,
  getBackgroundLayer: getBackgroundLayer,
  getMapBackgroundLayer: getMapBackgroundLayer,
  getBackgroundLayerStateByMapKey: getBackgroundLayerStateByMapKey,
  getFilterByActiveByMapKey: getFilterByActiveByMapKey,
  getLayers: getLayers,
  getMapLayers: getMapLayers,
  getLayersStateByMapKey: getLayersStateByMapKey,
  getMapByKey: getMapByKey,
  getMapLayerByMapKeyAndLayerKey: getMapLayerByMapKeyAndLayerKey,
  getMapLayersByMapKey: getMapLayersByMapKey,
  getMapsAsObject: getMapsAsObject,
  getMapSetActiveMapKey: getMapSetActiveMapKey,
  getMapSetActiveMapView: getMapSetActiveMapView,
  getMapSetByKey: getMapSetByKey,
  getMapSetByMapKey: getMapSetByMapKey,
  getMapSetLayersStateBySetKey: getMapSetLayersStateBySetKey,
  getMapSetMapKeys: getMapSetMapKeys,
  getMapSetView: getMapSetView,
  getMapSetViewLimits: getMapSetViewLimits,
  getMapSets: getMapSets,
  getMapSetsAsObject: getMapSetsAsObject,
  getSubstate: getSubstate$e,
  getView: getView,
  getViewLimits: getViewLimits,
  // Deprecated
  getAllLayersStateByMapKey_deprecated: getAllLayersStateByMapKey_deprecated,
  getBackgroundLayerStateByMapKey_deprecated: getBackgroundLayerStateByMapKey_deprecated,
  getFiltersForUse_deprecated: getFiltersForUse_deprecated,
  getLayers_deprecated: getLayers_deprecated,
  getLayersStateByMapKey_deprecated: getLayersStateByMapKey_deprecated,
  getLayersStateByMapSetKey_deprecated: getLayersStateByMapSetKey_deprecated,
  getMapByMetadata_deprecated: getMapByMetadata_deprecated,
  getMapSetNavigatorRange_deprecated: getMapSetNavigatorRange_deprecated,
  getNavigator_deprecated: getNavigator_deprecated
};

var getSubstate$f = function getSubstate(state) {
  return state.areas.areaTreeLevels;
};

var getAll$9 = commonSelectors.getAll(getSubstate$f);
var getAllAsObject$a = commonSelectors.getAllAsObject(getSubstate$f);
var getAllForActiveScope$2 = commonSelectors.getAllForActiveScope(getSubstate$f);
var getActiveKey$5 = commonSelectors.getActiveKey(getSubstate$f);
var getActive$4 = commonSelectors.getActive(getSubstate$f);
var selectors$4 = {
  getAll: getAll$9,
  getAllAsObject: getAllAsObject$a,
  getAllForActiveScope: getAllForActiveScope$2,
  getActiveKey: getActiveKey$5,
  getActive: getActive$4,
  getSubstate: getSubstate$f
};

var getSubstate$g = function getSubstate(state) {
  return state.areas.areaTrees;
};

var getAll$a = commonSelectors.getAll(getSubstate$g);
var getAllAsObject$b = commonSelectors.getAllAsObject(getSubstate$g);
var getAllForActiveScope$3 = commonSelectors.getAllForActiveScope(getSubstate$g);
var getActiveKey$6 = commonSelectors.getActiveKey(getSubstate$g);
var getActive$5 = commonSelectors.getActive(getSubstate$g);
var selectors$5 = {
  getAll: getAll$a,
  getAllAsObject: getAllAsObject$b,
  getAllForActiveScope: getAllForActiveScope$3,
  getActiveKey: getActiveKey$6,
  getActive: getActive$5,
  getByKeys: commonSelectors.getByKeys(getSubstate$g),
  getByKeysAsObject: commonSelectors.getByKeysAsObject(getSubstate$g),
  getSubstate: getSubstate$g
};

var Areas = {
  areaTreeLevels: selectors$4,
  areaTrees: selectors$5
};

var getSubstate$h = function getSubstate(state) {
  return state.attributes;
};

var getAttributes = commonSelectors.getAll(getSubstate$h);
var getActive$6 = commonSelectors.getActive(getSubstate$h);
var getActiveKey$7 = commonSelectors.getActiveKey(getSubstate$h);
var getAllAsObject$c = commonSelectors.getAllAsObject(getSubstate$h);
var getByKey$a = commonSelectors.getByKey(getSubstate$h);
var getByKeys$5 = commonSelectors.getByKeys(getSubstate$h);
var getDataByKey$4 = commonSelectors.getDataByKey(getSubstate$h);
var getDeletePermissionByKey$3 = commonSelectors.getDeletePermissionByKey(getSubstate$h);
var getEditedDataByKey$3 = commonSelectors.getEditedDataByKey(getSubstate$h);
var getUpdatePermissionByKey$3 = commonSelectors.getUpdatePermissionByKey(getSubstate$h);
var getStateToSave$1 = commonSelectors.getStateToSave(getSubstate$h);
var selectors$6 = {
  getAttributes: getAttributes,
  getActive: getActive$6,
  getActiveKey: getActiveKey$7,
  getAllAsObject: getAllAsObject$c,
  getByKey: getByKey$a,
  getByKeys: getByKeys$5,
  getDataByKey: getDataByKey$4,
  getDeletePermissionByKey: getDeletePermissionByKey$3,
  getEditedDataByKey: getEditedDataByKey$3,
  getUpdatePermissionByKey: getUpdatePermissionByKey$3,
  getStateToSave: getStateToSave$1,
  getSubstate: getSubstate$h
};

var getSubstate$i = function getSubstate(state) {
  return state.attributeSets;
};

var getAll$b = commonSelectors.getAll(getSubstate$i);
var getActiveKeys$2 = commonSelectors.getActiveKeys(getSubstate$i);
var getActive$7 = commonSelectors.getActive(getSubstate$i);
var getStateToSave$2 = commonSelectors.getStateToSave(getSubstate$i);
var getByTopics = reselect.createSelector([getAll$b, function (state, topics) {
  return topics;
}], function (attributeSets, topics) {
  if (attributeSets && topics) {
    if (!_isArray__default['default'](topics)) topics = [topics];

    var filtered = _filter__default['default'](attributeSets, function (attributeSet) {
      return _includes__default['default'](topics, attributeSet.data.topic);
    });

    return filtered.length ? filtered : null;
  } else {
    return null;
  }
});
var getUniqueAttributeKeysForTopics = reselect.createSelector([getByTopics], function (attributeSets) {
  if (attributeSets && attributeSets.length) {
    var allAttributeKeys = attributeSets.map(function (attributeSet) {
      return attributeSet.data.attributes;
    });

    var uniqueAttributeKeys = _compact__default['default'](_uniq__default['default'](_flatten__default['default'](allAttributeKeys)));

    return uniqueAttributeKeys.length ? uniqueAttributeKeys : null;
  } else {
    return null;
  }
});
var selectors$7 = {
  getActive: getActive$7,
  getActiveKeys: getActiveKeys$2,
  getAttributeSets: getAll$b,
  getByTopics: getByTopics,
  getStateToSave: getStateToSave$2,
  getUniqueAttributeKeysForTopics: getUniqueAttributeKeysForTopics
};

var getSubstate$j = function getSubstate(state) {
  return state.attributeStatistics;
};

var getAllAsObject$d = commonSelectors.getAllAsObject(getSubstate$j);
var getByKey$b = commonSelectors.getByKey(getSubstate$j);
var getBatchByFilterOrder$4 = commonSelectors.getBatchByFilterOrder(getSubstate$j);
var selectors$8 = {
  getByKey: getByKey$b,
  getSubstate: getSubstate$j,
  getAllAsObject: getAllAsObject$d,
  getBatchByFilterOrder: getBatchByFilterOrder$4
};

var getSubstate$k = function getSubstate(state) {
  return state.cases;
};

var getAll$c = commonSelectors.getAll(getSubstate$k);
var getAllAsObject$e = commonSelectors.getAllAsObject(getSubstate$k);
var getAllForActiveScope$4 = commonSelectors.getAllForActiveScope(getSubstate$k);
var getActive$8 = commonSelectors.getActive(getSubstate$k);
var getActiveKey$8 = commonSelectors.getActiveKey(getSubstate$k);
var getActiveKeys$3 = commonSelectors.getActiveKeys(getSubstate$k);
var getActiveModels$2 = commonSelectors.getActiveModels(getSubstate$k);
var getByKeys$6 = commonSelectors.getByKeys(getSubstate$k);
var getDataByKey$5 = commonSelectors.getDataByKey(getSubstate$k);
var getDeletePermissionByKey$4 = commonSelectors.getDeletePermissionByKey(getSubstate$k);
var getEditedDataByKey$4 = commonSelectors.getEditedDataByKey(getSubstate$k);
var getIndexed$3 = commonSelectors.getIndexed(getSubstate$k);
var getUpdatePermissionByKey$4 = commonSelectors.getUpdatePermissionByKey(getSubstate$k);
var selectors$9 = {
  getActive: getActive$8,
  getActiveKey: getActiveKey$8,
  getActiveKeys: getActiveKeys$3,
  getActiveModels: getActiveModels$2,
  getAll: getAll$c,
  getAllAsObject: getAllAsObject$e,
  getAllForActiveScope: getAllForActiveScope$4,
  getByKeys: getByKeys$6,
  getDataByKey: getDataByKey$5,
  getDeletePermissionByKey: getDeletePermissionByKey$4,
  getEditedDataByKey: getEditedDataByKey$4,
  getIndexed: getIndexed$3,
  getUpdatePermissionByKey: getUpdatePermissionByKey$4,
  getSubstate: getSubstate$k
};

// TODO test all selectors
var getAllChartsAsObject = function getAllChartsAsObject(state) {
  return state.charts.charts;
};

var getChartByKey = function getChartByKey(state, key) {
  return state.charts.charts[key];
};

var getSetByKey = function getSetByKey(state, key) {
  return state.charts.sets[key];
};

var getChartsBySetKeyAsObject = reselect.createSelector([getSetByKey, getAllChartsAsObject], function (set, charts) {
  if (set && set.charts && set.charts.length) {
    var setCharts = {};

    _each__default['default'](set.charts, function (key) {
      setCharts[key] = charts[key];
    });

    return setCharts;
  } else {
    return null;
  }
}); // TODO other metadata types

var getMetadataActiveKeys = function getMetadataActiveKeys(state) {
  return {
    activeScopeKey: state.scopes.activeKey,
    activePeriodKey: state.periods.activeKey,
    activePeriodKeys: state.periods.activeKeys,
    activeAttributeKey: state.attributes.activeKey
  };
};

var getChartConfiguration = createCachedSelector__default['default']([getChartByKey, getMetadataActiveKeys, function (state, chart, useActiveMetadataKeys) {
  return useActiveMetadataKeys;
}], function (chart, activeKeys, useActiveMetadataKeys) {
  if (chart && activeKeys) {
    var filters = getFiltersForUse(chart.data, activeKeys, useActiveMetadataKeys);
    return _objectSpread2(_objectSpread2({}, chart), filters);
  } else {
    return null;
  }
})(function (state, chart) {
  return "".concat(chart && chart.key);
});
var getDataForChart = createCachedSelector__default['default']([selectors$1.getFilteredGroupedByFid, function (state, filter, chartKey) {
  return chartKey;
}], function (data, chartKey) {
  if (chartKey && data) {
    return data;
  } else {
    return null;
  }
})(function (state, filter, chartKey) {
  return "".concat(JSON.stringify(filter), ":").concat(chartKey);
});
var getNamesForChart = createCachedSelector__default['default']([selectors$1.getNamesByFid, function (state, filter, cacheKey) {
  return cacheKey;
}], function (data, cacheKey) {
  if (cacheKey && data) {
    return data;
  } else {
    return null;
  }
})(function (state, filter, cacheKey) {
  return "".concat(JSON.stringify(filter), ":").concat(cacheKey);
});
/* helpers */

/**
 * Prepare filters for use from layers state
 * @param data {Object} chart data
 * @param activeKeys {Object} Metadata active keys
 * @param useActiveMetadataKeys {Object} Metadata active keys
 * @return {{filter, filterByActive, mergedFilter, data}}
 */
// TODO other metadata types

function getFiltersForUse(data, activeKeys, useActiveMetadataKeys) {
  var filter = {};
  var filterByActive = {};
  var mergedFilter = {};

  if (data && data.hasOwnProperty('scope')) {
    filter.scopeKey = data.scope;
  } else if (useActiveMetadataKeys && useActiveMetadataKeys.scope) {
    filterByActive.scope = true;

    if (activeKeys && activeKeys.activeScopeKey) {
      mergedFilter.scopeKey = activeKeys.activeScopeKey;
    }
  }

  if (data && data.hasOwnProperty('periods')) {
    if (data.periods.length > 1) {
      filter.periodKey = {
        "in": data.periods
      };
    } else {
      filter.periodKey = data.periods[0];
    }
  } else if (useActiveMetadataKeys && useActiveMetadataKeys.period) {
    filterByActive.period = true;

    if (activeKeys && activeKeys.activePeriodKey) {
      mergedFilter.periodKey = activeKeys.activePeriodKey;
    } else if (activeKeys && activeKeys.activePeriodKeys) {
      mergedFilter.periodKey = {
        "in": activeKeys.activePeriodKeys
      };
    }
  }

  if (data && data.hasOwnProperty('attributes')) {
    if (data.attributes.length > 1) {
      filter.attributeKey = {
        "in": data.attributes
      };
    } else {
      filter.attributeKey = data.attributes[0];
    }
  } else if (useActiveMetadataKeys && useActiveMetadataKeys.attribute) {
    filterByActive.attribute = true;

    if (activeKeys && activeKeys.activeAttributeKey) {
      mergedFilter.attributeKey = activeKeys.activeAttributeKey;
    } else if (activeKeys && activeKeys.activeAttributeKeys) {
      mergedFilter.attributeKey = {
        "in": activeKeys.activeAttributeKeys
      };
    }
  }

  if (data && data.hasOwnProperty('layerTemplate')) {
    filter.layerTemplateKey = data.layerTemplate;
  }

  mergedFilter = _objectSpread2(_objectSpread2({}, filter), mergedFilter);
  return {
    filter: filter,
    filterByActive: filterByActive,
    mergedFilter: mergedFilter
  };
}

var selectors$a = {
  getChartConfiguration: getChartConfiguration,
  getChartsBySetKeyAsObject: getChartsBySetKeyAsObject,
  getDataForChart: getDataForChart,
  getNamesForChart: getNamesForChart,
  getSetByKey: getSetByKey
};

var getAllByKey$1 = function getAllByKey(state) {
  return state.components;
};

var getDataByComponentKey = reselect.createSelector([getAllByKey$1, function (state, key) {
  return key;
}], function (components, key) {
  if (components && key && components[key]) {
    return components[key];
  } else {
    return null;
  }
});
var get = reselect.createSelector([getDataByComponentKey, function (state, key, path) {
  return path;
}], function (componentState, path) {
  return _get__default['default'](componentState, path, null);
});
var selectors$b = {
  get: get,
  getDataByComponentKey: getDataByComponentKey,
  getStateToSave: getAllByKey$1
};

var getSubstate$l = function getSubstate(state) {
  return state.data.attributeRelations;
};

var getIndex$2 = commonSelectors.getIndex(getSubstate$l);
var getIndex_recompute$1 = commonSelectors.getIndex_recompute(getSubstate$l);
/**
 * It returns relation model for given key, if exists
 * @param key {string} relation key
 * @return {Object} attribute relation
 */

var getByKeyObserver$2 = recompute.createObserver(function (state, key) {
  var _getSubstate, _getSubstate$byKey;

  return ((_getSubstate = getSubstate$l(state)) === null || _getSubstate === void 0 ? void 0 : (_getSubstate$byKey = _getSubstate.byKey) === null || _getSubstate$byKey === void 0 ? void 0 : _getSubstate$byKey[key]) || null;
});
/**
 * It returns relation models for given keys
 * @param keys {Array} relation keys
 * @return {Array} A collection of relations
 */

var getByKeys$7 = recompute.createSelector(function (keys) {
  return keys.map(function (key) {
    return getByKeyObserver$2(key);
  });
});
/**
 * It returns a collection of indexed relations for given filter
 * @param filter {Object}
 * @return {Array}
 */

var getIndexed$4 = recompute.createSelector(function (filter) {
  var index = getIndex_recompute$1(filter, null);

  if (index !== null && index !== void 0 && index.index) {
    // filter only uuids (not true or false values of index)
    var keys = _filter__default['default'](Object.values(index.index), function (key) {
      return typeof key === "string";
    });

    if (keys !== null && keys !== void 0 && keys.length) {
      return getByKeys$7(keys);
    } else {
      return null;
    }
  } else {
    return null;
  }
});
/**
 * It returns key-value pairs, where the key is attribute data source key and the value is attribute key
 * @param filter {Object} attribute relation filter
 * @return {Object}
 */

var getFilteredAttributeDataSourceKeyAttributeKeyPairs = recompute.createSelector(function (filter) {
  var relations = getIndexed$4(filter);

  if (relations) {
    var pairs = {};

    _forEach__default['default'](relations, function (relation) {
      pairs[relation.data.attributeDataSourceKey] = relation.data.attributeKey;
    });

    return pairs;
  } else {
    return null;
  }
});
var attributeRelations = {
  getFilteredAttributeDataSourceKeyAttributeKeyPairs: getFilteredAttributeDataSourceKeyAttributeKeyPairs,
  getIndex: getIndex$2
};

var getSubstate$m = function getSubstate(state) {
  return state.data.attributeDataSources;
};

var getIndex$3 = commonSelectors.getIndex(getSubstate$m);
var getIndex_recompute$2 = commonSelectors.getIndex_recompute(getSubstate$m);
/**
 * It returns data source model for given key, if exists
 * @param key {string} data source key
 * @return {Object} attribute data source
 */

var getByKeyObserver$3 = recompute.createObserver(function (state, key) {
  var _getSubstate, _getSubstate$byKey;

  return ((_getSubstate = getSubstate$m(state)) === null || _getSubstate === void 0 ? void 0 : (_getSubstate$byKey = _getSubstate.byKey) === null || _getSubstate$byKey === void 0 ? void 0 : _getSubstate$byKey[key]) || null;
});
/**
 * It returns data source models for given keys
 * @param keys {Array} data source keys
 * @return {Array} A collection of data sources
 */

var getByKeys$8 = recompute.createSelector(function (keys) {
  return keys.map(function (key) {
    return getByKeyObserver$3(key);
  });
});
/**
 * It returns a collection of indexed data sources for given filter
 * @param filter {Object}
 * @return {Array}
 */

var getIndexed$5 = recompute.createSelector(function (filter) {
  var index = getIndex_recompute$2(filter, null);

  if (index !== null && index !== void 0 && index.index) {
    var keys = Object.values(index.index);

    if (keys) {
      return getByKeys$8(keys);
    } else {
      return null;
    }
  } else {
    return null;
  }
});
var attributeDataSources = {
  getIndexed: getIndexed$5,
  getIndex: getIndex$3
};

var getSubstate$n = function getSubstate(state) {
  return state.data.attributeData;
};

var getIndex$4 = commonSelectors.getIndexByPath(getSubstate$n);
var getSpatialIndexesObserver = recompute.createObserver(function (state, getSubstate) {
  return getSubstate(state).spatialIndexes;
});
/**
 * It returns all data for given datasource key
 * @param key {string} data source key
 * @returns {Object} Features as object (by feature key)
 */

var getByDataSourceKeyObserver = recompute.createObserver(function (state, key) {
  var _getSubstate, _getSubstate$byDataSo;

  return ((_getSubstate = getSubstate$n(state)) === null || _getSubstate === void 0 ? void 0 : (_getSubstate$byDataSo = _getSubstate.byDataSourceKey) === null || _getSubstate$byDataSo === void 0 ? void 0 : _getSubstate$byDataSo[key]) || null;
});
/**
 * It returns whole index for given filter & order
 * @param {Object} filter
 * @param {Array} order
 * @return {Object} index
 */

var getIndex_recompute$3 = recompute.createSelector(function (filter, order) {
  var indexes = getSpatialIndexesObserver(getSubstate$n);

  if (indexes) {
    return commonHelpers.getIndex(indexes, filter, order);
  } else {
    return null;
  }
});
/**
 * It returns attributes data (an object containing featureKey-attributeValue pairs) grouped by data source key
 * @param dataSourceKeys {Array}
 * @return {Object}
 */

var getDataByDataSourceKeys = recompute.createSelector(function (dataSourceKeys) {
  if (dataSourceKeys) {
    var data = {};

    _.forEach(dataSourceKeys, function (key) {
      var attributes = getByDataSourceKeyObserver(key);

      if (attributes && !_.isEmpty(attributes)) {
        data[key] = attributes;
      }
    });

    return !_.isEmpty(data) ? data : null;
  } else {
    return null;
  }
});
/**
 * It returns attribute values for given feature key grouped by data source key
 * @param attributeDataSourceKeyAttributeKeyPairs {Object} key-value pairs, where the key is attribute data source key and the value is matching attribute key
 * @param featureKey {string | number}
 * @return {Object} attributeDataSource key - attribute value pairs
 */

var getAttributesByDataSourceKeysForFeatureKey = recompute.createSelector(function (attributeDataSourceKeyAttributeKeyPairs, featureKey) {
  if (attributeDataSourceKeyAttributeKeyPairs && featureKey) {
    var dataSourceKeys = Object.keys(attributeDataSourceKeyAttributeKeyPairs);
    var dataByDataSourceKey = getDataByDataSourceKeys(dataSourceKeys);

    if (dataByDataSourceKey) {
      var attributes = {};

      _.forIn(dataByDataSourceKey, function (dataSourceData, dataSourceKey) {
        var value = dataSourceData[featureKey];
        var attributeKey = attributeDataSourceKeyAttributeKeyPairs[dataSourceKey];
        attributes[attributeKey] = value;
      });

      return !_.isEmpty(attributes) ? attributes : null;
    } else {
      return null;
    }
  } else {
    return null;
  }
});
/**
 * It returns indexed feature keys grouped by attribute data source keys
 * @param {Object} filter
 * @param {number} level
 * @param {string} tile
 * @return {Object}
 */

var getIndexedFeatureKeysByDataSourceKeys = recompute.createSelector(function (filter, level, tile) {
  var index = getIndex_recompute$3(filter, null);

  if (index !== null && index !== void 0 && index.index) {
    var _index$index$level;

    var featureKeysByDataSourceKeys = (_index$index$level = index.index[level]) === null || _index$index$level === void 0 ? void 0 : _index$index$level[tile];
    return featureKeysByDataSourceKeys || null;
  } else {
    return null;
  }
});
var attributeData = {
  getIndex: getIndex$4,
  getDataByDataSourceKeys: getDataByDataSourceKeys,
  getAttributesByDataSourceKeysForFeatureKey: getAttributesByDataSourceKeysForFeatureKey,
  getIndexedFeatureKeysByDataSourceKeys: getIndexedFeatureKeysByDataSourceKeys
};

var getSubstate$o = function getSubstate(state) {
  return state.data.spatialRelations;
};

var getIndex$5 = commonSelectors.getIndex(getSubstate$o);
var selectors$c = {
  getIndex: getIndex$5
};

var getSubstate$p = function getSubstate(state) {
  return state.data.spatialDataSources;
};

var getIndex$6 = commonSelectors.getIndex(getSubstate$p);
var getAllAsObject$f = commonSelectors.getAllAsObject(getSubstate$p);
var getIndexesObserver$1 = recompute.createObserver(function (state, getSubstate) {
  return commonSelectors.getIndexes(getSubstate)(state);
});
/**
 * It returns data source model for given key, if exists
 * @param key {string} data source key
 * @return {Object} Data source
 */

var getByKeyObserver$4 = recompute.createObserver(function (state, key) {
  var _getSubstate, _getSubstate$byKey;

  return ((_getSubstate = getSubstate$p(state)) === null || _getSubstate === void 0 ? void 0 : (_getSubstate$byKey = _getSubstate.byKey) === null || _getSubstate$byKey === void 0 ? void 0 : _getSubstate$byKey[key]) || null;
});
/**
 * It returns data source models for given keys, if exist
 * @param keys {Array} data source keys
 * @return {Array} A collection of data sources
 */

var getByKeys$9 = recompute.createSelector(function (keys) {
  return keys.map(function (key) {
    return getByKeyObserver$4(key);
  });
});
/**
 * It returns whole index for given filter and order
 * @param {Object} filter Filler object contains modifiers and layerTemplateKey or areaTreeLevelKey.
 * @param order {Array}
 * @return {Object} index
 */

var getIndex_recompute$4 = recompute.createSelector(function (filter, order) {
  var indexes = getIndexesObserver$1(getSubstate$p);

  if (indexes) {
    return commonHelpers.getIndex(indexes, filter, order);
  } else {
    return null;
  }
});
/**
 * It returns a collection of indexed data sources for given filter
 * @param {Object} filter Filler object contains modifiers and layerTemplateKey or areaTreeLevelKey.
 * @return {Array}
 */

var getIndexed$6 = recompute.createSelector(function (filter) {
  var index = getIndex_recompute$4(filter, null);

  if (index !== null && index !== void 0 && index.index) {
    var keys = Object.values(index.index);

    if (keys) {
      return getByKeys$9(keys);
    } else {
      return null;
    }
  } else {
    return null;
  }
});
/**
 * Select array of SpatialDataSources based on given filter.
 * @param {Object} state 
 * @param {Object} filter Filler object contains modifiers and layerTemplateKey or areaTreeLevelKey.
 * @return {Array?}
 */

var getByFilteredIndex = createCachedSelector__default['default']([getIndex$6, getAllAsObject$f], function (index, dataSources) {
  if (!_isEmpty__default['default'](index)) {
    var dataSourceKeys = index.index;

    if (!_isEmpty__default['default'](dataSourceKeys)) {
      var filteredDataSources = [];

      for (var _i = 0, _Object$values = Object.values(dataSourceKeys); _i < _Object$values.length; _i++) {
        var dataSourceKey = _Object$values[_i];
        filteredDataSources.push(dataSources[dataSourceKey]);
      }

      if (filteredDataSources.length > 0) {
        return filteredDataSources;
      } else {
        return null;
      }
    } else {
      return null;
    }
  } else {
    return null;
  }
})(function (state, filter) {
  return "".concat(JSON.stringify(filter));
});
var spatialDataSources = {
  getIndexed: getIndexed$6,
  getIndex: getIndex$6,
  getByFilteredIndex: getByFilteredIndex
};

var getSubstate$q = function getSubstate(state) {
  return state.data.spatialData;
};

var getIndex$7 = commonSelectors.getIndex(getSubstate$q);
var getIndexesObserver$2 = recompute.createObserver(function (state, getSubstate) {
  return commonSelectors.getIndexes(getSubstate)(state);
});
/**
 * It returns all data for given datasource key
 * @param key {string} data source key
 * @returns {Object} Features as object (by feature key)
 */

var getByDataSourceKeyObserver$1 = recompute.createObserver(function (state, key) {
  var _getSubstate, _getSubstate$byDataSo;

  return ((_getSubstate = getSubstate$q(state)) === null || _getSubstate === void 0 ? void 0 : (_getSubstate$byDataSo = _getSubstate.byDataSourceKey) === null || _getSubstate$byDataSo === void 0 ? void 0 : _getSubstate$byDataSo[key]) || null;
});
/**
 * It returns whole index for given filter & order
 * @param {Object} filter
 * @param {Array} order
 * @return {Object} index
 */

var getIndex_recompute$5 = recompute.createSelector(function (filter, order) {
  var indexes = getIndexesObserver$2(getSubstate$q);

  if (indexes) {
    return commonHelpers.getIndex(indexes, filter, order);
  } else {
    return null;
  }
});
/**
 * @param {Object} filter
 * @param {number} level
 * @param {string} tile
 * @param {string} dataSourceKey
 * @return {Array} indexed feature keys
 */

var getIndexedFeatureKeys = recompute.createSelector(function (filter, level, tile, dataSourceKey) {
  var index = getIndex_recompute$5(filter, null);

  if (index !== null && index !== void 0 && index.index) {
    var _index$index$level, _index$index$level$ti;

    var featureKeys = (_index$index$level = index.index[level]) === null || _index$index$level === void 0 ? void 0 : (_index$index$level$ti = _index$index$level[tile]) === null || _index$index$level$ti === void 0 ? void 0 : _index$index$level$ti[dataSourceKey];
    return featureKeys !== null && featureKeys !== void 0 && featureKeys.length ? featureKeys : null;
  } else {
    return null;
  }
});
var spatialData = {
  getByDataSourceKeyObserver: getByDataSourceKeyObserver$1,
  getIndex: getIndex$7,
  getIndexedFeatureKeys: getIndexedFeatureKeys
};

/**
 * Returns string representing given tile
 * @param {Array|string} tile 
 * @returns {string}
 */
var tileAsString = function tileAsString(tile) {
  if (typeof tile === 'string') {
    return tile;
  } else {
    return "".concat(tile[0], ",").concat(tile[1]);
  }
};
/**
 * Converts tile as a string to array
 * @param {Array|string} tile
 * @returns {string}
 */

var tileAsArray = function tileAsArray(tile) {
  if (typeof tile === 'string') {
    return tile.split(',').map(parseFloat);
  } else if (_isArray__default['default'](tile)) {
    return tile.map(parseFloat);
  } else {
    return null;
  }
};
/**
 * Compare wanted tiles from filter with already loaded or loading tiles and give array of missing tiles
 * @param {Object} index Already loaded index
 * @param {Object} filter Required filter
 * @param {Array.<string|Array.<number>>} filter.tiles
 * @param {number} filter.level
 */

var getMissingTiles = function getMissingTiles(index, filter) {
  if (index && index.index && filter) {
    var _index$index;

    if ((_index$index = index.index) !== null && _index$index !== void 0 && _index$index[filter.level] && filter && filter.tiles) {
      var loadedTilesInIndex = _reduce__default['default'](index.index[filter.level], function (acc, tileData, tileKey) {
        //tileData === true means it is loading, so we mark them as not missing
        if (tileData) {
          return [].concat(_toConsumableArray(acc), [tileKey]);
        } else {
          return acc;
        }
      }, []);

      var missingTiles = filter.tiles.filter(function (tile) {
        return !loadedTilesInIndex.includes(tileAsString(tile));
      });
      return missingTiles;
    } else {
      // no data for requested level
      // all tiles are missing 
      return filter.tiles.map(function (tile) {
        return tileAsString(tile);
      });
    }
  } else {
    if (filter !== null && filter !== void 0 && filter.tiles) {
      // all tiles are missing 
      return filter.tiles.map(function (tile) {
        return tileAsString(tile);
      });
    } else {
      //filter is not defined
      return null;
    }
  }
};

var tilesCache = new ptrUtils.CacheFifo(1000);
/**
 * @param dataSourceKey {string} uuid
 * @param fidColumnName {string} name of property used as feature identifier
 * @param attributeDataSourceKeyAttributeKeyPairs {Object} key-value pairs, where key is attribute data source key and value is matching attribute key
 */

var getFeatures = recompute.createSelector(function (dataSourceKey, fidColumnName, attributeDataSourceKeyAttributeKeyPairs) {
  var data = spatialData.getByDataSourceKeyObserver(dataSourceKey);
  var attributesByDataSourceKey = null;

  if (attributeDataSourceKeyAttributeKeyPairs) {
    attributesByDataSourceKey = attributeData.getDataByDataSourceKeys(Object.keys(attributeDataSourceKeyAttributeKeyPairs));
  }

  if (data) {
    return _map__default['default'](data, function (feature, key) {
      var properties = _defineProperty({}, fidColumnName, key);

      if (attributesByDataSourceKey) {
        _forIn__default['default'](attributesByDataSourceKey, function (features, attributeDataSourceKey) {
          var attributeValue = features[key];

          if (attributeValue) {
            properties[attributeDataSourceKeyAttributeKeyPairs[attributeDataSourceKey]] = attributeValue;
          }
        });
      }

      return {
        type: "Feature",
        key: key,
        geometry: feature.geometry,
        properties: properties
      };
    });
  } else {
    return null;
  }
});
/**
 * Assemble vector data for single tile
 * @param dataSourceKey {string} uuid
 * @param fidColumnName {string} name of property used as feature identifier
 * @param level {number}
 * @param tile {Array} tile definition point
 * @param spatialRelationsFilter {Object} getSpatialRelationsFilterFromLayerState
 * @param attributeRelationsFilter {Object} getAttributeRelationsFilterFromLayerState
 * @param attributeDataSourceKeyAttributeKeyPairs {Object} key-value pairs, where key is attribute data source key and value is matching attribute key
 * @param styleKey {string} uuid
 * @return {Object} populated tile (with feature's geometries and attributes)
 */

var getTile = recompute.createSelector(function (spatialDataSourceKey, fidColumnName, level, tile, spatialRelationsFilter, attributeRelationsFilter, attributeDataSourceKeyAttributeKeyPairs, styleKey) {
  // Get all data for given key. It caused performance issues when the data was passed as a parameter
  var spatialDataForDataSource = spatialData.getByDataSourceKeyObserver(spatialDataSourceKey);

  if (spatialDataForDataSource) {
    var tileString = tileAsString(tile);
    var cacheParams = {
      attributeRelationsFilter: attributeRelationsFilter,
      spatialRelationsFilter: spatialRelationsFilter,
      level: level,
      tileAsString: tileString,
      spatialDataSourceKey: spatialDataSourceKey,
      styleKey: styleKey
    };
    var indexedFeatureKeys = spatialData.getIndexedFeatureKeys(spatialRelationsFilter, level, tileString, spatialDataSourceKey);
    var indexedFeatureKeysByAttributeDataSourceKeys = attributeData.getIndexedFeatureKeysByDataSourceKeys(attributeRelationsFilter, level, tileString);
    var cacheKey = stringify__default['default']({
      cacheParams: cacheParams,
      indexedFeatureKeys: indexedFeatureKeys,
      indexedFeatureKeysByAttributeDataSourceKeys: indexedFeatureKeysByAttributeDataSourceKeys
    }); // TODO is index enough as cache key?

    var cache = tilesCache.findByKey(cacheKey);

    if (cache) {
      return cache.data;
    } else {
      if (indexedFeatureKeys !== null && indexedFeatureKeys !== void 0 && indexedFeatureKeys.length) {
        var features = [];
        indexedFeatureKeys.forEach(function (key) {
          var _spatialDataForDataSo, _spatialDataForDataSo2;

          var properties = _defineProperty({}, fidColumnName, key); // TODO what if some geometries is missing


          var geometry = ((_spatialDataForDataSo = spatialDataForDataSource[key]) === null || _spatialDataForDataSo === void 0 ? void 0 : _spatialDataForDataSo.geometry) || ((_spatialDataForDataSo2 = spatialDataForDataSource[key]) === null || _spatialDataForDataSo2 === void 0 ? void 0 : _spatialDataForDataSo2.geometries[level]);

          if (attributeDataSourceKeyAttributeKeyPairs) {
            var attributes = attributeData.getAttributesByDataSourceKeysForFeatureKey(attributeDataSourceKeyAttributeKeyPairs, key);

            if (attributes) {
              properties = _objectSpread2(_objectSpread2({}, properties), attributes);
            }
          }

          if (geometry) {
            features.push({
              type: "Feature",
              key: key,
              geometry: geometry,
              properties: properties
            });
          }
        });
        var data = {
          features: features.length ? features : null,
          tile: tileString,
          level: level
        };
        tilesCache.addOrUpdate({
          cacheKey: cacheKey,
          data: data
        });
        return data;
      } else {
        return null;
      }
    }
  } else {
    return null;
  }
});
/**
 * Assemble vector data for all tiles
 * @param dataSourceKey {string} uuid
 * @param fidColumnName {string} name of property used as feature identifier
 * @param level {number}
 * @param tiles {Array} list of tiles definition points
 * @param spatialRelationsFilter {Object} getSpatialRelationsFilterFromLayerState
 * @param attributeRelationsFilter {Object} getAttributeRelationsFilterFromLayerState
 * @param attributeDataSourceKeyAttributeKeyPairs {Object} key-value pairs, where key is attribute data source key and value is matching attribute key
 * @param styleKey {string} uuid
 * @return {Array} a collection of populated tiles (with feature's geometries and attributes)
 */

var getTiles = recompute.createSelector(function (dataSourceKey, fidColumnName, level, tiles, spatialRelationsFilter, attributeRelationsFilter, attributeDataSourceKeyAttributeKeyPairs, styleKey) {
  if (tiles !== null && tiles !== void 0 && tiles.length) {
    var populatedTiles = [];

    _forEach__default['default'](tiles, function (tile) {
      var populatedTile = getTile(dataSourceKey, fidColumnName, level, tile, spatialRelationsFilter, attributeRelationsFilter, attributeDataSourceKeyAttributeKeyPairs, styleKey);

      if (populatedTile) {
        populatedTiles.push(populatedTile);
      }
    });

    return populatedTiles.length ? populatedTiles : null;
  } else {
    return null;
  }
});
var Data = {
  getFeatures: getFeatures,
  getTiles: getTiles,
  attributeData: attributeData,
  attributeDataSources: attributeDataSources,
  attributeRelations: attributeRelations,
  spatialData: spatialData,
  spatialDataSources: spatialDataSources,
  spatialRelations: selectors$c
};

var getByAoiKey = function getByAoiKey(state) {
  return state.layerPeriods.byAoiKey;
};

var getByPlaceKey = function getByPlaceKey(state) {
  return state.layerPeriods.byPlaceKey;
};

var getByKey$c = function getByKey(state) {
  return state.layerPeriods.byKey;
};

var getActiveAoiKey = function getActiveAoiKey(state) {
  return state.aoi.activeKey;
};

var getActivePlaceKey = function getActivePlaceKey(state) {
  return state.places.activeKey;
};

var getActiveLpisCaseKey = function getActiveLpisCaseKey(state) {
  return state.specific.lpisChangeReviewCases.activeCaseKey;
};

var getActiveAoiData = reselect.createSelector([getByAoiKey, getActiveAoiKey], function (byAoiKey, activeAoiKey) {
  return byAoiKey[activeAoiKey];
});
var getActivePlaceData = reselect.createSelector([getByPlaceKey, getActivePlaceKey], function (byPlaceKey, activePlaceKey) {
  return byPlaceKey[activePlaceKey];
});
var getForActiveLpisCase = reselect.createSelector([getByKey$c, getActiveLpisCaseKey], function (byKey, activeLpisCaseKey) {
  return byKey['lpisCase' + activeLpisCaseKey];
});
var selectors$d = {
  getActiveAoiData: getActiveAoiData,
  getActivePlaceData: getActivePlaceData,
  getForActiveLpisCase: getForActiveLpisCase
};

var getSubstate$r = function getSubstate(state) {
  return state.layerTrees;
};

var getAll$d = commonSelectors.getAll(getSubstate$r);
var getAllAsObject$g = commonSelectors.getAllAsObject(getSubstate$r);
var getAllForActiveScope$5 = commonSelectors.getAllForActiveScope(getSubstate$r);
var getByFilterOrder$1 = commonSelectors.getByFilterOrder(getSubstate$r);
var getDataByKey$6 = commonSelectors.getDataByKey(getSubstate$r);
var getDeletePermissionByKey$5 = commonSelectors.getDeletePermissionByKey(getSubstate$r);
var getEditedDataByKey$5 = commonSelectors.getEditedDataByKey(getSubstate$r);
var getUpdatePermissionByKey$5 = commonSelectors.getUpdatePermissionByKey(getSubstate$r);
var LayerTrees = {
  getAll: getAll$d,
  getAllAsObject: getAllAsObject$g,
  getAllForActiveScope: getAllForActiveScope$5,
  getByFilterOrder: getByFilterOrder$1,
  getDataByKey: getDataByKey$6,
  getDeletePermissionByKey: getDeletePermissionByKey$5,
  getEditedDataByKey: getEditedDataByKey$5,
  getUpdatePermissionByKey: getUpdatePermissionByKey$5,
  getSubstate: getSubstate$r
};

/* === HELPERS ======================================================================= */

/**
 * Get background layer in 'layer' format
 */

var getBackgroundLayerAsLayer = createCachedSelector__default['default']([function (backgroundLayer) {
  return backgroundLayer;
}], function (backgroundLayer) {
  if (backgroundLayer) {
    return _objectSpread2(_objectSpread2({}, backgroundLayer), {}, {
      key: 'pantherBackgroundLayer'
    });
  } else {
    return null;
  }
})(function (backgroundLayer) {
  return JSON.stringify(backgroundLayer);
});
/**
 * Merge background layer definition with layers to one collection
 */

var mergeBackgroundLayerWithLayers = createCachedSelector__default['default']([function (backgroundLayer) {
  return getBackgroundLayerAsLayer(backgroundLayer);
}, function (backgroundLayer, layers) {
  return layers;
}], function (backgroundLayer, layers) {
  var _finalLayers;

  var finalLayers = [];

  if (layers) {
    finalLayers = layers || [];
  }

  if (backgroundLayer) {
    finalLayers = [backgroundLayer].concat(_toConsumableArray(finalLayers));
  }

  return (_finalLayers = finalLayers) !== null && _finalLayers !== void 0 && _finalLayers.length ? finalLayers : null;
})(function (backgroundLayer, layers) {
  return "".concat(JSON.stringify(backgroundLayer), "_").concat(JSON.stringify(layers));
});
/**
 * Merge given modifiers with layer's modifiers & given filterByActive with layer's filter by active and add it to the layer state
 *
 * @param layers {Object} layers state
 * @param metadataModifiers {Object} modifiers like scopeKey, placeKey
 * @param filterByActive {{scope: bool, place: bool, period: bool,  scenario: bool, case: bool}}
 * @return {Object} Final layer state definition
 */

var mergeModifiersAndFilterByActiveToLayerStructure = function mergeModifiersAndFilterByActiveToLayerStructure(layers, metadataModifiers, filterByActive) {
  return layers.map(function (layer) {
    var layerMetadataModifiers = layer.metadataModifiers && metadataModifiers ? _objectSpread2(_objectSpread2({}, metadataModifiers), layer.metadataModifiers) : metadataModifiers || layer.metadataModifiers || null;
    var layerFilterByActive = layer.filterByActive && filterByActive ? _objectSpread2(_objectSpread2({}, filterByActive), layer.filterByActive) : filterByActive || layer.filterByActive || null;
    return _objectSpread2(_objectSpread2({}, layer), {}, {
      metadataModifiers: layerMetadataModifiers,
      filterByActive: layerFilterByActive
    });
  });
};
/**
 * It returns merged view from map and associated map set based on synced params
 * @param map {Object}
 * @param set {Object}
 * @return {Object|unknown} final map view
 */


var getView$1 = function getView(map, set) {
  if (map) {
    if (set) {
      var _map$data, _set$data;

      var mapView = (_map$data = map.data) === null || _map$data === void 0 ? void 0 : _map$data.view; // omit synced view params from map

      if (set.sync && !_isEmpty__default['default'](set.sync)) {
        mapView = _omitBy__default['default'](mapView, function (viewValue, viewKey) {
          return set.sync[viewKey];
        });
      }

      var mapSetView = (_set$data = set.data) === null || _set$data === void 0 ? void 0 : _set$data.view;
      var view = ptrUtils.map.view.mergeViews(ptrCore.mapConstants.defaultMapView, mapSetView, mapView);
      return !_isEmpty__default['default'](view) ? view : null;
    } else {
      var _map$data2;

      var _view = (_map$data2 = map.data) === null || _map$data2 === void 0 ? void 0 : _map$data2.view;

      return ptrUtils.map.view.mergeViews(ptrCore.mapConstants.defaultMapView, _view);
    }
  } else {
    return null;
  }
};
/**
 * Get zoom level of current view represented by mapWidth, mapHeight and boxRange.
 */


var getZoomLevel = createCachedSelector__default['default']([function (mapWidth) {
  return mapWidth;
}, function (mapWidth, mapHeight) {
  return mapHeight;
}, function (mapWidth, mapHeight, boxRange) {
  return boxRange;
}], function (mapWidth, mapHeight, boxRange) {
  var viewportRange = ptrUtils.map.view.getMapViewportRange(mapWidth, mapHeight);
  var levelBoxRange = ptrUtils.map.view.getNearestZoomLevelBoxRange(mapWidth, mapHeight, boxRange);
  return ptrTileGrid.grid.getLevelByViewport(levelBoxRange, viewportRange);
})(function (mapWidth, mapHeight, boxRange) {
  return "".concat(mapWidth).concat(mapHeight).concat(boxRange);
});
/**
 * Get tiles intersected by map extent.
 * Map extent is represented by mapWidth, mapHeight, center and boxRange.
 */

var getTiles$1 = createCachedSelector__default['default']([function (mapWidth) {
  return mapWidth;
}, function (mapWidth, mapHeight) {
  return mapHeight;
}, function (mapWidth, mapHeight, center) {
  return center;
}, function (mapWidth, mapHeight, center, boxRange) {
  return boxRange;
}], function (mapWidth, mapHeight, center, boxRange) {
  var levelBoxRange = ptrUtils.map.view.getNearestZoomLevelBoxRange(mapWidth, mapHeight, boxRange);
  var lonLat = [center.lon, center.lat];
  var tileGrid = ptrTileGrid.grid.getTileGrid(mapWidth, mapHeight, levelBoxRange, lonLat, true);
  return tileGrid.flat(1);
})(function (mapWidth, mapHeight, center, boxRange) {
  return "".concat(mapWidth).concat(mapHeight).concat(center.lon).concat(center.lat).concat(boxRange);
});
var selectorHelpers = {
  getBackgroundLayerAsLayer: getBackgroundLayerAsLayer,
  getTiles: getTiles$1,
  getView: getView$1,
  getZoomLevel: getZoomLevel,
  mergeBackgroundLayerWithLayers: mergeBackgroundLayerWithLayers,
  mergeModifiersAndFilterByActiveToLayerStructure: mergeModifiersAndFilterByActiveToLayerStructure
};

var getActiveMapKey$1 = function getActiveMapKey(state) {
  return state.maps.activeMapKey;
};

var getMapsAsObject$1 = function getMapsAsObject(state) {
  return state.maps.maps;
};

var getMapSetsAsObject$1 = function getMapSetsAsObject(state) {
  return state.maps.sets;
};
/**
 * @param state {Object}
 * @param mapKey {string}
 */


var getMapByKey$1 = reselect.createSelector([getMapsAsObject$1, function (state, key) {
  return key;
}], function (maps, key) {
  return (maps === null || maps === void 0 ? void 0 : maps[key]) || null;
});
/**
 * @param state {Object}
 */

var getMapSets$1 = reselect.createSelector([getMapSetsAsObject$1], function (sets) {
  if (sets && !_isEmpty__default['default'](sets)) {
    return Object.values(sets);
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param setKey {string}
 */

var getMapSetByKey$1 = reselect.createSelector([getMapSetsAsObject$1, function (state, key) {
  return key;
}], function (sets, key) {
  return (sets === null || sets === void 0 ? void 0 : sets[key]) || null;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapSetByMapKey$1 = reselect.createSelector([getMapSets$1, function (state, mapKey) {
  return mapKey;
}], function (sets, mapKey) {
  if (sets && !_isEmpty__default['default'](sets) && mapKey) {
    return _find__default['default'](sets, function (set) {
      return set.maps && _includes__default['default'](set.maps, mapKey);
    }) || null;
  } else {
    return null;
  }
});
/**
 * Get active map key for set. Either local, or global.
 *
 * @param state {Object}
 * @param setKey {string}
 */

var getMapSetActiveMapKey$1 = reselect.createSelector([getActiveMapKey$1, getMapSetByKey$1], function (mapKey, set) {
  if (set) {
    var mapKeyInSet = _includes__default['default'](set.maps, mapKey);

    return set.activeMapKey || mapKeyInSet && mapKey || null;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param setKey {string}
 */

var getMapSetActiveMapView$1 = createCachedSelector__default['default']([getMapSetActiveMapKey$1, getMapSetByKey$1, getMapsAsObject$1], function (mapKey, set, maps) {
  var map = maps === null || maps === void 0 ? void 0 : maps[mapKey];

  if (map) {
    return selectorHelpers.getView(map, set);
  } else {
    return null;
  }
})(function (state, setKey) {
  return setKey;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getViewByMapKey = createCachedSelector__default['default']([getMapByKey$1, getMapSetByMapKey$1], selectorHelpers.getView)(function (state, mapKey) {
  return mapKey;
});
var getViewByMapKeyObserver = recompute.createObserver(getViewByMapKey);
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getViewportByMapKey = createCachedSelector__default['default']([getMapByKey$1], function (map) {
  var _map$data;

  return (map === null || map === void 0 ? void 0 : (_map$data = map.data) === null || _map$data === void 0 ? void 0 : _map$data.viewport) || null;
})(function (state, mapKey) {
  return mapKey;
});
var getViewportByMapKeyObserver = recompute.createObserver(getViewportByMapKey);
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getViewLimitsByMapKey = createCachedSelector__default['default']([getMapByKey$1, getMapSetByMapKey$1], function (map, set) {
  if (map) {
    if (set) {
      var _map$data2, _set$data;

      var mapViewLimits = (_map$data2 = map.data) === null || _map$data2 === void 0 ? void 0 : _map$data2.viewLimits;
      var mapSetViewLimits = (_set$data = set.data) === null || _set$data === void 0 ? void 0 : _set$data.viewLimits;
      return mapViewLimits || mapSetViewLimits || null;
    } else {
      var _map$data3;

      return ((_map$data3 = map.data) === null || _map$data3 === void 0 ? void 0 : _map$data3.viewLimits) || null;
    }
  } else {
    return null;
  }
})(function (state, mapKey) {
  return mapKey;
});
/**
 * @param state {Object}
 * @param setKey {string}
 */

var getMapSetMapKeys$1 = reselect.createSelector([getMapSetByKey$1], function (set) {
  var _set$maps;

  return set !== null && set !== void 0 && (_set$maps = set.maps) !== null && _set$maps !== void 0 && _set$maps.length ? set.maps : null;
});
/**
 * @param state {Object}
 * @param setKey {string}
 */

var getMapSetMaps = reselect.createSelector([getMapsAsObject$1, getMapSetMapKeys$1], function (maps, mapKeys) {
  if (maps && mapKeys !== null && mapKeys !== void 0 && mapKeys.length) {
    return mapKeys.map(function (key) {
      return maps[key];
    });
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param setKey {string}
 */

var getMapSetView$1 = reselect.createSelector([getMapSetByKey$1], function (set) {
  if (set) {
    var _set$data2;

    return ptrUtils.map.view.mergeViews(ptrCore.mapConstants.defaultMapView, (_set$data2 = set.data) === null || _set$data2 === void 0 ? void 0 : _set$data2.view);
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param setKey {string}
 */

var getMapSetViewLimits$1 = reselect.createSelector([getMapSetByKey$1], function (set) {
  var _set$data3;

  return (set === null || set === void 0 ? void 0 : (_set$data3 = set.data) === null || _set$data3 === void 0 ? void 0 : _set$data3.viewLimits) || null;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapBackgroundLayerStateByMapKey$1 = reselect.createSelector([getMapByKey$1], function (map) {
  var _map$data4;

  return (map === null || map === void 0 ? void 0 : (_map$data4 = map.data) === null || _map$data4 === void 0 ? void 0 : _map$data4.backgroundLayer) || null;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapLayersStateByMapKey$1 = reselect.createSelector([getMapByKey$1], function (map) {
  var _map$data5;

  return (map === null || map === void 0 ? void 0 : (_map$data5 = map.data) === null || _map$data5 === void 0 ? void 0 : _map$data5.layers) || null;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapSetBackgroundLayerStateByMapKey$1 = reselect.createSelector([getMapSetByMapKey$1], function (set) {
  var _set$data4;

  return (set === null || set === void 0 ? void 0 : (_set$data4 = set.data) === null || _set$data4 === void 0 ? void 0 : _set$data4.backgroundLayer) || null;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapSetLayersStateByMapKey$1 = reselect.createSelector([getMapSetByMapKey$1], function (set) {
  var _set$data5;

  return (set === null || set === void 0 ? void 0 : (_set$data5 = set.data) === null || _set$data5 === void 0 ? void 0 : _set$data5.layers) || null;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapMetadataModifiersByMapKey$1 = reselect.createSelector([getMapByKey$1], function (map) {
  var _map$data6;

  return (map === null || map === void 0 ? void 0 : (_map$data6 = map.data) === null || _map$data6 === void 0 ? void 0 : _map$data6.metadataModifiers) || null;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapSetMetadataModifiersByMapKey$1 = reselect.createSelector([getMapSetByMapKey$1], function (set) {
  var _set$data6;

  return (set === null || set === void 0 ? void 0 : (_set$data6 = set.data) === null || _set$data6 === void 0 ? void 0 : _set$data6.metadataModifiers) || null;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMetadataModifiersByMapKey = createCachedSelector__default['default']([getMapMetadataModifiersByMapKey$1, getMapSetMetadataModifiersByMapKey$1], function (mapModifiers, setModifiers) {
  if (mapModifiers && setModifiers) {
    return _objectSpread2(_objectSpread2({}, setModifiers), mapModifiers);
  } else {
    return setModifiers || mapModifiers || null;
  }
})(function (state, mapKey) {
  return mapKey;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapFilterByActiveByMapKey$1 = reselect.createSelector([getMapByKey$1], function (map) {
  var _map$data7;

  return (map === null || map === void 0 ? void 0 : (_map$data7 = map.data) === null || _map$data7 === void 0 ? void 0 : _map$data7.filterByActive) || null;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getMapSetFilterByActiveByMapKey$1 = reselect.createSelector([getMapSetByMapKey$1], function (set) {
  var _set$data7;

  return (set === null || set === void 0 ? void 0 : (_set$data7 = set.data) === null || _set$data7 === void 0 ? void 0 : _set$data7.filterByActive) || null;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getFilterByActiveByMapKey$1 = createCachedSelector__default['default']([getMapFilterByActiveByMapKey$1, getMapSetFilterByActiveByMapKey$1], function (mapFilter, setFilter) {
  if (mapFilter && setFilter) {
    return _objectSpread2(_objectSpread2({}, mapFilter), setFilter);
  } else {
    return setFilter || mapFilter || null;
  }
})(function (state, mapKey) {
  return mapKey;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getBackgroundLayerStateByMapKey$1 = createCachedSelector__default['default']([getMapBackgroundLayerStateByMapKey$1, getMapSetBackgroundLayerStateByMapKey$1], function (mapBackgroundLayer, setBackgroundLayer) {
  return mapBackgroundLayer || setBackgroundLayer || null;
})(function (state, mapKey) {
  return mapKey;
});
var getBackgroundLayerStateByMapKeyObserver = recompute.createObserver(getBackgroundLayerStateByMapKey$1);
/**
 * @param state {Object}
 * @param mapKey {string}
 * @return {Object} Merged mapSetState with metadataModifiers and filterByActive.
 */

var getMapSetLayersStateWithModifiersByMapKey = createCachedSelector__default['default']([getMapSetLayersStateByMapKey$1, getMapSetMetadataModifiersByMapKey$1, getMapSetFilterByActiveByMapKey$1], function (setLayers, metadataModifiers, mapSetFilterByActive) {
  if (setLayers !== null && setLayers !== void 0 && setLayers.length) {
    return selectorHelpers.mergeModifiersAndFilterByActiveToLayerStructure(setLayers, metadataModifiers, mapSetFilterByActive);
  } else {
    return null;
  }
})(function (state, mapKey) {
  return mapKey;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 * @return {Object} Merged mapState with metadataModifiers and filterByActive.
 */

var getMapLayersStateWithModifiersByMapKey = createCachedSelector__default['default']([getMapLayersStateByMapKey$1, getMetadataModifiersByMapKey, getFilterByActiveByMapKey$1], function (mapLayers, metadataModifiers, mapFilterByActive) {
  if (mapLayers !== null && mapLayers !== void 0 && mapLayers.length) {
    return selectorHelpers.mergeModifiersAndFilterByActiveToLayerStructure(mapLayers, metadataModifiers, mapFilterByActive);
  } else {
    return null;
  }
})(function (state, mapKey) {
  return mapKey;
});
/**
 * @param state {Object}
 * @param mapKey {string}
 * @return {Object} Merged layer state from mapState and mapSetState with metadataModifiers and filterByActive.
 */

var getLayersStateByMapKey$1 = createCachedSelector__default['default']([getMapSetLayersStateWithModifiersByMapKey, getMapLayersStateWithModifiersByMapKey], function (setLayers, mapLayers) {
  if (mapLayers && setLayers) {
    return [].concat(_toConsumableArray(setLayers), _toConsumableArray(mapLayers));
  } else if (mapLayers) {
    return mapLayers;
  } else if (setLayers) {
    return setLayers;
  } else {
    return null;
  }
})(function (state, mapKey) {
  return mapKey;
});
var getLayersStateByMapKeyObserver = recompute.createObserver(getLayersStateByMapKey$1);
/**
 * @param state {Object}
 * @param mapKey {string}
 * @param layerKey {string}
 * @return {Object | null}
 */

var getLayerStateByLayerKeyAndMapKey = reselect.createSelector([getLayersStateByMapKey$1, function (state, mapKey, layerKey) {
  return layerKey;
}], function (layers, layerKey) {
  if (layers) {
    var layer = _find__default['default'](layers, function (layer) {
      return layer.key === layerKey;
    });

    return layer || null;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param mapKey {string}
 */

var getAllLayersStateByMapKey$1 = createCachedSelector__default['default']([getBackgroundLayerStateByMapKey$1, getLayersStateByMapKey$1], function (backgroundLayer, layers) {
  if (layers || backgroundLayer) {
    return selectorHelpers.mergeBackgroundLayerWithLayers(backgroundLayer, layers);
  } else {
    return null;
  }
})(function (state, mapKey) {
  return mapKey;
});
/**
 * @param layerState {Object}
 */

var getSpatialRelationsFilterFromLayerState = recompute.createSelector(function (layerState) {
  if (layerState) {
    // TODO at least a part is the same as in Maps/actions/layerUse?
    var layer = layerState; // modifiers defined by key

    var metadataDefinedByKey = layer.metadataModifiers ? _objectSpread2({}, layer.metadataModifiers) : {}; // Get actual metadata keys defined by filterByActive

    var activeMetadataKeys = commonSelectors.getActiveKeysByFilterByActiveObserver(layer.filterByActive); // Merge metadata, metadata defined by key have priority

    var mergedMetadataKeys = commonHelpers.mergeMetadataKeys(metadataDefinedByKey, activeMetadataKeys); // It converts modifiers from metadataKeys: ["A", "B"] to metadataKey: {in: ["A", "B"]}

    var relationsFilter = commonHelpers.convertModifiersToRequestFriendlyFormat(mergedMetadataKeys); // add layerTemplate od areaTreeLevelKey

    if (layer.layerTemplateKey) {
      relationsFilter.layerTemplateKey = layer.layerTemplateKey;
    } else if (layer.areaTreeLevelKey) {
      relationsFilter.areaTreeLevelKey = layer.areaTreeLevelKey;
    }

    return relationsFilter;
  } else {
    return null;
  }
});
/**
 * @param layerState {Object}
 */

var getAttributeRelationsFilterFromLayerState = recompute.createSelector(function (layerState) {
  var spatialFilter = getSpatialRelationsFilterFromLayerState(layerState);

  if (spatialFilter) {
    var attributeFilter = _objectSpread2({}, spatialFilter);

    if (layerState.styleKey) {
      // add styleKey
      attributeFilter.styleKey = layerState.styleKey;
    }

    return attributeFilter;
  } else {
    return null;
  }
});
/**
 * @param spatialDataSource {Object}
 * @param layerState {Object} layer definition from state or passed to the Map component
 * @param layerKey {string} layer unique identifier
 * @param attributeDataSourceKeyAttributeKeyPairs {Object} key-value pairs, where key is attribute data source key and value is matching attribute key
 * @param mapKey {string} map unique identifier
 * @param spatialRelationsFilter {Object} see getSpatialRelationsFilterFromLayerState
 * @param attributeRelationsFilter {Object} see getAttributeRelationsFilterFromLayerState
 */

var getFinalLayerByDataSourceAndLayerState = recompute.createSelector(function (spatialDataSource, layerState, layerKey, attributeDataSourceKeyAttributeKeyPairs, mapKey, spatialRelationsFilter, attributeRelationsFilter) {
  var _spatialDataSource$da = spatialDataSource === null || spatialDataSource === void 0 ? void 0 : spatialDataSource.data,
      attribution = _spatialDataSource$da.attribution,
      nameInternal = _spatialDataSource$da.nameInternal,
      type = _spatialDataSource$da.type,
      fidColumnName = _spatialDataSource$da.fidColumnName,
      geometryColumnName = _spatialDataSource$da.geometryColumnName,
      dataSourceOptions = _objectWithoutProperties(_spatialDataSource$da, ["attribution", "nameInternal", "type", "fidColumnName", "geometryColumnName"]);

  var key = layerState.key,
      name = layerState.name,
      opacity = layerState.opacity,
      styleKey = layerState.styleKey,
      renderAsType = layerState.renderAsType,
      layerStateOptions = layerState.options;
  layerKey = layerKey || key; // TODO temporary for development. Next, could be data source type rewritten in layer state (e.g. vector -> tiled-vector?)

  if (renderAsType) {
    type = renderAsType;
  }

  var options = _objectSpread2(_objectSpread2({}, dataSourceOptions), layerStateOptions);

  if (type === 'wmts') {
    options.url = dataSourceOptions.url || dataSourceOptions.urls[0];
  } else if (type === 'wms') {
    var url = dataSourceOptions.url,
        params = dataSourceOptions.params,
        configuration = dataSourceOptions.configuration,
        rest = _objectWithoutProperties(dataSourceOptions, ["url", "params", "configuration"]);

    var singleTile = configuration && configuration.hasOwnProperty('singleTile') ? configuration.singleTile : false;
    options = {
      params: _objectSpread2(_objectSpread2({}, params), {}, {
        layers: rest.layers,
        styles: rest.styles
      }),
      singleTile: singleTile,
      url: url
    };
  } else if (type === "vector" || type === "tiled-vector") {
    var _options, _options2;

    var features,
        tiles = null;

    if (type === "vector") {
      features = Data.getFeatures(spatialDataSource.key, fidColumnName, attributeDataSourceKeyAttributeKeyPairs);
    } else if (type === "tiled-vector") {
      var view = getViewByMapKeyObserver(mapKey);
      var viewport = getViewportByMapKeyObserver(mapKey);
      var tileList = selectorHelpers.getTiles(viewport.width, viewport.height, view.center, view.boxRange);
      var level = selectorHelpers.getZoomLevel(viewport.width, viewport.height, view.boxRange);
      tiles = Data.getTiles(spatialDataSource.key, fidColumnName, level, tileList, spatialRelationsFilter, attributeRelationsFilter, attributeDataSourceKeyAttributeKeyPairs, styleKey);
    }

    var selected = null;
    var style = (_options = options) === null || _options === void 0 ? void 0 : _options.style;

    if ((_options2 = options) !== null && _options2 !== void 0 && _options2.selected) {
      selected = Selections.prepareSelectionByLayerStateSelected(options.selected);
    }

    if (!style && styleKey) {
      style = Styles.getDefinitionByKey(styleKey);
    }

    options = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, options), selected && {
      selected: selected
    }), style && {
      style: style
    }), features && {
      features: features
    }), tiles && {
      tiles: tiles
    }), {}, {
      fidColumnName: fidColumnName,
      geometryColumnName: geometryColumnName
    });
  }

  return {
    key: layerKey + '_' + spatialDataSource.key,
    layerKey: layerKey,
    opacity: opacity || 1,
    name: name,
    type: type,
    options: options
  };
});
/**
 * @param mapKey {string} map unique identifier
 * @param layerState {Object} layer definition in state (see getBackgroundLayerState) or passed to the Map component
 * @return {Array} It returns a list of end format definitions of the background layer (per data source). See: https://gisat.github.io/ > Architecture > System data types > Layers
 */

var getMapBackgroundLayer$1 = recompute.createSelector(function (mapKey, layerState) {
  if (!layerState) {
    layerState = getBackgroundLayerStateByMapKeyObserver(mapKey);
  }

  if (layerState) {
    if (layerState.type) {
      return layerState;
    } else {
      var layerKey = 'pantherBackgroundLayer';
      var spatialDataSources = Data.spatialDataSources.getIndexed(layerState);

      if (spatialDataSources) {
        return spatialDataSources.map(function (dataSource) {
          var _dataSource$data;

          var dataSourceType = dataSource === null || dataSource === void 0 ? void 0 : (_dataSource$data = dataSource.data) === null || _dataSource$data === void 0 ? void 0 : _dataSource$data.type; // TODO currently only wms or wmts is supported; add filterByActive & metadata modifiers to support vectors

          if (dataSourceType === "wmts" || dataSourceType === "wms") {
            return getFinalLayerByDataSourceAndLayerState(dataSource, layerState, layerKey);
          } else {
            return null;
          }
        });
      } else {
        return null;
      }
    }
  } else {
    return null;
  }
});
/**
 * @param mapKey {string} map unique identifier
 * @param layerState {Object} layer definition in state (see getBackgroundLayerState) or passed to the Map component
 * @return {Array} It returns a list of end format definitions of the background layer (per data source). See: https://gisat.github.io/ > Architecture > System data types > Layers
 */

var getMapLayers$1 = recompute.createSelector(function (mapKey, layersState) {
  if (!layersState) {
    layersState = getLayersStateByMapKeyObserver(mapKey);
  }

  if (layersState) {
    var finalLayers = [];

    _forEach__default['default'](layersState, function (layerState) {
      // layer is already defined by the end format suitable for presentational map component
      if (layerState.type) {
        var _layerState$options;

        if (layerState.type === "vector" && (_layerState$options = layerState.options) !== null && _layerState$options !== void 0 && _layerState$options.selected) {
          layerState = _objectSpread2(_objectSpread2({}, layerState), {}, {
            options: _objectSpread2(_objectSpread2({}, layerState.options), {}, {
              selected: Selections.prepareSelectionByLayerStateSelected(layerState.options.selected)
            })
          });
        }

        finalLayers.push(layerState);
      } // necessary to assemble data for the end format
      else {
          var spatialRelationsFilter = getSpatialRelationsFilterFromLayerState(layerState);
          var attributeRelationsFilter = getAttributeRelationsFilterFromLayerState(layerState);
          var spatialDataSources = Data.spatialDataSources.getIndexed(spatialRelationsFilter);
          var attributeDataSourceKeyAttributeKeyPairs = Data.attributeRelations.getFilteredAttributeDataSourceKeyAttributeKeyPairs(attributeRelationsFilter);

          if (spatialDataSources) {
            _forEach__default['default'](spatialDataSources, function (dataSource) {
              finalLayers.push(getFinalLayerByDataSourceAndLayerState(dataSource, layerState, null, attributeDataSourceKeyAttributeKeyPairs, mapKey, spatialRelationsFilter, attributeRelationsFilter));
            });
          }
        }
    });

    return finalLayers.length ? finalLayers : null;
  } else {
    return null;
  }
});
var Maps = {
  getAllLayersStateByMapKey: getAllLayersStateByMapKey$1,
  getBackgroundLayerStateByMapKey: getBackgroundLayerStateByMapKey$1,
  getFilterByActiveByMapKey: getFilterByActiveByMapKey$1,
  getLayerStateByLayerKeyAndMapKey: getLayerStateByLayerKeyAndMapKey,
  getLayersStateByMapKey: getLayersStateByMapKey$1,
  getMetadataModifiersByMapKey: getMetadataModifiersByMapKey,
  getMapBackgroundLayerStateByMapKey: getMapBackgroundLayerStateByMapKey$1,
  getMapBackgroundLayer: getMapBackgroundLayer$1,
  getMapByKey: getMapByKey$1,
  getMapFilterByActiveByMapKey: getMapFilterByActiveByMapKey$1,
  getMapLayersStateByMapKey: getMapLayersStateByMapKey$1,
  getMapLayers: getMapLayers$1,
  getMapLayersStateWithModifiersByMapKey: getMapLayersStateWithModifiersByMapKey,
  getMapMetadataModifiersByMapKey: getMapMetadataModifiersByMapKey$1,
  getMapSetActiveMapKey: getMapSetActiveMapKey$1,
  getMapSetActiveMapView: getMapSetActiveMapView$1,
  getMapSetBackgroundLayerStateByMapKey: getMapSetBackgroundLayerStateByMapKey$1,
  getMapSetByMapKey: getMapSetByMapKey$1,
  getMapSetByKey: getMapSetByKey$1,
  getMapSetFilterByActiveByMapKey: getMapSetFilterByActiveByMapKey$1,
  getMapSetLayersStateByMapKey: getMapSetLayersStateByMapKey$1,
  getMapSetLayersStateWithModifiersByMapKey: getMapSetLayersStateWithModifiersByMapKey,
  getMapSetMetadataModifiersByMapKey: getMapSetMetadataModifiersByMapKey$1,
  getMapSetMapKeys: getMapSetMapKeys$1,
  getMapSetMaps: getMapSetMaps,
  getMapSets: getMapSets$1,
  getMapSetView: getMapSetView$1,
  getMapSetViewLimits: getMapSetViewLimits$1,
  getViewByMapKey: getViewByMapKey,
  getViewportByMapKey: getViewportByMapKey,
  getViewLimitsByMapKey: getViewLimitsByMapKey
};

var getSubstate$s = function getSubstate(state) {
  return state.scopes;
};

var getAll$e = commonSelectors.getAll(getSubstate$s);
var getAllAsObject$h = commonSelectors.getAllAsObject(getSubstate$s);
var getActive$9 = commonSelectors.getActive(getSubstate$s);
var getActiveKey$9 = commonSelectors.getActiveKey(getSubstate$s);
var getByKey$d = commonSelectors.getByKey(getSubstate$s);
var getByKeys$a = commonSelectors.getByKeys(getSubstate$s);
var getByFilterOrder$2 = commonSelectors.getByFilterOrder(getSubstate$s);
var getDataByKey$7 = commonSelectors.getDataByKey(getSubstate$s);
var getEditedDataByKey$6 = commonSelectors.getEditedDataByKey(getSubstate$s);
var getDeletePermissionByKey$6 = commonSelectors.getDeletePermissionByKey(getSubstate$s);
var getUpdatePermissionByKey$6 = commonSelectors.getUpdatePermissionByKey(getSubstate$s);
var getIndexed$7 = commonSelectors.getIndexed(getSubstate$s);
var getStateToSave$3 = commonSelectors.getStateToSave(getSubstate$s);
var getActiveScopeConfiguration = reselect.createSelector([getActive$9], function (scope) {
  return scope && scope.data && scope.data.configuration ? scope.data.configuration : null;
});
var Scopes = {
  getActive: getActive$9,
  getActiveKey: getActiveKey$9,
  getActiveScopeConfiguration: getActiveScopeConfiguration,
  getAll: getAll$e,
  getAllAsObject: getAllAsObject$h,
  getByFilterOrder: getByFilterOrder$2,
  getDataByKey: getDataByKey$7,
  getByKeys: getByKeys$a,
  getDeletePermissionByKey: getDeletePermissionByKey$6,
  getEditedDataByKey: getEditedDataByKey$6,
  getIndexed: getIndexed$7,
  getUpdatePermissionByKey: getUpdatePermissionByKey$6,
  getStateToSave: getStateToSave$3,
  getSubstate: getSubstate$s,
  // TODO handle following obsolete exports
  getActiveScopeData: getActive$9,
  getActiveScopeKey: getActiveKey$9,
  getScopes: getAll$e,
  getScopeData: getByKey$d
};

var getSubstate$t = function getSubstate(state) {
  return state.places;
};

var getAll$f = commonSelectors.getAll(getSubstate$t);
var getAllAsObject$i = commonSelectors.getAllAsObject(getSubstate$t);
var getAllForActiveScope$6 = commonSelectors.getAllForActiveScope(getSubstate$t);
var getActiveKey$a = commonSelectors.getActiveKey(getSubstate$t);
var getActiveKeys$4 = commonSelectors.getActiveKeys(getSubstate$t);
var getActive$a = commonSelectors.getActive(getSubstate$t);
var getActivePlaces = commonSelectors.getActiveModels(getSubstate$t);
var getDataByKey$8 = commonSelectors.getDataByKey(getSubstate$t);
var getDeletePermissionByKey$7 = commonSelectors.getDeletePermissionByKey(getSubstate$t);
var getEditedDataByKey$7 = commonSelectors.getEditedDataByKey(getSubstate$t);
var getUpdatePermissionByKey$7 = commonSelectors.getUpdatePermissionByKey(getSubstate$t); // TODO refactor

var getPlacesForActiveScope = reselect.createSelector([getAll$f, Scopes.getActiveScopeKey], function (models, activeScopeKey) {
  return _filter__default['default'](models, function (model) {
    return model.data && model.data.dataset === activeScopeKey;
  });
});
var getActiveView = reselect.createSelector([getActive$a], function (place) {
  if (place && place.data && place.data.bbox) {
    return ptrUtils.map.view.getViewFromBoundingBox(place.data.bbox, true);
  } else {
    return null;
  }
});
var Places = {
  getPlaces: getAll$f,
  getAll: getAll$f,
  getAllAsObject: getAllAsObject$i,
  getAllForActiveScope: getAllForActiveScope$6,
  getActiveKey: getActiveKey$a,
  getActiveKeys: getActiveKeys$4,
  getActive: getActive$a,
  getActivePlaces: getActivePlaces,
  getActiveView: getActiveView,
  getByKey: commonSelectors.getByKey(getSubstate$t),
  getDataByKey: getDataByKey$8,
  getDeletePermissionByKey: getDeletePermissionByKey$7,
  getEditedDataByKey: getEditedDataByKey$7,
  getIndexed: commonSelectors.getIndexed(getSubstate$t),
  getPlacesForActiveScope: getPlacesForActiveScope,
  getUpdatePermissionByKey: getUpdatePermissionByKey$7,
  getSubstate: getSubstate$t
};

var getSubstate$u = function getSubstate(state) {
  return state.scenarios.scenarios;
};

var isDefaultSituationActive = function isDefaultSituationActive(state) {
  return state.scenarios.scenarios.defaultSituationActive;
};

var getAll$g = commonSelectors.getAll(getSubstate$u);
var getAllAsObject$j = commonSelectors.getAllAsObject(getSubstate$u);
var getActiveKey$b = commonSelectors.getActiveKey(getSubstate$u);
var getActiveKeys$5 = commonSelectors.getActiveKeys(getSubstate$u);
var getActive$b = commonSelectors.getActive(getSubstate$u);
var getActiveScenarios = commonSelectors.getActiveModels(getSubstate$u);
var getByKey$e = commonSelectors.getByKey(getSubstate$u);
var getEditedAll$1 = commonSelectors.getEditedAll(getSubstate$u);
var getEditedAllAsObject$1 = commonSelectors.getEditedAllAsObject(getSubstate$u);
var getEditedByKey$1 = commonSelectors.getEditedByKey(getSubstate$u);
var getEditedKeys$1 = commonSelectors.getEditedKeys(getSubstate$u);
/**
 * Select spatial data source for scenario (based on source type)
 */

var getPucsScenariosVectorSource = reselect.createSelector([function (state, scenarioKey, defaultSituation) {
  return {
    scenarioKey: scenarioKey,
    defaultSituation: defaultSituation
  };
}], function (scenarioData, vectorLayers) {
  var source = null;

  if (scenarioData.scenarioKey && vectorLayers.length) {
    source = _find__default['default'](vectorLayers, {
      'scenarioKey': scenarioData.scenarioKey
    });
  } else if (scenarioData.defaultSituation && vectorLayers.length) {
    source = _find__default['default'](vectorLayers, {
      'scenarioKey': null
    });
  }

  return source ? source : null;
});
var scenariosSelectors = {
  getActive: getActive$b,
  getActiveKey: getActiveKey$b,
  getActiveKeys: getActiveKeys$5,
  getActiveScenarios: getActiveScenarios,
  getAll: getAll$g,
  getAllAsObject: getAllAsObject$j,
  getByKey: getByKey$e,
  getEditedAll: getEditedAll$1,
  getEditedAllAsObject: getEditedAllAsObject$1,
  getEditedByKey: getEditedByKey$1,
  getEditedKeys: getEditedKeys$1,
  getSubstate: getSubstate$u,
  isDefaultSituationActive: isDefaultSituationActive,
  getPucsScenariosVectorSource: getPucsScenariosVectorSource
};

var getSubstate$v = function getSubstate(state) {
  return state.scenarios.cases;
};

var getAll$h = commonSelectors.getAll(getSubstate$v);
var getActiveKey$c = commonSelectors.getActiveKey(getSubstate$v);
var getActive$c = commonSelectors.getActive(getSubstate$v);
var getByKey$f = commonSelectors.getByKey(getSubstate$v);
var getEditedAll$2 = commonSelectors.getEditedAll(getSubstate$v);
var getEditedActive$1 = commonSelectors.getEditedActive(getSubstate$v);
var activeCaseScenariosLoaded = reselect.createSelector([getActive$c], function (activeCase) {
  return activeCase && activeCase.data && activeCase.data.scenariosLoaded ? activeCase.data.scenariosLoaded : false;
});
/**
 * It should select scenario keys of active case from byKey
 */

var getActiveCaseScenarioKeys = reselect.createSelector([getActive$c], function (activeCase) {
  return activeCase && activeCase.data && activeCase.data.scenarios ? activeCase.data.scenarios : null;
});
/**
 * It should select scenario keys of active case from editedByKey
 */

var getActiveCaseEditedScenarioKeys = reselect.createSelector([getEditedActive$1], function (activeCaseEdited) {
  return activeCaseEdited && activeCaseEdited.data && activeCaseEdited.data.scenarios ? activeCaseEdited.data.scenarios : null;
});
/**
 * It should select scenario models for active case
 */

var getActiveCaseScenarios = reselect.createSelector([scenariosSelectors.getAllAsObject, getActiveCaseScenarioKeys], function (scenarios, activeCaseScenarioKeys) {
  if (scenarios && !_isEmpty__default['default'](scenarios) && activeCaseScenarioKeys) {
    var selectedModels = _pick__default['default'](scenarios, activeCaseScenarioKeys);

    return selectedModels && !_isEmpty__default['default'](selectedModels) ? Object.values(selectedModels) : null;
  } else {
    return null;
  }
});
/**
 * It should select keys of edited scenarios for active case
 */

var getActiveCaseScenariosEditedKeys = reselect.createSelector([getActive$c, scenariosSelectors.getEditedKeys], function (activeCase, scenariosEditedKeys) {
  if (activeCase && activeCase.data && activeCase.data.scenarios && scenariosEditedKeys) {
    var commonKeys = _intersection__default['default'](activeCase.data.scenarios, scenariosEditedKeys);

    return commonKeys && commonKeys.length ? commonKeys : null;
  } else {
    return null;
  }
});
/**
 * It should select edited scenarios data for active case
 */

var getActiveCaseScenariosEdited = reselect.createSelector([scenariosSelectors.getEditedAllAsObject, getActiveCaseScenarioKeys, getActiveCaseEditedScenarioKeys], function (scenariosEdited, activeCaseScenarioKeys, activeCaseEditedScenarioKeys) {
  if (scenariosEdited && !_isEmpty__default['default'](scenariosEdited)) {
    var keys = [];

    if (activeCaseScenarioKeys && activeCaseEditedScenarioKeys) {
      keys = [].concat(_toConsumableArray(activeCaseScenarioKeys), _toConsumableArray(activeCaseEditedScenarioKeys));
    } else if (activeCaseScenarioKeys && !activeCaseEditedScenarioKeys) {
      keys = activeCaseScenarioKeys;
    } else if (!activeCaseScenarioKeys && activeCaseEditedScenarioKeys) {
      keys = activeCaseEditedScenarioKeys;
    }

    var selectedEditedModels = _pick__default['default'](scenariosEdited, keys);

    return selectedEditedModels && !_isEmpty__default['default'](selectedEditedModels) ? Object.values(selectedEditedModels) : null;
  } else {
    return null;
  }
});
/**
 * It should select first edited scenario for active case
 * TODO clarify usage
 */

var getActiveCaseScenarioEdited = reselect.createSelector([getActiveCaseScenariosEdited], function (scenariosEdited) {
  if (scenariosEdited && scenariosEdited.length === 1) {
    return scenariosEdited[0];
  } else {
    return null;
  }
});
/**
 * Select all cases for active place
 */

var getActivePlaceCases = reselect.createSelector([getAll$h, Places.getActiveKey], function (cases, activePlaceKey) {
  if (cases && cases.length && activePlaceKey) {
    return _filter__default['default'](cases, function (caseItem) {
      return _includes__default['default'](caseItem.data.place_ids, activePlaceKey);
    });
  } else {
    return [];
  }
});
var casesSelectors = {
  getActive: getActive$c,
  getActiveKey: getActiveKey$c,
  getAll: getAll$h,
  getByKey: getByKey$f,
  getEditedAll: getEditedAll$2,
  activeCaseScenariosLoaded: activeCaseScenariosLoaded,
  getActiveCaseEdited: getEditedActive$1,
  getActiveCaseEditedScenarioKeys: getActiveCaseEditedScenarioKeys,
  getActiveCaseScenarioKeys: getActiveCaseScenarioKeys,
  getActiveCaseScenarioEdited: getActiveCaseScenarioEdited,
  getActiveCaseScenarios: getActiveCaseScenarios,
  getActiveCaseScenariosEdited: getActiveCaseScenariosEdited,
  getActiveCaseScenariosEditedKeys: getActiveCaseScenariosEditedKeys,
  getActivePlaceCases: getActivePlaceCases,
  getSubstate: getSubstate$v
};

var Scenarios = {
  cases: casesSelectors,
  scenarios: scenariosSelectors
};

var getAllScreensAsObject = function getAllScreensAsObject(state) {
  return state.screens.screens;
};

var getAllSetsAsObject = function getAllSetsAsObject(state) {
  return state.screens.sets;
};
/**
 * @param state {Object}
 * @param key {string} set key
 */


var getSetByKey$1 = reselect.createSelector([getAllSetsAsObject, function (state, key) {
  return key;
}],
/**
 * @param sets {Object} all sets as object
 * @param key {string} set key
 * @return {Object | null} selected object
 */
function (sets, key) {
  if (sets && !_isEmpty__default['default'](sets) && key && sets[key]) {
    return sets[key];
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param key {string} set key
 */

var getScreensBySetKey = reselect.createSelector([getSetByKey$1, getAllScreensAsObject],
/**
 * @param set {Object} set
 * @param screens {Object} all screens as object
 * @return {null | Object} selected screen
 */
function (set, screens) {
  if (set) {
    var setScreens = {};

    _each__default['default'](set.orderBySpace, function (lineage) {
      setScreens[lineage] = screens[lineage];
    });

    return setScreens;
  } else {
    return null;
  }
});
/**
 * @param state {Object}
 * @param screenLineage {string}
 */

var getSetKeyByScreenLineage = reselect.createSelector([getAllSetsAsObject, function (state, screenLineage) {
  return screenLineage;
}],
/**
 * @param sets {Object} all sets as object
 * @param lineage {string}
 * @return {string | null} screen set key
 */
function (sets, lineage) {
  var setKey = null;

  _forIn__default['default'](sets, function (value, key) {
    if (_includes__default['default'](value.orderByHistory, lineage)) {
      setKey = key;
    }
  });

  return setKey;
});
/**
 * @param state {Object}
 * @param screenLineage {string}
 */

var getScreenByLineage = reselect.createSelector([getAllScreensAsObject, function (state, lineage) {
  return lineage;
}],
/**
 * @param screens {object} all screens as object
 * @param lineage {string}
 * @return {Object | null} screen
 */
function (screens, lineage) {
  if (screens && !_isEmpty__default['default'](screens) && lineage && screens[lineage]) {
    return screens[lineage];
  } else {
    return null;
  }
});
var Screens = {
  getScreenByLineage: getScreenByLineage,
  getScreensBySetKey: getScreensBySetKey,
  getSetByKey: getSetByKey$1,
  getSetKeyByScreenLineage: getSetKeyByScreenLineage
};

var getSubstate$w = function getSubstate(state) {
  return state.snapshots;
};

var getAll$i = commonSelectors.getAll(getSubstate$w);
var Snapshots = {
  getAll: getAll$i
};

var getSubstate$x = function getSubstate(state) {
  return state.tags;
};

var getAll$j = commonSelectors.getAll(getSubstate$x);
var getAllAsObject$k = commonSelectors.getAllAsObject(getSubstate$x);
var getByKey$g = commonSelectors.getByKey(getSubstate$x);
var getByKeys$b = commonSelectors.getByKeys(getSubstate$x);
var getDataByKey$9 = commonSelectors.getDataByKey(getSubstate$x);
var getEditedDataByKey$8 = commonSelectors.getEditedDataByKey(getSubstate$x);
var getIndexed$8 = commonSelectors.getIndexed(getSubstate$x);
var getDeletePermissionByKey$8 = commonSelectors.getDeletePermissionByKey(getSubstate$x);
var getUpdatePermissionByKey$8 = commonSelectors.getUpdatePermissionByKey(getSubstate$x);
var Tags = {
  getAll: getAll$j,
  getAllAsObject: getAllAsObject$k,
  getByKey: getByKey$g,
  getByKeys: getByKeys$b,
  getDataByKey: getDataByKey$9,
  getDeletePermissionByKey: getDeletePermissionByKey$8,
  getEditedDataByKey: getEditedDataByKey$8,
  getIndexed: getIndexed$8,
  getUpdatePermissionByKey: getUpdatePermissionByKey$8,
  getSubstate: getSubstate$x
};

var DEFAULT_CATEGORY = 'metadata';

var getSubstate$y = function getSubstate(state) {
  return state.users;
};

var getGroupsSubstate = function getGroupsSubstate(state) {
  return state.users.groups;
};

var getAll$k = commonSelectors.getAll(getSubstate$y);
var getGroups = commonSelectors.getAll(getGroupsSubstate);
var getActiveKey$d = commonSelectors.getActiveKey(getSubstate$y);
var getActive$d = commonSelectors.getActive(getSubstate$y);
var getByKey$h = commonSelectors.getByKey(getSubstate$y);

var isLoggedIn = function isLoggedIn(state) {
  return !!state.users.activeKey;
};

var isAdmin = function isAdmin(state) {
  return state.users.isAdmin;
};

var getById = reselect.createSelector([getAll$k, function (state, userId) {
  return userId;
}], function (users, userId) {
  if (userId) {
    return users.find(function (user) {
      return user.id === userId;
    });
  }

  return false;
});
var isAdminGroupMember = reselect.createSelector([getActive$d], function (user) {
  if (user) {
    return _includes__default['default'](user.groups, 1);
  }

  return false;
});
var getActiveUserPermissions = reselect.createSelector([getActive$d], function (user) {
  if (user && user.permissions) {
    return user.permissions;
  } else {
    return null;
  }
});
var isAdminOrAdminGroupMember = reselect.createSelector([isAdmin, isAdminGroupMember], function (isAdmin, isAdminGroupMember) {
  return isAdmin || isAdminGroupMember;
});
var getGroupKeysForActiveUser = reselect.createSelector([getActive$d], function (activeUser) {
  if (activeUser && activeUser.groups) {
    return activeUser.groups;
  } else {
    return [];
  }
});
var hasActiveUserPermissionToCreate = reselect.createSelector([getActiveUserPermissions, function (state, type) {
  return type;
}, function (state, type, category) {
  return category;
}], function (permissions, type) {
  var category = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_CATEGORY;
  return type && permissions && permissions[category] && permissions[category][type] && permissions[category][type].create;
});

var isDromasAdmin = function isDromasAdmin(state) {
  var isDromasAdmin = false;

  if (state.users && state.users.data && state.users.data.length) {
    var currentUser = state.users.data.filter(function (user) {
      return user.key === state.users.activeKey;
    });

    if (currentUser.length > 0) {
      currentUser[0].groups.forEach(function (group) {
        if (group.name === 'Aktualizace LPIS Gisat admin') {
          isDromasAdmin = true;
        }
      });
    }
  }

  return isDromasAdmin || state.users.isAdmin;
};

var getActiveUserDromasLpisChangeReviewGroup = reselect.createSelector([getGroupKeysForActiveUser, Scopes.getActiveScopeConfiguration], function (activeUserGroupKeys, activeScopeConfiguration) {
  if (_includes__default['default'](activeUserGroupKeys, activeScopeConfiguration.dromasLpisChangeReview.groups.gisatAdmins)) {
    return 'gisatAdmins';
  } else if (_includes__default['default'](activeUserGroupKeys, activeScopeConfiguration.dromasLpisChangeReview.groups.szifAdmins)) {
    return 'szifAdmins';
  } else if (_includes__default['default'](activeUserGroupKeys, activeScopeConfiguration.dromasLpisChangeReview.groups.gisatUsers)) {
    return 'gisatUsers';
  } else if (_includes__default['default'](activeUserGroupKeys, activeScopeConfiguration.dromasLpisChangeReview.groups.szifUsers)) {
    return 'szifUsers';
  } else {
    return null;
  }
});
var Users = {
  getAll: getAll$k,
  getActive: getActive$d,
  getByKey: getByKey$h,
  getById: getById,
  getActiveKey: getActiveKey$d,
  getActiveUser: getActive$d,
  getGroupKeysForActiveUser: getGroupKeysForActiveUser,
  getGroupsForActiveUser: getGroupKeysForActiveUser,
  getUsers: getAll$k,
  getGroups: getGroups,
  getSubstate: getSubstate$y,
  getGroupsSubstate: getGroupsSubstate,
  hasActiveUserPermissionToCreate: hasActiveUserPermissionToCreate,
  isAdmin: isAdmin,
  isAdminGroupMember: isAdminGroupMember,
  isAdminOrAdminGroupMember: isAdminOrAdminGroupMember,
  isLoggedIn: isLoggedIn,
  isDromasAdmin: isDromasAdmin,
  getActiveUserDromasLpisChangeReviewGroup: getActiveUserDromasLpisChangeReviewGroup
};

var getSubstate$z = function getSubstate(state) {
  return state.views;
};

var getActiveKey$e = commonSelectors.getActiveKey(getSubstate$z);
var getActiveKeys$6 = commonSelectors.getActiveKeys(getSubstate$z);
var getAll$l = commonSelectors.getAll(getSubstate$z);
var getAllAsObject$l = commonSelectors.getAllAsObject(getSubstate$z);
var getByKey$i = commonSelectors.getByKey(getSubstate$z);
var getByKeys$c = commonSelectors.getByKeys(getSubstate$z);
var getDataByKey$a = commonSelectors.getDataByKey(getSubstate$z);
var getEditedDataByKey$9 = commonSelectors.getEditedDataByKey(getSubstate$z);
var getDeletePermissionByKey$9 = commonSelectors.getDeletePermissionByKey(getSubstate$z);
var getUpdatePermissionByKey$9 = commonSelectors.getUpdatePermissionByKey(getSubstate$z);
var getStateToSave$4 = reselect.createSelector([selectors$6.getStateToSave, selectors$7.getStateToSave, selectors$b.getStateToSave, Scopes.getStateToSave], function (attributes, attributeSets, components, scopes) {
  return {
    attributes: attributes,
    attributeSets: attributeSets,
    components: components,
    scopes: scopes
  };
});
var Views = {
  getActiveKey: getActiveKey$e,
  getActiveKeys: getActiveKeys$6,
  getByKeys: getByKeys$c,
  getDataByKey: getDataByKey$a,
  getEditedDataByKey: getEditedDataByKey$9,
  getViewsData: getByKey$i,
  getAll: getAll$l,
  getAllAsObject: getAllAsObject$l,
  getDeletePermissionByKey: getDeletePermissionByKey$9,
  getUpdatePermissionByKey: getUpdatePermissionByKey$9,
  getStateToSave: getStateToSave$4,
  getSubstate: getSubstate$z
};

var getAllSetsAsObject$1 = function getAllSetsAsObject(state) {
  return state.windows.sets;
};

var getAllWindowsAsObject = function getAllWindowsAsObject(state) {
  return state.windows.windows;
};

var getSetByKey$2 = reselect.createSelector([getAllSetsAsObject$1, function (state, key) {
  return key;
}], function (sets, key) {
  return sets && sets[key];
});
var getWindow = reselect.createSelector([getAllWindowsAsObject, function (state, key) {
  return key;
}], function (windows, key) {
  return windows && windows[key];
});
var getWindowsBySetKeyAsObject = reselect.createSelector([getSetByKey$2, getAllWindowsAsObject], function (set, windows) {
  if (set && set.orderByHistory && set.orderByHistory.length) {
    var setWindows = {};

    _each__default['default'](set.orderByHistory, function (key) {
      setWindows[key] = windows[key];
    });

    return setWindows;
  } else {
    return null;
  }
});
var isOpen = reselect.createSelector([getWindow], function (window) {
  return window && window.data && window.data.state === 'open';
});
var Windows = {
  getSetByKey: getSetByKey$2,
  getWindow: getWindow,
  getWindowsBySetKeyAsObject: getWindowsBySetKeyAsObject,
  isOpen: isOpen
};

var Select = {
  _deprecatedSelections: _deprecatedSelections,
  _deprecatedMaps: _deprecatedMaps,
  app: selectors$3,
  areas: Areas,
  areaRelations: AreaRelations,
  attributes: selectors$6,
  attributeData: selectors$1,
  attributeDataSources: selectors$2,
  attributeStatistics: selectors$8,
  attributeRelations: selectors,
  attributeSets: selectors$7,
  cases: selectors$9,
  charts: selectors$a,
  components: selectors$b,
  data: Data,
  layerPeriods: selectors$d,
  layerTemplates: LayerTemplates,
  layerTrees: LayerTrees,
  maps: Maps,
  periods: Periods,
  places: Places,
  scenarios: Scenarios,
  scopes: Scopes,
  screens: Screens,
  selections: Selections,
  snapshots: Snapshots,
  spatialData: SpatialData,
  spatialDataSources: SpatialDataSources,
  spatialRelations: SpatialRelations,
  styles: Styles,
  tags: Tags,
  users: Users,
  views: Views,
  windows: Windows
};

var getEurope = function getEurope(state) {
  return state.countries.europe;
};

var getAfrica = function getAfrica(state) {
  return state.countries.africa;
};

var getAsia = function getAsia(state) {
  return state.countries.asia;
};

var getEuropeCountryByKey = createCachedSelector__default['default']([getEurope, function (state, key) {
  return key;
}], function (europe, key) {
  if (europe && key) {
    return _objectSpread2(_objectSpread2({}, europe[key]), {}, {
      "case": "European country"
    });
  } else {
    return null;
  }
})(function (state, key) {
  return key;
});
var getAfricaCountryByKey = createCachedSelector__default['default']([getAfrica, function (state, key) {
  return key;
}], function (africa, key) {
  if (africa && key) {
    return _objectSpread2(_objectSpread2({}, africa[key]), {}, {
      "case": "African country"
    });
  } else {
    return null;
  }
})(function (state, key) {
  return key;
});
var getAsiaCountryByKey = createCachedSelector__default['default']([getAsia, function (state, key) {
  return key;
}], function (asia, key) {
  if (asia && key) {
    return _objectSpread2(_objectSpread2({}, asia[key]), {}, {
      "case": "Asian country"
    });
  } else {
    return null;
  }
})(function (state, key) {
  return key;
});
var getThreeCountries = createCachedSelector__default['default']([function (state, europeKey) {
  return getEuropeCountryByKey(state, europeKey);
}, function (state, europeKey, africaKey) {
  return getAfricaCountryByKey(state, africaKey);
}, function (state, europeKey, africaKey, asiaKey) {
  return getAsiaCountryByKey(state, asiaKey);
}], function (europeanCountry, africanCountry, asianCountry) {
  return [europeanCountry, africanCountry, asianCountry];
})(function (state, europeKey, africaKey, asiaKey) {
  return "".concat(europeKey, "_").concat(africaKey, "_").concat(asiaKey);
});
var selectorsCacheTest = {
  countries: {
    getEuropeCountryByKey: getEuropeCountryByKey,
    getAfricaCountryByKey: getAfricaCountryByKey,
    getAsiaCountryByKey: getAsiaCountryByKey,
    getThreeCountries: getThreeCountries
  }
};

function testCache(testingFunction, params, expectedResult, otherParams) {
  it('should be cached', function () {
    if (!otherParams) {
      otherParams = params.map(function (param) {
        return null;
      });
    } // first run of the selector should return computed value


    var firstOutput = testingFunction.apply(void 0, _toConsumableArray(params));
    chai.assert.deepStrictEqual(expectedResult, firstOutput);
    chai.assert.notEqual(expectedResult, firstOutput); // second run to simulate different params

    testingFunction.apply(void 0, _toConsumableArray(otherParams)); // third run with the same params as the first one should return cached value

    var thirdOutput = testingFunction.apply(void 0, _toConsumableArray(params));
    chai.assert.equal(firstOutput, thirdOutput);
  });
}

var testHelpers = {
  testCache: testCache
};

describe('selectorsCacheTest', function () {
  var state = {
    countries: {
      europe: {
        germany: {
          name: "Germany"
        },
        france: {
          name: "France"
        }
      },
      asia: {
        china: {
          name: "China"
        },
        japan: {
          name: "Japan"
        }
      },
      africa: {
        egypt: {
          name: "Egypt"
        },
        mali: {
          name: "Mali"
        }
      }
    },
    cities: {
      newYork: {
        name: ""
      }
    }
  };
  describe('getEuropeCountryByKey', function () {
    var expectedResult = {
      "case": "European country",
      name: "Germany"
    };

    var updatedState = _objectSpread2(_objectSpread2({}, state), {}, {
      cities: _objectSpread2(_objectSpread2({}, state.cities), {}, {
        prague: {}
      })
    });

    it('should return expected country', function () {
      var output = selectorsCacheTest.countries.getEuropeCountryByKey(state, "germany");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    testHelpers.testCache(selectorsCacheTest.countries.getEuropeCountryByKey, [state, "germany"], expectedResult, [updatedState, "france"]);
    it('should return cached value', function () {
      var output = selectorsCacheTest.countries.getEuropeCountryByKey(state, "germany");

      var updatedState2 = _objectSpread2(_objectSpread2({}, state), {}, {
        countries: _objectSpread2(_objectSpread2({}, state.countries), {}, {
          europe: _objectSpread2(_objectSpread2({}, state.countries.europe), {}, {
            czechia: {}
          })
        })
      });

      var midtermOutput = selectorsCacheTest.countries.getEuropeCountryByKey(state, "france");
      var secondOutput = selectorsCacheTest.countries.getEuropeCountryByKey(updatedState2, "germany");
      chai.assert.notEqual(output, secondOutput);
    });
    it('should return cached value', function () {
      var output = selectorsCacheTest.countries.getEuropeCountryByKey(state, "germany");

      var updatedState = _objectSpread2(_objectSpread2({}, state), {}, {
        cities: _objectSpread2(_objectSpread2({}, state.cities), {}, {
          prague: {}
        })
      });

      var secondOutput = selectorsCacheTest.countries.getEuropeCountryByKey(updatedState, "germany");
      chai.assert.equal(output, secondOutput);
    });
  });
  describe('getThreeCountries', function () {
    var expectedResult = [{
      "case": "European country",
      name: "Germany"
    }, {
      "case": "African country",
      name: "Egypt"
    }, {
      "case": "Asian country",
      name: "Japan"
    }];
    it('should return expected countries', function () {
      var output = selectorsCacheTest.countries.getThreeCountries(state, "germany", "egypt", "japan");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return expected', function () {
      var output = selectorsCacheTest.countries.getThreeCountries(state, "germany", "egypt", "japan");
      var output2 = selectorsCacheTest.countries.getThreeCountries(state, "germany", "mali", "japan");
      var output3 = selectorsCacheTest.countries.getThreeCountries(state, "germany", "egypt", "japan");
      chai.assert.notEqual(output, output2);
      chai.assert.equal(output, output3);
    });
    testHelpers.testCache(selectorsCacheTest.countries.getThreeCountries, [state, "germany", "egypt", "japan"], expectedResult, [state, "germany", "egypt", "china"]);
    it('should return cached value', function () {
      var output = selectorsCacheTest.countries.getThreeCountries(state, "germany", "egypt", "japan");

      var updatedState = _objectSpread2(_objectSpread2({}, state), {}, {
        cities: _objectSpread2(_objectSpread2({}, state.cities), {}, {
          prague: {}
        })
      });

      var secondOutput = selectorsCacheTest.countries.getThreeCountries(updatedState, "germany", "egypt", "japan");
      chai.assert.equal(output, secondOutput);
    });
    it('should return cached value 2', function () {
      var output = selectorsCacheTest.countries.getThreeCountries(state, "germany", "egypt", "japan");

      var updatedState = _objectSpread2(_objectSpread2({}, state), {}, {
        countries: _objectSpread2(_objectSpread2({}, state.countries), {}, {
          america: {}
        })
      });

      var secondOutput = selectorsCacheTest.countries.getThreeCountries(updatedState, "germany", "egypt", "japan");
      chai.assert.equal(output, secondOutput);
    });
    it('should not return cached value', function () {
      var output = selectorsCacheTest.countries.getThreeCountries(state, "germany", "egypt", "japan");

      var updatedState = _objectSpread2(_objectSpread2({}, state), {}, {
        countries: _objectSpread2(_objectSpread2({}, state.countries), {}, {
          europe: _objectSpread2(_objectSpread2({}, state.countries.europe), {}, {
            spain: {}
          })
        })
      });

      var secondOutput = selectorsCacheTest.countries.getThreeCountries(updatedState, "germany", "egypt", "japan");
      chai.assert.notEqual(output, secondOutput);
    });
  });
});

var ActionTypes = ptrUtils.utils.deepKeyMirror({
  INITIALIZE: 'INITIALIZE',
  AOI_ADD: 'AOI_ADD',
  AOI_SET_ACTIVE: 'AOI_SET_ACTIVE',
  AOI_REQUEST: 'AOI_REQUEST',
  AOI_RECEIVE: 'AOI_RECEIVE',
  AOI_REQUEST_ERROR: 'AOI_REQUEST_ERROR',
  AOI_GEOMETRY_RECEIVE: 'AOI_GEOMETRY_RECEIVE',
  AOI_GEOMETRY_REQUEST_ERROR: 'AOI_GEOMETRY_REQUEST_ERROR',
  APP: {
    SET_KEY: null,
    SET_BASE_URL: null,
    SET_LOCAL_CONFIGURATION: null,
    UPDATE_LOCAL_CONFIGURATION: null,
    RECEIVE_CONFIGURATION: null
  },
  AREAS: {
    AREA_TREE_LEVELS: {
      ADD: null,
      ADD_UNRECEIVED: null,
      ENSURE: {
        ERROR: null
      },
      INDEX: {
        ADD: null,
        CLEAR_ALL: null
      },
      LOAD: {
        ERROR: null,
        REQUEST: null
      },
      SET_ACTIVE_KEY: null,
      USE: {
        INDEXED: {
          CLEAR: null,
          REGISTER: null
        },
        KEYS: {
          CLEAR: null,
          REGISTER: null
        }
      }
    },
    AREA_TREES: {
      ADD: null,
      ADD_UNRECEIVED: null,
      ENSURE: {
        ERROR: null
      },
      INDEX: {
        ADD: null,
        CLEAR_ALL: null
      },
      LOAD: {
        ERROR: null,
        REQUEST: null
      },
      SET_ACTIVE_KEY: null,
      USE: {
        INDEXED: {
          CLEAR: null,
          REGISTER: null
        },
        KEYS: {
          CLEAR: null,
          REGISTER: null
        }
      }
    }
  },
  AREA_RELATIONS: {
    ADD: null,
    ADD_UNRECEIVED: null,
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      CLEAR_ALL: null
    },
    USE: {
      INDEXED: {
        CLEAR: null,
        CLEAR_ALL: null,
        REGISTER: null
      }
    }
  },
  AREAS_SELECTIONS_SET_ACTIVE_MULTIPLE: 'AREAS_SELECTIONS_SET_ACTIVE_MULTIPLE',
  AREAS_SELECTIONS_UPDATE: 'AREAS_SELECTIONS_UPDATE',
  ATTRIBUTES: {
    ADD: null,
    ADD_UNRECEIVED: null,
    DELETE: null,
    MARK_DELETED: null,
    EDITED: {
      REMOVE: null,
      REMOVE_PROPERTY: null,
      UPDATE: null
    },
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      ADD_BATCH: null,
      CLEAR_ALL: null,
      CLEAR_INDEX: null
    },
    LOAD: {
      ERROR: null,
      REQUEST: null
    },
    SET_ACTIVE_KEY: null,
    SET_ACTIVE_KEYS: null,
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      },
      INDEXED_BATCH: {
        REGISTER: null
      }
    }
  },
  ATTRIBUTE_SETS: {
    ADD: null,
    ADD_UNRECEIVED: null,
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null
    },
    LOAD: {
      ERROR: null,
      REQUEST: null
    },
    SET_ACTIVE_KEY: null,
    SET_ACTIVE_KEYS: null,
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      }
    }
  },
  CASES: {
    ADD: null,
    ADD_UNRECEIVED: null,
    DELETE: null,
    MARK_DELETED: null,
    EDITED: {
      REMOVE: null,
      REMOVE_PROPERTY: null,
      UPDATE: null
    },
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      CLEAR_ALL: null,
      CLEAR_INDEX: null
    },
    LOAD: {
      ERROR: null,
      REQUEST: null
    },
    SET_ACTIVE_KEY: null,
    SET_ACTIVE_KEYS: null,
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      }
    }
  },
  CHOROPLETHS_SET_ACTIVE_KEYS: 'CHOROPLETHS_SET_ACTIVE_KEYS',
  CHOROPLETHS_UPDATE: 'CHOROPLETHS_UPDATE',
  COMMON: {
    DATA: {
      CLEANUP_ON_LOGOUT: null,
      SET_OUTDATED: null
    },
    EDITED: {
      REMOVE_PROPERTY_VALUES: null
    }
  },
  COMPONENTS: {
    UPDATE: null,
    SET: null
  },
  CHARTS: {
    UPDATE: null,
    SET_INITIAL: null
  },
  DATA: {
    ATTRIBUTE_DATA: {
      ADD: null,
      ADD_WITH_INDEX: null,
      UPDATE: null,
      INDEX: {
        ADD: null,
        REMOVE: null
      }
    },
    ATTRIBUTE_DATA_SOURCES: {
      ADD: null,
      INDEX: {
        ADD: null
      }
    },
    ATTRIBUTE_RELATIONS: {
      ADD: null,
      INDEX: {
        ADD: null
      }
    },
    SPATIAL_DATA: {
      ADD: null,
      ADD_WITH_INDEX: null,
      INDEX: {
        ADD: null,
        REMOVE: null
      }
    },
    SPATIAL_DATA_SOURCES: {
      ADD: null,
      INDEX: {
        ADD: null
      }
    },
    SPATIAL_RELATIONS: {
      ADD: null,
      INDEX: {
        ADD: null
      }
    }
  },
  DATAVIEWS_REMOVE: 'DATAVIEWS_REMOVE',
  DATAVIEWS_DELETE_RECEIVE: 'DATAVIEWS_DELETE_RECEIVE',
  DATAVIEWS_DELETE_REQUEST: 'DATAVIEWS_DELETE_REQUEST',
  DATAVIEWS_DELETE_REQUEST_ERROR: 'DATAVIEWS_DELETE_REQUEST_ERROR',
  DATAVIEWS: {
    ADD: null,
    ADD_UNRECEIVED: null,
    INDEX: {
      ADD: null,
      CLEAR_ALL: null
    },
    SET_ACTIVE_KEY: null,
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      }
    }
  },
  INDICATORS: {
    ADD: null,
    ADD_UNRECEIVED: null,
    DELETE: null,
    MARK_DELETED: null,
    EDITED: {
      REMOVE: null,
      REMOVE_PROPERTY: null,
      UPDATE: null
    },
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      CLEAR_INDEX: null,
      CLEAR_ALL: null
    },
    LOAD: {
      ERROR: null,
      REQUEST: null
    },
    SET_ACTIVE_KEY: null,
    SET_ACTIVE_KEYS: null,
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      }
    }
  },
  LAYER_PERIODS_AOI_LAYER_REQUEST: 'LAYER_PERIODS_AOI_LAYER_REQUEST',
  LAYER_PERIODS_AOI_LAYER_REQUEST_ERROR: 'LAYER_PERIODS_AOI_LAYER_REQUEST_ERROR',
  LAYER_PERIODS_AOI_LAYER_RECEIVE: 'LAYER_PERIODS_AOI_LAYER_RECEIVE',
  LAYER_PERIODS_PLACE_LAYER_REQUEST: 'LAYER_PERIODS_PLACE_LAYER_REQUEST',
  LAYER_PERIODS_PLACE_LAYER_REQUEST_ERROR: 'LAYER_PERIODS_PLACE_LAYER_REQUEST_ERROR',
  LAYER_PERIODS_PLACE_LAYER_RECEIVE: 'LAYER_PERIODS_PLACE_LAYER_RECEIVE',
  LAYER_PERIODS_KEY_LAYER_REQUEST: 'LAYER_PERIODS_KEY_LAYER_REQUEST',
  LAYER_PERIODS_KEY_LAYER_REQUEST_ERROR: 'LAYER_PERIODS_KEY_LAYER_REQUEST_ERROR',
  LAYER_PERIODS_KEY_LAYER_RECEIVE: 'LAYER_PERIODS_KEY_LAYER_RECEIVE',
  LAYER_TEMPLATES: {
    ADD: null,
    ADD_UNRECEIVED: null,
    DELETE: null,
    MARK_DELETED: null,
    EDITED: {
      REMOVE: null,
      REMOVE_PROPERTY: null,
      UPDATE: null
    },
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      CLEAR_INDEX: null,
      CLEAR_ALL: null
    },
    LOAD: {
      ERROR: null,
      REQUEST: null
    },
    SET_ACTIVE_KEY: null,
    SET_ACTIVE_KEYS: null,
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      }
    }
  },
  MAPS_ADD: 'MAPS_ADD',
  MAPS_REMOVE: 'MAPS_REMOVE',
  MAPS_UPDATE: 'MAPS_UPDATE',
  MAPS_UPDATE_DEFAULTS: 'MAPS_UPDATE_DEFAULTS',
  MAPS_SET_ACTIVE: 'MAPS_SET_ACTIVE',
  MAPS_SET_INDEPENDENT_OF_PERIOD: 'MAPS_SET_INDEPENDENT_OF_PERIOD',
  MAPS: {
    SET: {
      SET_ACTIVE_MAP_KEY: null,
      SET_BACKGROUND_LAYER: null,
      VIEW: {
        SET: null,
        UPDATE: null
      }
    },
    MAP: {
      LAYERS: {
        SET_STYLE_KEY: null
      },
      VIEWPORT: {
        SET: null
      },
      VIEW: {
        SET: null,
        UPDATE: null
      }
    },
    UPDATE: null
  },
  _DEPRECATED_MAPS: {
    SET_INITIAL: null,
    SET_ACTIVE_MAP_KEY: null,
    SET_ACTIVE_SET_KEY: null,
    SET_SCOPE: null,
    SET_SCENARIO: null,
    SET_PERIOD: null,
    SET_PLACE: null,
    SET_CASE: null,
    SET_BACKGROUND_LAYER: null,
    SET: {
      ADD: null,
      SET_BACKGROUND_LAYER: null,
      SET_LAYERS: null,
      REMOVE: null,
      ADD_MAP: null,
      SET_MAPS: null,
      REMOVE_MAP: null,
      WORLD_WIND_NAVIGATOR: {
        // TODO deprecated
        SET: null,
        UPDATE: null
      },
      VIEW: {
        SET: null,
        UPDATE: null
      },
      SET_ACTIVE_MAP_KEY: null,
      SET_SYNC: null
    },
    MAP: {
      ADD: null,
      LAYERS: {
        SET: {
          HOVERED_FEATURE_KEYS: null,
          SELECTION: null,
          STYLE: null
        },
        CLEAR: {
          SELECTION: null
        }
      },
      REMOVE: null,
      SET_NAME: null,
      SET_DATA: null,
      WORLD_WIND_NAVIGATOR: {
        // TODO deprecated
        SET: null,
        UPDATE: null
      },
      VIEW: {
        SET: null,
        UPDATE: null
      }
    },
    UPDATE: null,
    // TODO deprecated
    LAYERS: {
      ADD_LAYERS: null,
      REMOVE_LAYERS: null,
      LAYER: {
        ADD: null,
        ADD_TO_SET: null,
        REMOVE: null,
        SET: null,
        UPDATE: null,
        SET_INDEX: null
      },
      SET: null
    }
  },
  PERIODS: {
    ADD: null,
    ADD_UNRECEIVED: null,
    DELETE: null,
    MARK_DELETED: null,
    EDITED: {
      REMOVE: null,
      REMOVE_PROPERTY: null,
      UPDATE: null
    },
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      CLEAR_ALL: null,
      CLEAR_INDEX: null
    },
    LOAD: {
      ERROR: null,
      REQUEST: null
    },
    SET_ACTIVE_KEY: null,
    SET_ACTIVE_KEYS: null,
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      }
    }
  },
  PLACES_ADD: 'PLACES_ADD',
  PLACES_SET_ACTIVE_MULTI: 'PLACES_SET_ACTIVE_MULTI',
  PLACES: {
    ADD: null,
    ADD_UNRECEIVED: null,
    DELETE: null,
    MARK_DELETED: null,
    EDITED: {
      REMOVE: null,
      REMOVE_PROPERTY: null,
      UPDATE: null
    },
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      CLEAR_INDEX: null,
      CLEAR_ALL: null
    },
    LOAD: {
      ERROR: null,
      REQUEST: null
    },
    SET_ACTIVE_KEY: null,
    SET_ACTIVE_KEYS: null,
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      }
    }
  },
  REDIRECT_TO_VIEW: 'REDIRECT_TO_VIEW',
  SCENARIOS: {
    ADD: null,
    ADD_UNRECEIVED: null
  },
  SCENARIOS_ADD: 'SCENARIOS_ADD',
  SCENARIOS_EDITED_UPDATE: 'SCENARIOS_EDITED_UPDATE',
  SCENARIOS_EDITED_REMOVE: 'SCENARIOS_EDITED_REMOVE',
  SCENARIOS_EDITED_REMOVE_PROPERTY: 'SCENARIOS_EDITED_REMOVE_PROPERTY',
  SCENARIOS_SET_ACTIVE: 'SCENARIOS_SET_ACTIVE',
  SCENARIOS_SET_ACTIVE_MULTI: 'SCENARIOS_SET_ACTIVE_MULTI',
  SCENARIOS_SET_DEFAULT_SITUATION_ACTIVE: 'SCENARIOS_SET_DEFAULT_SITUATION_ACTIVE',
  SCENARIOS_CASES_ADD: 'SCENARIOS_CASES_ADD',
  SCENARIOS_CASES_REMOVE: 'SCENARIOS_CASES_REMOVE',
  SCENARIOS_CASES_SET_ACTIVE: 'SCENARIOS_CASES_SET_ACTIVE',
  SCENARIOS_UPDATE: 'SCENARIOS_UPDATE',
  SCENARIOS_REQUEST: 'SCENARIOS_REQUEST',
  SCENARIOS_RECEIVE: 'SCENARIOS_RECEIVE',
  SCENARIOS_REQUEST_ERROR: 'SCENARIOS_REQUEST_ERROR',
  SCENARIOS_CASES_REQUEST: 'SCENARIOS_CASES_REQUEST',
  SCENARIOS_CASES_RECEIVE: 'SCENARIOS_CASES_RECEIVE',
  SCENARIOS_CASES_REQUEST_ERROR: 'SCENARIOS_CASES_REQUEST_ERROR',
  SCENARIOS_CASES_UPDATE: 'SCENARIOS_CASES_UPDATE',
  SCENARIOS_CASES_EDITED_UPDATE: 'SCENARIOS_CASES_EDITED_UPDATE',
  SCENARIOS_CASES_EDITED_REMOVE: 'SCENARIOS_CASES_EDITED_REMOVE',
  SCENARIOS_CASES_EDITED_REMOVE_ACTIVE: 'SCENARIOS_CASES_EDITED_REMOVE_ACTIVE',
  SCENARIOS_CASES_EDITED_REMOVE_PROPERTY: 'SCENARIOS_CASE_EDITED_REMOVE_PROPERTY',
  SCENARIOS_API_PROCESSING_FILE_STARTED: 'SCENARIOS_API_PROCESSING_FILE_STARTED',
  SCENARIOS_API_PROCESSING_FILE_SUCCESS: 'SCENARIOS_API_PROCESSING_FILE_SUCCESS',
  SCENARIOS_API_PROCESSING_FILE_ERROR: 'SCENARIOS_API_PROCESSING_FILE_ERROR',
  SCENARIOS_CASES_API_CREATE_REQUEST: 'SCENARIOS_CASES_API_CREATE_REQUEST',
  SCENARIOS_CASES_API_CREATE_RECEIVE: 'SCENARIOS_CASES_API_CREATE_RECEIVE',
  SCENARIOS_CASES_API_CREATE_ERROR: 'SCENARIOS_CASES_API_CREATE_ERROR',
  SCENARIOS_CASES_API_DELETE_REQUEST: 'SCENARIOS_CASES_API_DELETE_REQUEST',
  SCENARIOS_CASES_API_DELETE_RECEIVE: 'SCENARIOS_CASES_API_DELETE_RECEIVE',
  SCENARIOS_CASES_API_DELETE_ERROR: 'SCENARIOS_CASES_API_DELETE_ERROR',
  SCENARIOS_CASES_API_UPDATE_REQUEST: 'SCENARIOS_CASES_API_UPDATE_REQUEST',
  SCENARIOS_CASES_API_UPDATE_RECEIVE: 'SCENARIOS_CASES_API_UPDATE_RECEIVE',
  SCENARIOS_CASES_API_UPDATE_ERROR: 'SCENARIOS_CASES_API_UPDATE_ERROR',
  SCOPES: {
    ADD: null,
    ADD_UNRECEIVED: null,
    DELETE: null,
    MARK_DELETED: null,
    EDITED: {
      REMOVE: null,
      REMOVE_PROPERTY: null,
      UPDATE: null
    },
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      CLEAR_INDEX: null,
      CLEAR_ALL: null
    },
    LOAD: {
      ERROR: null,
      REQUEST: null
    },
    SET_ACTIVE_KEY: null,
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      }
    }
  },
  SCREENS: {
    ADD: null,
    CLOSE: null,
    OPEN: null,
    REMOVE: null,
    REMOVE_ALL: null,
    RETRACT: null,
    SETS: {
      ADD: null,
      REMOVE: null
    },
    TOP_HISTORY: null,
    UPDATE: null
  },
  SELECTIONS: {
    ADD: null,
    ADD_UNRECEIVED: null,
    SET_ACTIVE_KEY: null,
    SET: {
      FEATURE_KEYS_FILTER: {
        KEYS: null
      }
    },
    CLEAR: {
      FEATURE_KEYS_FILTER: null
    }
  },
  _DEPRECATED_SELECTIONS: {
    ADD: null,
    REMOVE: null,
    SET_ACTIVE_KEY: null,
    UPDATE_FROM_VIEW: null
  },
  SPATIAL_RELATIONS: {
    ADD: null,
    ADD_UNRECEIVED: null,
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      CLEAR_ALL: null
    },
    USE: {
      INDEXED: {
        CLEAR: null,
        CLEAR_ALL: null,
        REGISTER: null
      }
    }
  },
  SPATIAL_DATA: {
    ADD: null,
    ADD_UNRECEIVED: null,
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      CLEAR_INDEX: null,
      CLEAR_ALL: null
    },
    USE: {
      ADD: null,
      ADD_UNRECEIVED: null,
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      }
    }
  },
  SPATIAL_DATA_SOURCES: {
    ADD: null,
    ADD_UNRECEIVED: null,
    ENSURE: {
      ERROR: null
    },
    USE: {
      ADD: null,
      ADD_UNRECEIVED: null,
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      },
      INDEXED_BATCH: {
        REGISTER: null
      }
    },
    VECTOR: {
      ADD: null,
      ADD_BATCH: null,
      ADD_UNRECEIVED: null,
      ENSURE: {
        ERROR: null
      },
      INDEX: {
        ADD: null,
        CLEAR_INDEX: null,
        CLEAR_ALL: null,
        ADD_BATCH: null
      },
      LOAD: {
        ERROR: null,
        REQUEST: null
      },
      USE: {
        INDEXED: {
          CLEAR: null,
          REGISTER: null
        },
        KEYS: {
          CLEAR: null,
          REGISTER: null
        },
        INDEXED_BATCH: {
          REGISTER: null
        }
      }
    }
  },
  ATTRIBUTE_DATA_SOURCES: {
    ADD: null,
    ADD_UNRECEIVED: null,
    ENSURE: {
      ERROR: null
    },
    USE: {
      ADD: null,
      ADD_UNRECEIVED: null,
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      },
      INDEXED_BATCH: {
        REGISTER: null
      }
    }
  },
  ATTRIBUTE_DATA: {
    ADD: null,
    ADD_BATCH: null,
    ADD_UNRECEIVED: null,
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      CLEAR_ALL: null,
      ADD_BATCH: null
    },
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      INDEXED_BATCH: {
        REGISTER: null
      }
    }
  },
  ATTRIBUTE_STATISTICS: {
    ADD: null,
    ADD_BATCH: null,
    ADD_UNRECEIVED: null,
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      CLEAR_ALL: null,
      ADD_BATCH: null
    },
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      INDEXED_BATCH: {
        REGISTER: null
      }
    }
  },
  ATTRIBUTE_RELATIONS: {
    ADD: null,
    ADD_UNRECEIVED: null,
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      CLEAR_ALL: null
    },
    USE: {
      INDEXED: {
        CLEAR: null,
        CLEAR_ALL: null,
        REGISTER: null
      }
    }
  },
  SPATIAL_DATA_SOURCES_DOWNLOAD_FILE_ERROR: 'SPATIAL_DATA_SOURCES_DOWNLOAD_FILE_ERROR',
  SPATIAL_DATA_SOURCES_DOWNLOAD_FILE_REQUEST: 'SPATIAL_DATA_SOURCES_DOWNLOAD_FILE_REQUEST',
  SPATIAL_DATA_SOURCES_RECEIVE: 'SPATIAL_DATA_SOURCES_RECEIVE',
  SPATIAL_DATA_SOURCES_REQUEST: 'SPATIAL_DATA_SOURCES_REQUEST',
  SPATIAL_DATA_SOURCES_FILTERED_REQUEST: 'SPATIAL_DATA_SOURCES_FILTERED_REQUEST',
  SPATIAL_DATA_SOURCES_REQUEST_ERROR: 'SPATIAL_DATA_SOURCES_REQUEST_ERROR',
  SPATIAL_DATA_SOURCES_ADD: 'SPATIAL_DATA_SOURCES_ADD',
  SPATIAL_DATA_SOURCES_VECTOR_FEATURES_RECEIVE: 'SPATIAL_DATA_SOURCES_VECTOR_FEATURES_RECEIVE',
  SPATIAL_DATA_SOURCES_VECTOR_FEATURES_BBOX_REQUEST: 'SPATIAL_DATA_SOURCES_VECTOR_FEATURES_BBOX_REQUEST',
  SPATIAL_DATA_SOURCES_VECTOR_FEATURES_BBOX_REQUEST_ERROR: 'SPATIAL_DATA_SOURCES_VECTOR_FEATURES_BBOX_REQUEST_ERROR',
  SPATIAL_DATA_SOURCES_VECTOR_FEATURES_POINT_REQUEST: 'SPATIAL_DATA_SOURCES_VECTOR_FEATURES_POINT_REQUEST',
  SPATIAL_DATA_SOURCES_VECTOR_FEATURES_POINT_REQUEST_ERROR: 'SPATIAL_DATA_SOURCES_VECTOR_FEATURES_POINT_REQUEST_ERROR',
  SPATIAL_DATA_SOURCES_VECTOR_FEATURES_SELECT: 'SPATIAL_DATA_SOURCES_VECTOR_FEATURES_SELECT',
  SPATIAL_DATA_SOURCES_VECTOR_FEATURES_EDITED_ADD: 'SPATIAL_DATA_SOURCES_VECTOR_FEATURES_EDITED_ADD',
  STYLES: {
    ADD: null,
    ADD_UNRECEIVED: null,
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      CLEAR_ALL: null
    },
    USE: {
      INDEXED: {
        CLEAR: null,
        CLEAR_ALL: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      }
    }
  },
  SNAPSHOTS_ADD: 'SNAPSHOTS_ADD',
  SNAPSHOTS_REMOVE: 'SNAPSHOTS_REMOVE',
  TAGS: {
    ADD: null,
    ADD_UNRECEIVED: null,
    DELETE: null,
    MARK_DELETED: null,
    EDITED: {
      REMOVE: null,
      REMOVE_PROPERTY: null,
      UPDATE: null
    },
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      CLEAR_INDEX: null,
      CLEAR_ALL: null
    },
    LOAD: {
      ERROR: null,
      REQUEST: null
    },
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      }
    }
  },
  THEMES: {
    ADD: null,
    ADD_UNRECEIVED: null,
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      CLEAR_ALL: null
    },
    LOAD: {
      ERROR: null,
      REQUEST: null
    },
    SET_ACTIVE_KEY: null,
    SET_ACTIVE_KEYS: null,
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      }
    }
  },
  USERS: {
    ADD: null,
    ADD_UNRECEIVED: null,
    GROUPS: {
      ADD: null,
      ADD_UNRECEIVED: null,
      INDEX: {
        ADD: null,
        CLEAR_ALL: null
      },
      USE: {
        INDEXED: {
          CLEAR: null,
          REGISTER: null
        },
        KEYS: {
          CLEAR: null,
          REGISTER: null
        }
      }
    },
    SET_ACTIVE_KEY: null,
    CURRENT: {
      REQUEST: null
    },
    LOGIN: {
      REQUEST: null
    },
    INDEX: {
      ADD: null,
      CLEAR_ALL: null
    },
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      }
    }
  },
  //todo which is it? USER_GROUPS or USERS.GROUPS?
  USER_GROUPS: {
    ADD: null,
    ADD_UNRECEIVED: null
  },
  USERS_ADD: 'USERS_ADD',
  USERS_LOAD_REQUEST: 'USERS_LOAD_REQUEST',
  USERS_LOAD_REQUEST_ERROR: 'USERS_LOAD_REQUEST_ERROR',
  USERS_LOAD_CURRENT_REQUEST: 'USERS_LOAD_CURRENT_REQUEST',
  USERS_LOAD_CURRENT_REQUEST_ERROR: 'USERS_LOAD_CURRENT_REQUEST_ERROR',
  USERS_LOGIN_REQUEST: 'USERS_LOGIN_REQUEST',
  USERS_LOGIN_REQUEST_ERROR: 'USERS_LOGIN_REQUEST_ERROR',
  USERS_LOGOUT_REQUEST: 'USERS_LOGOUT_REQUEST',
  USERS_LOGOUT_REQUEST_ERROR: 'USERS_LOGOUT_REQUEST_ERROR',
  USERS_UPDATE: 'USERS_UPDATE',
  LAYER_TREES: {
    ADD: null,
    ADD_UNRECEIVED: null,
    DELETE: null,
    MARK_DELETED: null,
    EDITED: {
      REMOVE: null,
      REMOVE_PROPERTY: null,
      UPDATE: null
    },
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      CLEAR_INDEX: null,
      CLEAR_ALL: null
    },
    LOAD: {
      ERROR: null,
      REQUEST: null
    },
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      }
    }
  },
  VIEWS: {
    ADD: null,
    ADD_UNRECEIVED: null,
    DELETE: null,
    MARK_DELETED: null,
    EDITED: {
      REMOVE: null,
      REMOVE_PROPERTY: null,
      UPDATE: null
    },
    ENSURE: {
      ERROR: null
    },
    INDEX: {
      ADD: null,
      CLEAR_INDEX: null,
      CLEAR_ALL: null
    },
    LOAD: {
      ERROR: null,
      REQUEST: null
    },
    SET_ACTIVE_KEY: null,
    SET_ACTIVE_KEYS: null,
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      }
    }
  },
  VISUALIZATIONS: {
    ADD: null,
    ADD_UNRECEIVED: null,
    INDEX: {
      ADD: null,
      CLEAR_ALL: null
    },
    SET_ACTIVE_KEY: null,
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      }
    }
  },
  WMS_LAYERS: {
    ADD: null,
    ADD_UNRECEIVED: null,
    INDEX: {
      ADD: null,
      CLEAR_ALL: null
    },
    SET_ACTIVE_KEY: null,
    USE: {
      INDEXED: {
        CLEAR: null,
        REGISTER: null
      },
      KEYS: {
        CLEAR: null,
        REGISTER: null
      }
    }
  },
  WINDOWS: {
    ADD: null,
    OPEN: null,
    REMOVE: null,
    SETS: {
      ADD: null,
      REMOVE: null
    },
    TOP: null,
    UPDATE: null
  },
  LPIS_CASES_ADD: 'LPIS_CASES_ADD',
  LPIS_CASE_CHANGES_ADD: 'LPIS_CASE_CHANGES_ADD',
  LPIS_CASES_SEARCH_STRING_CHANGE: 'LPIS_CASES_SEARCH_STRING_CHANGE',
  LPIS_CASES_SELECTED_STATUS_CHANGE: 'LPIS_CASES_SELECTED_STATUS_CHANGE',
  LPIS_CASES_EDIT_ACTIVE_EDITED_CASE: 'LPIS_CASES_EDIT_ACTIVE_EDITED_CASE',
  LPIS_CASES_CREATE_NEW_ACTIVE_EDITED_CASE: 'LPIS_CASES_CREATE_NEW_ACTIVE_EDITED_CASE',
  LPIS_CASES_REMOVE_EDITED_CASES_BY_KEYS: 'LPIS_CASES_REMOVE_EDITED_CASES_BY_KEYS',
  LPIS_CASES_SET_ACTIVE: 'LPIS_CASES_SET_ACTIVE',
  LPIS_CASES_CLEAR_EDITED_CASE: 'LPIS_CASES_CLEAR_EDITED_CASE',
  LPIS_CASE_EDIT_ACTIVE_CASE: 'LPIS_CASE_EDIT_ACTIVE_CASE',
  LPIS_CASE_EDIT_ACTIVE_CASE_STATUS: 'LPIS_CASE_EDIT_ACTIVE_CASE_STATUS',
  LPIS_CASE_EDIT_CASE_STATUS: 'LPIS_CASE_EDIT_CASE_STATUS',
  LPIS_CASE_SET_NEXT_ACTIVE_CASE_KEY: 'LPIS_CASE_SET_NEXT_ACTIVE_CASE_KEY',
  LPISCHECK_CASES_ADD: 'LPISCHECK_CASES_ADD',
  LPISCHECK_UPDATE_CASE: 'LPISCHECK_UPDATE_CASE',
  LPISCHECK_CASES_SET_ACTIVE: 'LPISCHECK_CASES_SET_ACTIVE',
  LPIS_CHECK_CASES_SEARCH_PARAM_CHANGE: 'LPIS_CHECK_CASES_SEARCH_PARAM_CHANGE'
});

var TTL = 5;
/**
 * Fetch implementation used by this module.
 *
 * It can be useful in tests to override this using `setFetch` fn.
 */

var fetch = fetch__default['default'];
/**
 * Set different fetch implementation. Useful in tests.
 */

function setFetch(_fetch) {
  fetch = _fetch;
}
/**
 * Reset fetch implementation to default one.
 */

function resetFetch() {
  fetch = fetch__default['default'];
}
/**
 * Request helper. Creates an request to backend.
 * @param localConfig
 * @param apiPath - path to backend endpoint (hostname taken from config)
 * @param method - HTTP method
 * @param query - url query as object
 * @param payload - payload as object
 * @param ttl - (optional) number of tries
 * @returns response or error
 */

function request(localConfig, apiPath, method, query, payload, ttl) {
  if (_isUndefined__default['default'](ttl)) ttl = TTL;
  var url = localConfig.apiBackendProtocol + '://' + path__default['default'].join(localConfig.apiBackendHost, localConfig.apiBackendPath, apiPath);

  if (query) {
    url += '?' + queryString__default['default'].stringify(query);
  }

  return fetch(url, {
    method: method,
    credentials: 'include',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    },
    body: payload ? JSON.stringify(payload) : null
  }).then(function (response) {
    var contentType = response.headers.get('Content-type');

    if (response.ok && contentType && contentType.indexOf('application/json') !== -1) {
      return response.json().then(function (body) {
        if (body.data) {
          return body;
        } else {
          throw new Error('no data returned');
        }
      });
    } else {
      throw new Error('response error');
    }
  }, function (error) {
    if (ttl - 1) {
      request(localConfig, apiPath, method, query, payload, ttl - 1);
    } else {
      throw error;
    }
  });
}

var DEFAULT_CATEGORY_PATH = 'metadata'; // ============ factories ===========

var apiDelete = function apiDelete(dataType, categoryPath, data) {
  return function (dispatch, getState) {
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    var apiPath = 'backend/rest/' + categoryPath;
    var payload = {
      data: _defineProperty({}, dataType, data)
    };
    return request(localConfig, apiPath, 'DELETE', null, payload).then(function (result) {
      if (result.errors && result.errors[dataType] || result.data && !result.data[dataType]) {
        dispatch(actionGeneralError(result.errors[dataType] || new Error('no data')));
      } else {
        var itemsDeleted = result.data[dataType];

        if (itemsDeleted.length > 0) {
          return result;
        } else {
          console.warn("No data updated for ".concat(dataType, " metadata type"));
        }
      }
    })["catch"](function (error) {
      dispatch(actionGeneralError(error));
    });
  };
};

var apiUpdate = function apiUpdate(getSubstate, dataType, actionTypes, categoryPath, editedData) {
  return function (dispatch, getState) {
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    var apiPath = 'backend/rest/' + categoryPath;
    var payload = {
      data: _defineProperty({}, dataType, editedData)
    };
    return request(localConfig, apiPath, 'PUT', null, payload).then(function (result) {
      if (result.errors && result.errors[dataType] || result.data && !result.data[dataType]) {
        dispatch(actionGeneralError(result.errors[dataType] || new Error('no data')));
      } else {
        dispatch(receiveUpdated(getSubstate, actionTypes, result, dataType, categoryPath));
      }
    })["catch"](function (error) {
      dispatch(actionGeneralError(error));
    });
  };
};

var updateEdited = function updateEdited(getSubstate, actionTypes) {
  return function (modelKey, key, value) {
    return function (dispatch, getState) {
      if (!getSubstate) {
        return dispatch(actionGeneralError('common/actions#updateEdited: setSubstate parameter is missing!'));
      }

      if (!actionTypes) {
        return dispatch(actionGeneralError('common/actions#updateEdited: actionTypes parameter is missing!'));
      }

      if (!modelKey) {
        return dispatch(actionGeneralError('common/actions#updateEdited: Model key is missing!'));
      }

      if (!key) {
        return dispatch(actionGeneralError('common/actions#updateEdited: Property key is missing!'));
      }

      var originalModel = commonSelectors.getByKey(getSubstate)(getState(), modelKey); // delete property from edited, if the value in update is the same as in state
      //TODO - test

      if (originalModel && (value === originalModel.data[key] || _isEqual__default['default'](originalModel.data[key], value))) {
        dispatch(actionRemovePropertyFromEdited(actionTypes, modelKey, key));
      } else {
        dispatch(actionUpdateEdited(actionTypes, [{
          key: modelKey,
          data: _defineProperty({}, key, value)
        }]));
      }
    };
  };
};

var removePropertyFromEdited = function removePropertyFromEdited(actionTypes) {
  return function (modelKey, key) {
    return dispatch(actionRemovePropertyFromEdited(actionTypes, modelKey, key));
  };
};

var deleteItem = function deleteItem(getSubstate, dataType, actionTypes) {
  var categoryPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_CATEGORY_PATH;
  return function (item) {
    return function (dispatch, getState) {
      if (!item) {
        return dispatch(actionGeneralError('common/actions#deleteItem: item to delete is missing!'));
      }

      if (!item.key) {
        return dispatch(actionGeneralError('common/actions#deleteItem: item key to delete is missing!'));
      } //dispatch deleting?
      //TODO


      return dispatch(apiDelete(dataType, categoryPath, [{
        key: item.key
      }])).then(function (result) {
        var data = result.data[dataType];
        var deletedKeys = data.map(function (d) {
          return d.key;
        }); //Check if item deleted

        if (_isEqual__default['default'](deletedKeys, [item.key])) {
          // mark deleted items by "deleted" date
          var deleteDate = moment__default['default'](new Date().toISOString()).utc().format();
          deletedKeys.forEach(function (key) {
            dispatch(actionMarkAsDeleted(actionTypes, key, deleteDate));
          }); // remove dependencies in all edited metadata

          dispatch(actionRemovePropertyValuesFromAllEdited(dataType, deletedKeys)); // TODO check original metadata dependencies
          //refresh proper indexes

          var state = getState();
          var indexes = commonSelectors.getIndexesByFilteredItem(getSubstate)(state, item) || [];

          if (!_isEmpty__default['default'](indexes)) {
            indexes.forEach(function (index) {
              if (index) {
                //invalidate data
                dispatch(actionClearIndex(actionTypes, index.filter, index.order)); //refresh data

                dispatch(refreshIndex$1(getSubstate, dataType, index.filter, index.order, actionTypes, categoryPath));
              }
            });
          }
        } else {
          //error
          return dispatch(actionGeneralError('common/actions#deleteItem: Deleted key is not equal to key to delete!'));
        }
      });
    };
  };
};

var saveEdited = function saveEdited(getSubstate, dataType, actionTypes) {
  var categoryPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_CATEGORY_PATH;
  return function (key) {
    return function (dispatch, getState) {
      if (!getSubstate) {
        return dispatch(actionGeneralError('common/actions#saveEdited: setSubstate parameter is missing!'));
      }

      if (!dataType) {
        return dispatch(actionGeneralError('common/actions#saveEdited: dataType parameter is missing!'));
      }

      if (!actionTypes) {
        return dispatch(actionGeneralError('common/actions#saveEdited: actionTypes parameter is missing!'));
      }

      if (!key) {
        return dispatch(actionGeneralError('common/actions#saveEdited: Model key is missing!'));
      }

      var state = getState();
      var saved = commonSelectors.getByKey(getSubstate)(state, key);
      var edited = commonSelectors.getEditedByKey(getSubstate)(state, key);

      if (saved) {
        // update
        return dispatch(apiUpdate(getSubstate, dataType, actionTypes, categoryPath, [edited]));
      } else {
        // create
        debugger;
      }
    };
  };
};

var useKeys = function useKeys(getSubstate, dataType, actionTypes) {
  var categoryPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_CATEGORY_PATH;
  return function (keys, componentId) {
    return function (dispatch) {
      dispatch(actionUseKeysRegister(actionTypes, componentId, keys));
      return dispatch(ensureKeys(getSubstate, dataType, actionTypes, keys, categoryPath));
    };
  };
};

var useIndexed = function useIndexed(getSubstate, dataType, actionTypes) {
  var categoryPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_CATEGORY_PATH;
  return function (filterByActive, filter, order, start, length, componentId) {
    return function (dispatch, getState) {
      dispatch(actionUseIndexedRegister(actionTypes, componentId, filterByActive, filter, order, start, length));
      var state = getState();
      var fullFilter = commonHelpers.mergeFilters({
        activeApplicationKey: state.app.key,
        activeAttributeKey: commonSelectors.getActiveKey(function (state) {
          return state.attributes;
        })(state),
        activeScopeKey: commonSelectors.getActiveKey(function (state) {
          return state.scopes;
        })(state),
        activePeriodKey: commonSelectors.getActiveKey(function (state) {
          return state.periods;
        })(state),
        activePeriodKeys: commonSelectors.getActiveKeys(function (state) {
          return state.periods;
        })(state),
        activePlaceKey: commonSelectors.getActiveKey(function (state) {
          return state.places;
        })(state),
        activePlaceKeys: commonSelectors.getActiveKeys(function (state) {
          return state.places;
        })(state)
      }, filterByActive, filter);
      return dispatch(ensureIndexed(getSubstate, dataType, fullFilter, order, start, length, actionTypes, categoryPath));
    };
  };
};

var useIndexedBatch = function useIndexedBatch(dataType, actionTypes) {
  var categoryPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_CATEGORY_PATH;
  return function (filterByActive, filter, order, componentId, key, additionalParams) {
    return function (dispatch, getState) {
      dispatch(actionUseIndexedBatchRegister(actionTypes, componentId, filterByActive, filter, order));
      var state = getState();
      var fullFilter = commonHelpers.mergeFilters({
        activeApplicationKey: state.app.key,
        activeScopeKey: commonSelectors.getActiveKey(function (state) {
          return state.scopes;
        })(state),
        activePeriodKey: commonSelectors.getActiveKey(function (state) {
          return state.periods;
        })(state),
        activePeriodKeys: commonSelectors.getActiveKeys(function (state) {
          return state.periods;
        })(state),
        activePlaceKey: commonSelectors.getActiveKey(function (state) {
          return state.places;
        })(state),
        activePlaceKeys: commonSelectors.getActiveKeys(function (state) {
          return state.places;
        })(state)
      }, filterByActive, filter);
      return dispatch(ensureIndexedBatch(dataType, fullFilter, order, actionTypes, categoryPath, key, additionalParams));
    };
  };
};

var setActiveKeyAndEnsureDependencies = function setActiveKeyAndEnsureDependencies(actionTypes, filterKey) {
  return function (key) {
    return function (dispatch) {
      dispatch(actionSetActiveKey(actionTypes, key));
      dispatch(ensureIndexesWithActiveKey(filterKey));
    };
  };
};

var setActiveKeysAndEnsureDependencies = function setActiveKeysAndEnsureDependencies(actionTypes, filterKey) {
  return function (keys) {
    return function (dispatch) {
      dispatch(actionSetActiveKeys(actionTypes, keys));
      dispatch(ensureIndexesWithActiveKey(filterKey));
    };
  };
};
/**
 * If not refresh data, call clearIndex to invalidate data.
 */


function refreshIndex$1(getSubstate, dataType, filter, order, actionTypes) {
  var categoryPath = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : DEFAULT_CATEGORY_PATH;
  return function (dispatch, getState) {
    var state = getState();
    var usesForIndex = commonSelectors.getUsesForIndex(getSubstate)(state, filter, order);

    if (usesForIndex) {
      _each__default['default'](usesForIndex.uses, function (use) {
        dispatch(ensureIndexed(getSubstate, dataType, usesForIndex.filter, usesForIndex.order, use.start, use.length, actionTypes, categoryPath));
      });
    }
  };
}

function receiveIndexed(actionTypes, result, dataType, filter, order, start) {
  return function (dispatch) {
    // add data to store
    if (result.data[dataType].length) {
      dispatch(actionAdd(actionTypes, result.data[dataType], filter));
    } // add to index


    dispatch(actionAddIndex(actionTypes, filter, order, result.total, start, result.data[dataType], result.changes && result.changes[dataType]));
  };
}

function receiveIndexedBatch(actionTypes, result, dataType, filter, order, key) {
  return function (dispatch) {
    // add data to store
    if (result.data[dataType].length) {
      dispatch(actionAddBatch(actionTypes, result.data[dataType], key));
    } // add to index


    dispatch(actionAddBatchIndex(actionTypes, filter, order, result.data[dataType], key));
  };
}

function requestWrapper(apiPath, method, query, payload, successAction, errorAction) {
  return function (dispatch, getState) {
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    request(localConfig, apiPath, method, query, payload).then(function (result) {
      dispatch(successAction(result.data));
    })["catch"](function (error) {
      dispatch(errorAction(error));
    });
  };
}

function create(getSubstate, dataType, actionTypes) {
  var categoryPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_CATEGORY_PATH;
  return function (key, appKey) {
    return function (dispatch, getState) {
      var state = getState();
      var apiPath = path__default['default'].join('backend/rest', categoryPath);
      var localConfig = Select.app.getCompleteLocalConfiguration(state);
      var applicationKey = null;

      if (appKey) {
        applicationKey = appKey;
      } else {
        var currentAppKey = Select.app.getKey(state);

        if (currentAppKey) {
          applicationKey = currentAppKey;
        }
      }

      var payload = getCreatePayload(dataType, key, applicationKey);
      return request(localConfig, apiPath, 'POST', null, payload).then(function (result) {
        if (result.errors && result.errors[dataType] || result.data && !result.data[dataType]) {
          dispatch(actionGeneralError(result.errors[dataType] || new Error('no data')));
        } else {
          var items = result.data[dataType];
          dispatch(actionAdd(actionTypes, items));
          var indexes = [];
          items.forEach(function (item) {
            indexes = indexes.concat(commonSelectors.getIndexesByFilteredItem(getSubstate)(getState(), item)) || [];
          });
          var uniqueIndexes = commonHelpers.getUniqueIndexes(indexes);

          if (!_isEmpty__default['default'](uniqueIndexes)) {
            uniqueIndexes.forEach(function (index) {
              if (index) {
                //invalidate data
                dispatch(actionClearIndex(actionTypes, index.filter, index.order)); //refresh data

                dispatch(refreshIndex$1(getSubstate, dataType, index.filter, index.order, actionTypes, categoryPath));
              }
            });
          }
        }
      })["catch"](function (error) {
        dispatch(actionGeneralError(error));
      });
    };
  };
}

function loadAll(dataType, actionTypes) {
  var categoryPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_CATEGORY_PATH;
  return function (dispatch, getState) {
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    var PAGE_SIZE = localConfig.requestPageSize || ptrCore.configDefaults.requestPageSize;
    var apiPath = getAPIPath(categoryPath, dataType);
    var payload = {
      limit: PAGE_SIZE
    };
    return request(localConfig, apiPath, 'POST', null, payload).then(function (result) {
      if (result.errors && result.errors[dataType] || result.data && !result.data[dataType]) {
        dispatch(actionGeneralError(result.errors[dataType] || new Error('no data')));
      } else {
        if (result.total <= PAGE_SIZE) {
          // everything already loaded
          dispatch(actionAdd(actionTypes, result.data[dataType]));
        } else {
          // load remaining pages
          var promises = [];
          var remainingPageCount = Math.ceil((result.total - PAGE_SIZE) / PAGE_SIZE);

          for (var i = 0; i < remainingPageCount; i++) {
            var pagePayload = {
              offset: (i + 1) * PAGE_SIZE,
              limit: PAGE_SIZE
            };
            promises.push(request(localConfig, apiPath, 'POST', null, pagePayload)); //todo what if one fails?
          }

          Promise.all(promises).then(function (results) {
            var remainingData = _flatten__default['default'](results.map(function (res) {
              return res.data[dataType];
            }));

            dispatch(actionAdd(actionTypes, [].concat(_toConsumableArray(result.data[dataType]), _toConsumableArray(remainingData))));
          });
        }
      }
    })["catch"](function (error) {
      dispatch(actionGeneralError(error));
    });
  };
}

function ensureKeys(getSubstate, dataType, actionTypes, keys) {
  var categoryPath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_CATEGORY_PATH;
  return function (dispatch, getState) {
    var state = getState();
    var PAGE_SIZE = Select.app.getLocalConfiguration(state, 'requestPageSize') || ptrCore.configDefaults.requestPageSize;
    var keysToLoad = commonSelectors.getKeysToLoad(getSubstate)(state, keys);
    var promises = [];

    if (keysToLoad) {
      keysToLoad = _chunk__default['default'](keysToLoad, PAGE_SIZE);

      _each__default['default'](keysToLoad, function (keysToLoadPage) {
        promises.push(dispatch(loadKeysPage(dataType, actionTypes, keysToLoadPage, categoryPath)));
      });
    }

    return Promise.all(promises);
  };
}

function ensureIndexed(getSubstate, dataType, filter, order, start, length, actionTypes) {
  var categoryPath = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : DEFAULT_CATEGORY_PATH;
  return function (dispatch, getState) {
    var state = getState();
    var localConfig = Select.app.getCompleteLocalConfiguration(state);
    var PAGE_SIZE = localConfig.requestPageSize || ptrCore.configDefaults.requestPageSize;
    var total = commonSelectors.getIndexTotal(getSubstate)(state, filter, order);
    var changedOn = commonSelectors.getIndexChangedOn(getSubstate)(state, filter, order);

    if (total != null) {
      // we have existing index, we only load what we don't have
      var indexPage = commonSelectors.getIndexPage(getSubstate)(state, filter, order, start, length) || {};

      var pages = _chunk__default['default'](Object.values(indexPage), PAGE_SIZE);

      var promises = pages.map(function (page, i) {
        var loadedKeys = page.filter(function (v) {
          return v != null;
        });

        if (loadedKeys.length === page.length) {
          return; // page is already loaded
        }

        var completeFilter = loadedKeys.length ? _objectSpread2(_objectSpread2({}, filter), {}, {
          key: {
            notin: loadedKeys
          }
        }) : filter;
        return dispatch(loadIndexedPage(dataType, completeFilter, order, start + i * PAGE_SIZE, changedOn, actionTypes, categoryPath))["catch"](function (err) {
          if (err.message === 'Index outdated') {
            dispatch(refreshIndex$1(getSubstate, dataType, filter, order, actionTypes, categoryPath));
          }
        });
      });
      return Promise.all(promises);
    } else {
      // we don't have index, we need to load everything
      return dispatch(loadIndexedPage(dataType, filter, order, start, changedOn, actionTypes, categoryPath)).then(function (response) {
        // check success to make sure it's our error from BE and not anything broken in render chain
        if (response && response.message && response.success === false) ; else {
          // remaining pages
          if (length > PAGE_SIZE) {
            return dispatch(ensureIndexed(getSubstate, dataType, filter, order, start + PAGE_SIZE, length - PAGE_SIZE, actionTypes, categoryPath));
          } // else already done

        }
      })["catch"](function (err) {
        if (err.message === 'Index outdated') {
          dispatch(refreshIndex$1(getSubstate, dataType, filter, order, actionTypes, categoryPath));
        } else {
          throw new Error("_common/actions#ensure: ".concat(err));
        }
      });
    }
  };
}

function ensureIndexedBatch(dataType, filter, order, actionTypes) {
  var categoryPath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_CATEGORY_PATH;
  var key = arguments.length > 5 ? arguments[5] : undefined;
  var additionalParams = arguments.length > 6 ? arguments[6] : undefined;
  return function (dispatch) {
    return dispatch(loadIndexedBatch(dataType, filter, order, actionTypes, categoryPath, key, additionalParams)).then(function (response) {//success
    })["catch"](function (err) {
      throw new Error("_common/actions#ensure: ".concat(err));
    });
  };
}

function loadKeysPage(dataType, actionTypes, keys) {
  var categoryPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_CATEGORY_PATH;
  return function (dispatch, getState) {
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    var apiPath = getAPIPath(categoryPath, dataType);
    var payload = {
      filter: {
        key: {
          "in": keys
        }
      }
    };
    return request(localConfig, apiPath, 'POST', null, payload).then(function (result) {
      if (result.errors && result.errors[dataType] || result.data && !result.data[dataType]) {
        throw new Error(result.errors[dataType] || 'no data');
      } else {
        dispatch(receiveKeys(actionTypes, result, dataType, keys));
      }
    })["catch"](function (error) {
      dispatch(actionGeneralError(error));
      return error;
    });
  };
}

function loadIndexedPage(dataType, filter, order, start, changedOn, actionTypes) {
  var categoryPath = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : DEFAULT_CATEGORY_PATH;
  return function (dispatch, getState) {
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    var PAGE_SIZE = localConfig.requestPageSize || ptrCore.configDefaults.requestPageSize;
    var apiPath = getAPIPath(categoryPath, dataType);
    var payload = {
      filter: filter && _objectSpread2({}, filter),
      offset: start - 1,
      order: order,
      limit: PAGE_SIZE
    };
    return request(localConfig, apiPath, 'POST', null, payload).then(function (result) {
      if (result.errors && result.errors[dataType] || result.data && !result.data[dataType]) {
        throw new Error(result.errors[dataType] || 'no data');
      } else if (result.changes && result.changes[dataType] && moment__default['default'](result.changes[dataType]).isAfter(changedOn)) {
        throw new Error('Index outdated');
      } else {
        dispatch(receiveIndexed(actionTypes, result, dataType, filter, order, start));
      }
    })["catch"](function (error) {
      dispatch(actionGeneralError(error));
      return error; //todo do we need to return this
    });
  };
}

function loadIndexedBatch(dataType, filter, order, actionTypes) {
  var categoryPath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_CATEGORY_PATH;
  var key = arguments.length > 5 ? arguments[5] : undefined;
  var additionalParams = arguments.length > 6 ? arguments[6] : undefined;
  return function (dispatch, getState) {
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    var apiPath = getAPIPath(categoryPath, dataType);
    var payload = {
      filter: _objectSpread2({}, filter),
      order: order
    };

    if (additionalParams) {
      payload = _objectSpread2(_objectSpread2({}, payload), additionalParams);
    }

    return request(localConfig, apiPath, 'POST', null, payload).then(function (result) {
      if (result.errors && result.errors[dataType] || result.data && !result.data[dataType]) {
        throw new Error(result.errors[dataType] || 'no data');
      } else {
        dispatch(receiveIndexedBatch(actionTypes, result, dataType, filter, order, key));
      }
    })["catch"](function (error) {
      dispatch(actionGeneralError(error));
      return error;
    });
  };
}

function loadFiltered(dataType, actionTypes, filter) {
  var categoryPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_CATEGORY_PATH;
  return function (dispatch, getState) {
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    var PAGE_SIZE = localConfig.requestPageSize || ptrCore.configDefaults.requestPageSize;
    var apiPath = getAPIPath(categoryPath, dataType);
    var payload = {
      filter: filter,
      limit: PAGE_SIZE
    };
    return request(localConfig, apiPath, 'POST', null, payload).then(function (result) {
      if (result.errors && result.errors[dataType] || result.data && !result.data[dataType]) {
        dispatch(actionGeneralError(result.errors[dataType] || new Error('no data')));
      } else {
        if (result.total <= PAGE_SIZE) {
          // everything already loaded
          return dispatch(actionAdd(actionTypes, result.data[dataType]));
        } else {
          // load remaining pages
          var promises = [];
          var remainingPageCount = Math.ceil((result.total - PAGE_SIZE) / PAGE_SIZE);

          for (var i = 0; i < remainingPageCount; i++) {
            var pagePayload = {
              filter: filter,
              offset: (i + 1) * PAGE_SIZE,
              limit: PAGE_SIZE
            };
            promises.push(request(localConfig, apiPath, 'POST', null, pagePayload)); //todo what if one fails?
          }

          return Promise.all(promises).then(function (results) {
            var remainingData = _flatten__default['default'](results.map(function (res) {
              return res.data[dataType];
            }));

            dispatch(actionAdd(actionTypes, [].concat(_toConsumableArray(result.data[dataType]), _toConsumableArray(remainingData))));
          });
        }
      }
    })["catch"](function (error) {
      dispatch(actionGeneralError(error));
    });
  };
}

function receiveUpdated(getSubstate, actionTypes, result, dataType, categoryPath) {
  return function (dispatch, getState) {
    var data = result.data[dataType];

    if (data.length) {
      var originalData = commonSelectors.getAllAsObject(getSubstate)(getState());
      dispatch(actionAdd(actionTypes, data));
      var editedData = commonSelectors.getEditedAllAsObject(getSubstate)(getState());
      var indexes = [];
      data.forEach(function (model) {
        var original = originalData[model.key];
        var edited = editedData[model.key].data;

        _forIn__default['default'](edited, function (value, key) {
          if (model.data[key] === value) {
            dispatch(actionRemovePropertyFromEdited(actionTypes, model.key, key));
          } else if (_isObject__default['default'](value)) {
            if (JSON.stringify(value) === JSON.stringify(model.data[key])) {
              dispatch(actionRemovePropertyFromEdited(actionTypes, model.key, key));
            } else if (_isArray__default['default'](value) && _isEmpty__default['default'](value)) {
              if (_isEmpty__default['default'](model.data[key]) || model.data && !model.data[key]) {
                dispatch(actionRemovePropertyFromEdited(actionTypes, model.key, key));
              }
            }
          }
        });

        indexes = indexes.concat(commonSelectors.getIndexesByFilteredItem(getSubstate)(getState() || [], model));
        indexes = indexes.concat(commonSelectors.getIndexesByFilteredItem(getSubstate)(getState() || [], original));
      });
      var uniqueIndexes = commonHelpers.getUniqueIndexes(indexes);

      if (!_isEmpty__default['default'](uniqueIndexes)) {
        uniqueIndexes.forEach(function (index) {
          if (index) {
            //invalidate data
            dispatch(actionClearIndex(actionTypes, index.filter, index.order)); //refresh data

            dispatch(refreshIndex$1(getSubstate, dataType, index.filter, index.order, actionTypes, categoryPath));
          }
        });
      }
    } else {
      console.warn("No data updated for ".concat(dataType, " metadata type"));
    }
  };
}

function receiveKeys(actionTypes, result, dataType, keys) {
  return function (dispatch) {
    // add data to store
    if (result.data[dataType].length) {
      dispatch(actionAdd(actionTypes, result.data[dataType]));
    } // add unreceived keys


    _remove__default['default'](keys, function (key) {
      return _find__default['default'](result.data[dataType], {
        key: key
      });
    });

    if (keys.length) {
      dispatch(actionAddUnreceivedKeys(actionTypes, keys));
    }
  };
}

function refreshUses(getSubstate, dataType, actionTypes) {
  var categoryPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_CATEGORY_PATH;
  return function () {
    return function (dispatch, getState) {
      dispatch(actionClearIndexes(actionTypes));
      var state = getState();
      var usedKeys = commonSelectors.getUsedKeys(getSubstate)(state);
      dispatch(ensureKeys(getSubstate, dataType, actionTypes, usedKeys, categoryPath));
      var usedIndexPages = commonSelectors.getUsedIndexPages(getSubstate)(state);

      var promises = _flatMap__default['default'](usedIndexPages, function (usedIndexPage) {
        _map__default['default'](usedIndexPage.uses, function (use) {
          return dispatch(ensureIndexed(getSubstate, dataType, usedIndexPage.filter, usedIndexPage.order, use.start, use.length, actionTypes, categoryPath));
        });
      });

      return Promise.all(promises);
    };
  };
}

function ensureIndexesWithFilterByActive(getSubstate, dataType, actionTypes) {
  var categoryPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_CATEGORY_PATH;
  return function (filterByActive) {
    return function (dispatch, getState) {
      var state = getState();
      var usedIndexes = commonSelectors.getUsesWithActiveDependency(getSubstate)(state, filterByActive);

      var promises = _flatMap__default['default'](usedIndexes, function (usedIndex) {
        _map__default['default'](usedIndex.uses, function (use) {
          return dispatch(ensureIndexed(getSubstate, dataType, usedIndex.filter, usedIndex.order, use.start, use.length, actionTypes, categoryPath));
        });
      });

      return Promise.all(promises);
    };
  };
}

function ensureIndexesWithActiveKey(filterKey) {
  var categoryPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_CATEGORY_PATH;
  return function (dispatch) {
    var filterByActive = _defineProperty({}, filterKey, true); // dispatch ensureIndexesWithFilterByActive on all stores implementing it


    _map__default['default'](Action, function (actions) {
      if (actions.hasOwnProperty('ensureIndexesWithFilterByActive')) {
        dispatch(actions.ensureIndexesWithFilterByActive(filterByActive, categoryPath));
      }
    });
  };
}

function updateSubstateFromView(actionTypes) {
  return function (data) {
    return function (dispatch) {
      if (data && data.activeKey) {
        dispatch(actionSetActiveKey(actionTypes, data.activeKey));
      } else if (data && data.activeKeys) {
        dispatch(actionSetActiveKeys(actionTypes, data.activeKeys));
      }
    };
  };
} // ============ common namespace actions ===========


function actionDataSetOutdated() {
  return {
    type: ActionTypes.COMMON.DATA.SET_OUTDATED
  };
}

function actionRemovePropertyValuesFromAllEdited(dataType, keys) {
  return {
    type: ActionTypes.COMMON.EDITED.REMOVE_PROPERTY_VALUES,
    dataType: dataType,
    keys: keys
  };
}

function actionGeneralError(e) {
  console.error('common/actions error', e);
  return {
    type: 'ERROR'
  };
} // ============ specific store namespace actions ===========


var creator = function creator(action) {
  return function (actionTypes) {
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return function (dispatch) {
        dispatch(action.apply(void 0, [actionTypes].concat(args)));
      };
    };
  };
};

function action(actionTypes, type, payload) {
  type = type.split('.');

  _each__default['default'](type, function (pathSegment) {
    if (!actionTypes.hasOwnProperty(pathSegment)) {
      console.error('common/actions#action: Action not in namespace', type, payload);
      throw new Error('common/actions#action: Action not in namespace');
    }

    actionTypes = actionTypes[pathSegment];
  });

  if (typeof actionTypes !== 'string') throw new Error('common/actions#action: Action type not string');
  return _objectSpread2(_objectSpread2({}, payload), {}, {
    type: actionTypes
  });
}

function actionAdd(actionTypes, data, filter) {
  if (!_isArray__default['default'](data)) data = [data];
  return action(actionTypes, 'ADD', {
    data: data,
    filter: filter
  });
}

function actionAddBatch(actionTypes, data, key) {
  if (!_isArray__default['default'](data)) data = [data];
  var payload = {
    data: data,
    key: key //FIXME - key should be union of filter and key?

  };
  return action(actionTypes, 'ADD_BATCH', payload);
}

function actionAddUnreceivedKeys(actionTypes, keys) {
  if (!_isArray__default['default'](keys)) keys = [keys];
  return action(actionTypes, 'ADD_UNRECEIVED', {
    keys: keys
  });
}

function actionAddIndex(actionTypes, filter, order, count, start, data, changedOn) {
  return action(actionTypes, 'INDEX.ADD', {
    filter: filter,
    order: order,
    count: count,
    start: start,
    data: data,
    changedOn: changedOn
  });
}

function actionAddBatchIndex(actionTypes, filter, order, data, key) {
  return action(actionTypes, 'INDEX.ADD_BATCH', {
    filter: filter,
    order: order,
    data: data,
    key: key
  });
}
/**
 * Useful for invalidate data before refresh indexes
 */


function actionClearIndex(actionTypes, filter, order) {
  return action(actionTypes, 'INDEX.CLEAR_INDEX', {
    filter: filter,
    order: order
  });
}

var actionMarkAsDeleted = function actionMarkAsDeleted(actionTypes, key, date) {
  return action(actionTypes, 'MARK_DELETED', {
    key: key,
    date: date
  });
};

function actionClearIndexes(actionTypes) {
  return action(actionTypes, 'INDEX.CLEAR_ALL');
}

function actionSetActiveKey(actionTypes, key) {
  return action(actionTypes, 'SET_ACTIVE_KEY', {
    key: key
  });
}

function actionSetActiveKeys(actionTypes, keys) {
  return action(actionTypes, 'SET_ACTIVE_KEYS', {
    keys: keys
  });
}

function actionUpdateEdited(actionTypes, data) {
  return action(actionTypes, 'EDITED.UPDATE', {
    data: data
  });
}

function actionRemovePropertyFromEdited(actionTypes, key, property) {
  return action(actionTypes, 'EDITED.REMOVE_PROPERTY', {
    key: key,
    property: property
  });
}

function actionUseIndexedRegister(actionTypes, componentId, filterByActive, filter, order, start, length) {
  return action(actionTypes, 'USE.INDEXED.REGISTER', {
    componentId: componentId,
    filterByActive: filterByActive,
    filter: filter,
    order: order,
    start: start,
    length: length
  });
}

function actionUseIndexedBatchRegister(actionTypes, componentId, filterByActive, filter, order) {
  return action(actionTypes, 'USE.INDEXED_BATCH.REGISTER', {
    componentId: componentId,
    filterByActive: filterByActive,
    filter: filter,
    order: order
  });
}

function actionUseIndexedClear(actionTypes, componentId) {
  return action(actionTypes, 'USE.INDEXED.CLEAR', {
    componentId: componentId
  });
}

function actionUseIndexedClearAll(actionTypes) {
  return action(actionTypes, 'USE.INDEXED.CLEAR_ALL');
}

function actionSetInitial(actionTypes) {
  return action(actionTypes, 'SET_INITIAL');
}

function actionUseKeysClear(actionTypes, componentId) {
  return action(actionTypes, 'USE.KEYS.CLEAR', {
    componentId: componentId
  });
}

function actionUseKeysRegister(actionTypes, componentId, keys) {
  return action(actionTypes, 'USE.KEYS.REGISTER', {
    componentId: componentId,
    keys: keys
  });
} // ============ utilities ===========


var getAPIPath = function getAPIPath() {
  var categoryPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_CATEGORY_PATH;
  var dataType = arguments.length > 1 ? arguments[1] : undefined;
  return path__default['default'].join('backend/rest', categoryPath, 'filtered', dataType);
};

var getCreatePayload = function getCreatePayload(datatype) {
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ptrUtils.utils.uuid();
  var applicationKey = arguments.length > 2 ? arguments[2] : undefined;
  var payload = {
    "data": {}
  };
  var model = {
    key: key,
    data: {}
  };

  if (applicationKey) {
    model.data = {
      applicationKey: applicationKey
    };
  }

  payload.data[datatype] = [model];
  return payload;
}; // ============ export ===========


var actions = {
  add: creator(actionAdd),
  addBatch: creator(actionAddBatch),
  addBatchIndex: creator(actionAddBatchIndex),
  action: action,
  addIndex: creator(actionAddIndex),
  actionGeneralError: actionGeneralError,
  apiUpdate: apiUpdate,
  creator: creator,
  create: create,
  "delete": deleteItem,
  ensure: ensureKeys,
  ensureIndexed: ensureIndexed,
  ensureIndexesWithFilterByActive: ensureIndexesWithFilterByActive,
  ensureKeys: ensureKeys,
  loadAll: loadAll,
  loadFiltered: loadFiltered,
  useIndexedBatch: useIndexedBatch,
  loadIndexedPage: loadIndexedPage,
  loadKeysPage: loadKeysPage,
  setActiveKey: creator(actionSetActiveKey),
  setActiveKeyAndEnsureDependencies: setActiveKeyAndEnsureDependencies,
  setActiveKeysAndEnsureDependencies: setActiveKeysAndEnsureDependencies,
  setActiveKeys: creator(actionSetActiveKeys),
  receiveUpdated: receiveUpdated,
  receiveIndexed: receiveIndexed,
  receiveKeys: receiveKeys,
  refreshUses: refreshUses,
  removePropertyFromEdited: removePropertyFromEdited,
  request: requestWrapper,
  saveEdited: saveEdited,
  updateSubstateFromView: updateSubstateFromView,
  updateEdited: updateEdited,
  useKeys: useKeys,
  useKeysClear: creator(actionUseKeysClear),
  useIndexed: useIndexed,
  clearIndex: creator(actionClearIndex),
  useIndexedRegister: actionUseIndexedRegister,
  useIndexedClear: creator(actionUseIndexedClear),
  useIndexedClearAll: creator(actionUseIndexedClearAll),
  setInitial: creator(actionSetInitial),
  actionDataSetOutdated: actionDataSetOutdated,
  actionSetActiveKey: actionSetActiveKey
}; // useIndexedBatch
// ensureIndexedBatch
// actionUseIndexedBatchRegister
// loadIndexedBatch
// receiveIndexedBatch
//actionAddBatchIndex
//reducer
// - USE.INDEXED_BATCH.REGISTER
// - INDEX.ADD_BATCH
// - ADD_BATCH

var add = actions.add(ActionTypes.LAYER_TEMPLATES);
var create$1 = actions.create(Select.layerTemplates.getSubstate, 'layerTemplates', ActionTypes.LAYER_TEMPLATES);
var deleteItem$1 = actions["delete"](Select.layerTemplates.getSubstate, 'layerTemplates', ActionTypes.LAYER_TEMPLATES);
var saveEdited$1 = actions.saveEdited(Select.layerTemplates.getSubstate, 'layerTemplates', ActionTypes.LAYER_TEMPLATES);
var updateEdited$1 = actions.updateEdited(Select.layerTemplates.getSubstate, ActionTypes.LAYER_TEMPLATES);
var useKeys$1 = actions.useKeys(Select.layerTemplates.getSubstate, 'layerTemplates', ActionTypes.LAYER_TEMPLATES);
var useKeysClear = actions.useKeysClear(ActionTypes.LAYER_TEMPLATES);
var useIndexed$1 = actions.useIndexed(Select.layerTemplates.getSubstate, 'layerTemplates', ActionTypes.LAYER_TEMPLATES);
var useIndexedClear = actions.useIndexedClear(ActionTypes.LAYER_TEMPLATES);
var clearIndex = actions.clearIndex(ActionTypes.LAYER_TEMPLATES);
var ensureIndexesWithFilterByActive$1 = actions.ensureIndexesWithFilterByActive(Select.layerTemplates.getSubstate, 'layerTemplates', ActionTypes.LAYER_TEMPLATES); // ============ export ===========

var LayerTemplatesAction = {
  add: add,
  clearIndex: clearIndex,
  create: create$1,
  "delete": deleteItem$1,
  ensureIndexesWithFilterByActive: ensureIndexesWithFilterByActive$1,
  saveEdited: saveEdited$1,
  setActiveKey: actions.setActiveKeyAndEnsureDependencies(ActionTypes.LAYER_TEMPLATES, 'layerTemplate'),
  updateEdited: updateEdited$1,
  useIndexed: useIndexed$1,
  useIndexedClear: useIndexedClear,
  useKeys: useKeys$1,
  useKeysClear: useKeysClear
};

var setActiveKey = actions.setActiveKey(ActionTypes.AREAS.AREA_TREE_LEVELS);
var useIndexed$2 = actions.useIndexed(Select.areas.areaTreeLevels.getSubstate, 'areaTreeLevels', ActionTypes.AREAS.AREA_TREE_LEVELS);
var useKeys$2 = actions.useKeys(Select.areas.areaTreeLevels.getSubstate, 'areaTreeLevels', ActionTypes.AREAS.AREA_TREE_LEVELS);
var refreshUses$1 = actions.refreshUses(Select.areas.areaTreeLevels.getSubstate, "areaTreeLevels", ActionTypes.AREAS.AREA_TREE_LEVELS);
var ensureIndexesWithFilterByActive$2 = actions.ensureIndexesWithFilterByActive(Select.areas.areaTrees.getSubstate, 'areaTreeLevels', ActionTypes.AREAS.AREA_TREE_LEVELS); // ============ actions ===========

function actionClearUseIndexed(componentId) {
  return {
    type: ActionTypes.AREAS.AREA_TREE_LEVELS.USE.INDEXED.CLEAR,
    componentId: componentId
  };
} // ============ export ===========


var actions$1 = {
  ensureIndexesWithFilterByActive: ensureIndexesWithFilterByActive$2,
  refreshUses: refreshUses$1,
  setActiveKey: setActiveKey,
  useIndexed: useIndexed$2,
  useIndexedClear: actionClearUseIndexed,
  useKeys: useKeys$2
};

var setActiveKey$1 = actions.setActiveKey(ActionTypes.AREAS.AREA_TREES);
var useIndexed$3 = actions.useIndexed(Select.areas.areaTrees.getSubstate, 'areaTrees', ActionTypes.AREAS.AREA_TREES);
var useKeys$3 = actions.useKeys(Select.areas.areaTrees.getSubstate, 'areaTrees', ActionTypes.AREAS.AREA_TREES);
var refreshUses$2 = actions.refreshUses(Select.areas.areaTrees.getSubstate, "areaTrees", ActionTypes.AREAS.AREA_TREES);
var ensureIndexesWithFilterByActive$3 = actions.ensureIndexesWithFilterByActive(Select.areas.areaTrees.getSubstate, 'areaTrees', ActionTypes.AREAS.AREA_TREES); // ============ actions ===========

function actionClearUseIndexed$1(componentId) {
  return {
    type: ActionTypes.AREAS.AREA_TREES.USE.INDEXED.CLEAR,
    componentId: componentId
  };
} // ============ export ===========


var actions$2 = {
  ensureIndexesWithFilterByActive: ensureIndexesWithFilterByActive$3,
  refreshUses: refreshUses$2,
  setActiveKey: setActiveKey$1,
  useIndexed: useIndexed$3,
  useIndexedClear: actionClearUseIndexed$1,
  useKeys: useKeys$3,
  useKeysClear: actions.useKeysClear(ActionTypes.AREAS.AREA_TREES)
};

var AreasAction = {
  areaTreeLevels: actions$1,
  areaTrees: actions$2
};

var add$1 = actions.add(ActionTypes.SELECTIONS);
var setActiveKey$2 = actions.setActiveKey(ActionTypes.SELECTIONS);
var updateStateFromView = actions.updateSubstateFromView(ActionTypes.SELECTIONS);

var setActiveSelectionFeatureKeysFilterKeys = function setActiveSelectionFeatureKeysFilterKeys(selectionKeys) {
  return function (dispatch, getState) {
    var activeSelectionKey = Select.selections.getActiveKey(getState());

    if (activeSelectionKey && selectionKeys) {
      dispatch(setFeatureKeysFilterKeys(activeSelectionKey, selectionKeys));
    }
  };
};

var updateStateFromViewWithData = function updateStateFromViewWithData(view) {
  return function (dispatch, getState) {
    dispatch(updateStateFromView(view));

    if (view.data) {
      dispatch(add$1(view.data));
    }
  };
}; // ============ actions ===========


function clearFeatureKeysFilter(key) {
  return {
    type: ActionTypes.SELECTIONS.CLEAR.FEATURE_KEYS_FILTER,
    key: key
  };
}

function setFeatureKeysFilterKeys(key, featureKeys) {
  return {
    type: ActionTypes.SELECTIONS.SET.FEATURE_KEYS_FILTER.KEYS,
    key: key,
    featureKeys: featureKeys
  };
}

var SelectionsAction = {
  add: add$1,
  clearFeatureKeysFilter: clearFeatureKeysFilter,
  setActiveSelectionFeatureKeysFilterKeys: setActiveSelectionFeatureKeysFilterKeys,
  setActiveKey: setActiveKey$2,
  updateStateFromView: updateStateFromView,
  updateStateFromViewWithData: updateStateFromViewWithData
};

var useKeys$4 = actions.useKeys(Select.spatialDataSources.vector.getSubstate, 'spatial', ActionTypes.SPATIAL_DATA_SOURCES.VECTOR, 'data');
var useKeysClear$1 = actions.useKeysClear(ActionTypes.SPATIAL_DATA_SOURCES.VECTOR);
var useIndexed$4 = actions.useIndexed(Select.spatialDataSources.vector.getSubstate, 'spatial', ActionTypes.SPATIAL_DATA_SOURCES.VECTOR, 'data');
var useIndexedBatch$1 = actions.useIndexedBatch('spatial', ActionTypes.SPATIAL_DATA_SOURCES.VECTOR, 'data');
var useIndexedClear$1 = actions.useIndexedClear(ActionTypes.SPATIAL_DATA_SOURCES.VECTOR);
var clearIndex$1 = actions.clearIndex(ActionTypes.SPATIAL_DATA_SOURCES.VECTOR);
var addBatch = actions.addBatch(ActionTypes.SPATIAL_DATA_SOURCES.VECTOR);
var addBatchIndex = actions.addBatchIndex(ActionTypes.SPATIAL_DATA_SOURCES.VECTOR); // ============ creators ===========

function loadLayerData(filter, componentId) {
  return function (dispatch, getState) {
    var additionalParams = {};
    var geometriesAccuracy = Select.app.getLocalConfiguration(getState(), 'geometriesAccuracy');

    if (geometriesAccuracy) {
      additionalParams.transformation = {
        snapToGrid: {
          size: geometriesAccuracy
        },
        transform: 4326
      };
    }

    return dispatch(useIndexedBatch$1(null, filter, null, componentId, 'spatialDataSourceKey', additionalParams));
  };
} // ============ export ===========


var vectorActions = {
  addBatch: addBatch,
  addBatchIndex: addBatchIndex,
  loadLayerData: loadLayerData,
  useKeys: useKeys$4,
  useKeysClear: useKeysClear$1,
  useIndexed: useIndexed$4,
  useIndexedClear: useIndexedClear$1,
  clearIndex: clearIndex$1
};

var useKeys$5 = actions.useKeys(Select.spatialDataSources.getSubstate, 'spatial', ActionTypes.SPATIAL_DATA_SOURCES, 'dataSources');
var useKeysClear$2 = actions.useKeysClear(ActionTypes.SPATIAL_DATA_SOURCES);
var add$2 = actions.add(ActionTypes.SPATIAL_DATA_SOURCES); // ============ export ===========

var SpatialDataSourcesAction = {
  vector: vectorActions,
  add: add$2,
  useKeys: useKeys$5,
  useKeysClear: useKeysClear$2
};

var useIndexedRegister = function useIndexedRegister(componentId, filterByActive, filter, order, start, length) {
  return actions.useIndexedRegister(ActionTypes.SPATIAL_RELATIONS, componentId, filterByActive, filter, order, start, length);
};

var ensureIndexed$1 = function ensureIndexed(filter, order, start, length) {
  return actions.ensureIndexed(Select.spatialRelations.getSubstate, 'spatial', filter, order, start, length, ActionTypes.SPATIAL_RELATIONS, 'relations');
};

var add$3 = actions.add(ActionTypes.SPATIAL_RELATIONS);
var useIndexedClearAll = actions.useIndexedClearAll(ActionTypes.SPATIAL_RELATIONS);

function ensureIndexedAndEnsureDependencies(filter, order, start, length, componentId, noStatistic) {
  return function (dispatch, getState) {
    dispatch(actions.ensureIndexed(Select.spatialRelations.getSubstate, 'spatial', filter, order, start, length, ActionTypes.SPATIAL_RELATIONS, 'relations')).then(function () {
      var filteredRelations = Select.spatialRelations.getFilteredData(getState(), filter);

      if (filteredRelations) {
        var dataSourceKeys = _map__default['default'](filteredRelations, function (relation) {
          return relation.spatialDataSourceKey;
        });

        var uniqueDataSourcesKeys = _uniq__default['default'](dataSourceKeys);
        /* Ensure spatial data sources */
        // TODO component id?


        if (uniqueDataSourcesKeys) {
          dispatch(SpatialDataSourcesAction.useKeys(uniqueDataSourcesKeys, componentId)).then(function () {// TODO load data for vector data sources
          });
        }
      }
    })["catch"](function (err) {
      dispatch(actions.actionGeneralError(err));
    });
  };
}

function ensureIndexesWithFilterByActive$4(filterByActive) {
  return function (dispatch, getState) {
    var state = getState();
    var usedIndexes = commonSelectors.getUsesWithActiveDependency(Select.spatialRelations.getSubstate)(state, filterByActive); // TODO pass componentId

    _each__default['default'](usedIndexes, function (usedIndex) {
      _each__default['default'](usedIndex.uses, function (use) {
        dispatch(ensureIndexedAndEnsureDependencies(usedIndex.filter, usedIndex.order, use.start, use.length));
      });
    });
  };
} // ============ export ===========


var SpatialRelationsAction = {
  add: add$3,
  useIndexedRegister: useIndexedRegister,
  useIndexedClearAll: useIndexedClearAll,
  ensureIndexed: ensureIndexed$1,
  ensureIndexesWithFilterByActive: ensureIndexesWithFilterByActive$4
};

var useIndexedRegister$1 = function useIndexedRegister(componentId, filterByActive, filter, order, start, length) {
  return actions.useIndexedRegister(ActionTypes.AREA_RELATIONS, componentId, filterByActive, filter, order, start, length);
};

var ensureIndexed$2 = function ensureIndexed(filter, order, start, length) {
  return actions.ensureIndexed(Select.areaRelations.getSubstate, 'area', filter, order, start, length, ActionTypes.AREA_RELATIONS, 'relations');
};

var add$4 = actions.add(ActionTypes.AREA_RELATIONS);
var useIndexedClearAll$1 = actions.useIndexedClearAll(ActionTypes.AREA_RELATIONS); // ============ export ===========

var AreaRelationsAction = {
  add: add$4,
  useIndexedRegister: useIndexedRegister$1,
  useIndexedClearAll: useIndexedClearAll$1,
  ensureIndexed: ensureIndexed$2
};

var useIndexed$5 = actions.useIndexed(Select.spatialData.getSubstate, 'spatial', ActionTypes.SPATIAL_DATA, 'data'); // ============ creators ===========
// ============ export ===========

var SpatialDataAction = {
  useIndexed: useIndexed$5
};

var create$2 = actions.create(Select.attributes.getSubstate, 'attributes', ActionTypes.ATTRIBUTES);
var refreshUses$3 = actions.refreshUses(Select.attributes.getSubstate, "attributes", ActionTypes.ATTRIBUTES);
var deleteItem$2 = actions["delete"](Select.attributes.getSubstate, 'attributes', ActionTypes.ATTRIBUTES);
var saveEdited$2 = actions.saveEdited(Select.attributes.getSubstate, 'attributes', ActionTypes.ATTRIBUTES);
var updateEdited$2 = actions.updateEdited(Select.attributes.getSubstate, ActionTypes.ATTRIBUTES);
var useIndexed$6 = actions.useIndexed(Select.attributes.getSubstate, 'attributes', ActionTypes.ATTRIBUTES);
var useIndexedClear$2 = actions.useIndexedClear(ActionTypes.ATTRIBUTES);
var useKeys$6 = actions.useKeys(Select.attributes.getSubstate, 'attributes', ActionTypes.ATTRIBUTES);
var useKeysClear$3 = actions.useKeysClear(ActionTypes.ATTRIBUTES);
var ensureIndexesWithFilterByActive$5 = actions.ensureIndexesWithFilterByActive(Select.attributes.getSubstate, 'attributes', ActionTypes.ATTRIBUTES);
var updateStateFromView$1 = actions.updateSubstateFromView(ActionTypes.ATTRIBUTES);
var useIndexedBatch$2 = actions.useIndexedBatch('attributes', ActionTypes.ATTRIBUTES, 'data');
var setActiveKeyAndEnsureDependencies$1 = actions.setActiveKeyAndEnsureDependencies(ActionTypes.ATTRIBUTES, 'attribute');

function setActiveKey$3(key) {
  return function (dispatch) {
    dispatch(setActiveKeyAndEnsureDependencies$1(key));
  };
}

function loadAttributeData(filter, componentId) {
  return function (dispatch, getState) {
    return dispatch(useIndexedBatch$2(null, filter, null, componentId, 'attributeDataSourceKey'));
  };
} // ============ export ===========


var actions$3 = {
  create: create$2,
  "delete": deleteItem$2,
  ensureIndexesWithFilterByActive: ensureIndexesWithFilterByActive$5,
  updateStateFromView: updateStateFromView$1,
  refreshUses: refreshUses$3,
  saveEdited: saveEdited$2,
  setActiveKey: setActiveKey$3,
  updateEdited: updateEdited$2,
  useIndexed: useIndexed$6,
  useIndexedClear: useIndexedClear$2,
  useKeys: useKeys$6,
  useKeysClear: useKeysClear$3,
  useIndexedBatch: useIndexedBatch$2,
  loadAttributeData: loadAttributeData
};

var useIndexed$7 = actions.useIndexed(Select.attributeData.getSubstate, 'attribute', ActionTypes.ATTRIBUTE_DATA, 'data');
var useIndexedClear$3 = actions.useIndexedClear(ActionTypes.ATTRIBUTE_DATA);
var useIndexedBatch$3 = actions.useIndexedBatch('attribute', ActionTypes.ATTRIBUTE_DATA, 'data');

function loadFilteredData(filter, componentId) {
  return function (dispatch) {
    return dispatch(useIndexedBatch$3(null, filter, null, componentId, 'attributeDataSourceKey'));
  };
} // ============ export ===========


var actions$4 = {
  useIndexed: useIndexed$7,
  useIndexedClear: useIndexedClear$3,
  loadFilteredData: loadFilteredData
};

var useIndexedClear$4 = actions.useIndexedClear(ActionTypes.ATTRIBUTE_STATISTICS);
var useIndexedBatch$4 = actions.useIndexedBatch('attribute', ActionTypes.ATTRIBUTE_STATISTICS, 'statistic');

function loadFilteredData$1(filter, componentId) {
  return function (dispatch) {
    return dispatch(useIndexedBatch$4(null, filter, null, componentId, 'attributeDataSourceKey'));
  };
} // ============ export ===========


var actions$5 = {
  useIndexedClear: useIndexedClear$4,
  loadFilteredData: loadFilteredData$1
};

var useKeys$7 = actions.useKeys(Select.attributeDataSources.getSubstate, 'attribute', ActionTypes.ATTRIBUTE_DATA_SOURCES, 'dataSources');
var useKeysClear$4 = actions.useKeysClear(ActionTypes.ATTRIBUTE_DATA_SOURCES); // ============ export ===========

var actions$6 = {
  useKeys: useKeys$7,
  useKeysClear: useKeysClear$4
};

var useIndexedRegister$2 = function useIndexedRegister(componentId, filterByActive, filter, order, start, length) {
  return actions.useIndexedRegister(ActionTypes.ATTRIBUTE_RELATIONS, componentId, filterByActive, filter, order, start, length);
};

var useIndexed$8 = actions.useIndexed(Select.attributeRelations.getSubstate, 'attribute', ActionTypes.ATTRIBUTE_RELATIONS, 'relations');
var useIndexedClearAll$2 = actions.useIndexedClearAll(ActionTypes.ATTRIBUTE_RELATIONS);

var ensureIndexed$3 = function ensureIndexed(filter, order, start, length) {
  return actions.ensureIndexed(Select.attributeRelations.getSubstate, 'attribute', filter, order, start, length, ActionTypes.ATTRIBUTE_RELATIONS, 'relations');
}; // ============ actions ===========


function ensureIndexedSpecific(filter, order, start, length, componentId, noStatistic) {
  return function (dispatch, getState) {
    dispatch(actions.ensureIndexed(Select.attributeRelations.getSubstate, 'attribute', filter, order, start, length, ActionTypes.ATTRIBUTE_RELATIONS, 'relations')).then(function () {
      var filteredRelations = Select.attributeRelations.getFilteredRelations(getState(), filter);

      if (filteredRelations) {
        var dataSourceKeys = _map__default['default'](filteredRelations, function (relation) {
          return relation.attributeDataSourceKey;
        });

        var attributeKeys = _map__default['default'](filteredRelations, function (relation) {
          return relation.attributeKey;
        });

        var fidColumnNames = null;
        var attributeDataSourceKeys = [];
        filteredRelations.map(function (relation) {
          fidColumnNames = relation.fidColumnName; // TODO is fidColumnName still the same

          attributeDataSourceKeys.push(relation.attributeDataSourceKey);
        });

        var uniqueAtributeDataSourceKeys = _uniq__default['default'](attributeDataSourceKeys);

        var attributeDataFilter = {
          fidColumnName: fidColumnNames,
          attributeDataSourceKey: {
            "in": uniqueAtributeDataSourceKeys
          }
        };
        var statisticsFilter = {
          percentile: ptrUtils.statistics.quartilePercentiles,
          attributeDataSourceKey: {
            "in": uniqueAtributeDataSourceKeys
          }
        };
        /* use attributes */

        if (attributeKeys && attributeKeys.length) {
          var uniqueKeys = _uniq__default['default'](attributeKeys);

          dispatch(actions$3.useKeys(uniqueKeys, componentId));
        }
        /* use attribute data sources */


        dispatch(actions$6.useKeys(dataSourceKeys, componentId));
        /* use attribute statistics */

        /* TODO use indexed? */

        var existingStatisticsSource = Select.attributeStatistics.getBatchByFilterOrder(getState(), statisticsFilter, null);

        if (!noStatistic && !existingStatisticsSource) {
          dispatch(actions$5.loadFilteredData(statisticsFilter, componentId));
        }
        /* use attribute data */


        var existingSource = Select.attributeData.getBatchByFilterOrder(getState(), attributeDataFilter, null);

        if (!existingSource) {
          dispatch(actions$4.loadFilteredData(attributeDataFilter, componentId));
        }
      }
    })["catch"](function (err) {
      dispatch(actions.actionGeneralError(err));
    });
  };
}

function ensureIndexesWithFilterByActive$6(filterByActive) {
  return function (dispatch, getState) {
    var state = getState();
    var usedIndexes = commonSelectors.getUsesWithActiveDependency(Select.attributeRelations.getSubstate)(state, filterByActive); // TODO pass componentId

    _each__default['default'](usedIndexes, function (usedIndex) {
      _each__default['default'](usedIndex.uses, function (use) {
        dispatch(ensureIndexedSpecific(usedIndex.filter, usedIndex.order, use.start, use.length)); // dispatch(ensureIndexedSpecificForLegend(usedIndex.filter, usedIndex.order, use.start, use.length))
      });
    });
  };
} // ============ export ===========


var actions$7 = {
  useIndexed: useIndexed$8,
  useIndexedClearAll: useIndexedClearAll$2,
  useIndexedRegister: useIndexedRegister$2,
  ensureIndexed: ensureIndexed$3,
  ensureIndexesWithFilterByActive: ensureIndexesWithFilterByActive$6,
  // TODO join with ensure indexed
  ensureIndexedSpecific: ensureIndexedSpecific
};

var add$5 = actions.add(ActionTypes.STYLES);
var useIndexed$9 = actions.useIndexed(Select.styles.getSubstate, 'styles', ActionTypes.STYLES);
var useKeys$8 = actions.useKeys(Select.styles.getSubstate, 'styles', ActionTypes.STYLES);
var useKeysClear$5 = actions.useKeysClear(ActionTypes.STYLES);
var updateStateFromView$2 = actions.updateSubstateFromView(ActionTypes.STYLES); // ============ export ===========
// TODO - common?

var updateStateFromViewWithData$1 = function updateStateFromViewWithData(view) {
  return function (dispatch, getState) {
    dispatch(updateStateFromView$2(view));

    if (view.data) {
      dispatch(add$5(view.data));
    }
  };
};

var StylesActions = {
  add: add$5,
  useIndexed: useIndexed$9,
  useKeys: useKeys$8,
  useKeysClear: useKeysClear$5,
  updateStateFromView: updateStateFromView$2,
  updateStateFromViewWithData: updateStateFromViewWithData$1
};

var actionGeneralError$1 = actions.actionGeneralError;
var setInitial = actions.setInitial(ActionTypes.MAPS);
/*
Table of contents
	- creators
	- deprecated creators
	- actions
	- deprecated actions
	- exports
*/

/* ==================================================
 * CREATORS
 * ================================================== */

var setActiveMapKey = function setActiveMapKey(mapKey) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (mapByKey) {
      var activeMapKey = Select._deprecatedMaps.getActiveMapKey(state);

      if (mapKey !== activeMapKey) {
        dispatch(actionSetActiveMapKey(mapKey));

        var setByMapKey = Select._deprecatedMaps.getMapSetByMapKey(state, mapKey);

        if (setByMapKey) {
          dispatch(setActiveSetKey(setByMapKey.key));
        }
      }
    } else {
      return dispatch(actionGeneralError$1("Can not set mapKey ".concat(mapKey, " as active, because map with this key dont exists.")));
    }
  };
};

var setMapSetActiveMapKey = function setMapSetActiveMapKey(mapKey) {
  return function (dispatch, getState) {
    var set = Select._deprecatedMaps.getMapSetByMapKey(getState(), mapKey);

    if (set) {
      dispatch(actionSetMapSetActiveMapKey(set.key, mapKey));
    }
  };
};

var setActiveSetKey = function setActiveSetKey(setKey) {
  return function (dispatch, getState) {
    var state = getState();

    var setByKey = Select._deprecatedMaps.getMapSetByKey(state, setKey);

    if (setByKey) {
      var activeSetKey = Select._deprecatedMaps.getActiveSetKey(state);

      if (setKey !== activeSetKey) {
        return dispatch(actionSetActiveSetKey(setKey));
      }
    } else {
      return dispatch(actionGeneralError$1("Can not set setKey ".concat(setKey, " as active, because set with this key dont exists.")));
    }
  };
};

var addSet = function addSet(set) {
  return function (dispatch, getState) {
    var state = getState();
    var setKey = set.key;

    if (!setKey) {
      return dispatch(actionGeneralError$1("Undefined setKey for set ".concat(set)));
    } else {
      var setByKey = Select._deprecatedMaps.getMapSetByKey(state, setKey);

      if (setByKey) {
        return dispatch(actionGeneralError$1("Set with given setKey (".concat(setKey, ") already exists ").concat(setByKey)));
      } else {
        dispatch(actionAddSet(set)); //if no set is active, set set as active

        var activeSetKey = Select._deprecatedMaps.getActiveSetKey(state);

        if (!activeSetKey) {
          dispatch(actionSetActiveSetKey(setKey));
        }
      }
    }
  };
};
/**
 * {Object} layerTreesFilter
 * {Array} mapKeys
 */


var addLayersToMaps = function addLayersToMaps(layerTreesFilter, mapKeys, useActiveMetadataKeys) {
  return function (dispatch, getState) {
    var state = getState(); // getIndexed

    var layerTreesData = Select.layerTrees.getByFilterOrder(state, layerTreesFilter, null);

    if (layerTreesData) {
      //BE should return only one record, but could be bore fore scopeKey and applicationKey. 
      //Take last record
      var lastLTdata = layerTreesData[layerTreesData.length - 1]; //parse to map state

      if (lastLTdata && lastLTdata.data && lastLTdata.data.structure && lastLTdata.data.structure.length > 0) {
        var layerTreeStructure = lastLTdata.data.structure;
        dispatch(addTreeLayers(layerTreeStructure, 'layers', mapKeys, useActiveMetadataKeys));
        dispatch(addTreeLayers(layerTreeStructure, 'backgroundLayers', mapKeys, useActiveMetadataKeys));
      }
    }
  };
};

var addTreeLayers = function addTreeLayers(treeLayers, layerTreeBranchKey, mapKeys, useActiveMetadataKeys) {
  return function (dispatch, getState) {
    var state = getState(); //no array but object

    var flattenLT = ptrUtils.layerTree.getFlattenLayers(treeLayers[0][layerTreeBranchKey]);
    var visibleLayers = flattenLT.filter(function (l) {
      return l.visible;
    }); //add all visible layers in layerTree to map

    var visibleLayersKeys = visibleLayers.map(function (l) {
      return l.key;
    });

    if (mapKeys) {
      mapKeys.forEach(function (mapKey) {
        // check if layer in map
        var layersState = Select._deprecatedMaps.getLayersStateByMapKey_deprecated(state, mapKey, useActiveMetadataKeys); // clean templateKeys found in map


        var uniqVisibleLayersKeys = layersState ? visibleLayersKeys.filter(function (lk) {
          return !layersState.some(function (ls) {
            return ls.layer && ls.layer.layerTemplate === lk;
          });
        }) : visibleLayersKeys;
        uniqVisibleLayersKeys.forEach(function (layerKey) {
          var zIndex = ptrUtils.layerTree.getLayerZindex(treeLayers[0], layerKey);
          var layer = {
            layerTemplate: layerKey
          };

          switch (layerTreeBranchKey) {
            case 'backgroundLayers':
              return dispatch(setMapBackgroundLayer(mapKey, layer));

            case 'layers':
              return dispatch(addLayer(mapKey, layer, zIndex, useActiveMetadataKeys));

            default:
              return dispatch(addLayer(mapKey, layer, zIndex, useActiveMetadataKeys));
          }
        });
      });
    }
  };
};

var removeSet = function removeSet(setKey) {
  return function (dispatch, getState) {
    var state = getState();

    var setByKey = Select._deprecatedMaps.getMapSetByKey(state, setKey);

    if (!setByKey) {
      return dispatch(actionGeneralError$1("No set found for setKey ".concat(setKey, ".")));
    } else {
      return dispatch(actionRemoveSet(setKey));
    }
  };
};

var addMapToSet = function addMapToSet(setKey, mapKey) {
  return function (dispatch, getState) {
    var state = getState();

    var setByKey = Select._deprecatedMaps.getMapSetByKey(state, setKey);

    if (!setByKey) {
      return dispatch(actionGeneralError$1("No set found for setKey ".concat(setKey, ".")));
    } else {
      //check map exist
      if (setByKey.maps && setByKey.maps.includes(mapKey)) {
        return dispatch(actionGeneralError$1("Set ".concat(setKey, " already contains map ").concat(mapKey, ".")));
      } else {
        dispatch(actionAddMapToSet(setKey, mapKey)); //if no map is active, set map as active

        var activeMapKey = Select._deprecatedMaps.getMapSetActiveMapKey(state, setKey);

        if (!activeMapKey) {
          dispatch(setMapSetActiveMapKey(mapKey));
        }
      }
    }
  };
};

var removeMapKeyFromSet = function removeMapKeyFromSet(setKey, mapKey) {
  return function (dispatch, getState) {
    var state = getState();

    var setByKey = Select._deprecatedMaps.getMapSetByKey(state, setKey);

    if (!setByKey) {
      return dispatch(actionGeneralError$1("No set found for setKey ".concat(setKey, ".")));
    } else {
      //check map exist
      if (setByKey.maps && setByKey.maps.includes(mapKey)) {
        var activeMapKey = Select._deprecatedMaps.getMapSetActiveMapKey(state, setKey);

        dispatch(actionRemoveMapKeyFromSet(setKey, mapKey));

        if (activeMapKey === mapKey) {
          var mapSetMapKeys = Select._deprecatedMaps.getMapSetMapKeys(getState(), setKey);

          if (mapSetMapKeys) {
            dispatch(actionSetMapSetActiveMapKey(setKey, mapSetMapKeys[0]));
          }
        }
      } else {
        return dispatch(actionGeneralError$1("Set ".concat(setKey, " do not contains map ").concat(mapKey, ".")));
      }
    }
  };
};

var setSetView = function setSetView(setKey, view) {
  return function (dispatch, getState) {
    var state = getState();

    var setByKey = Select._deprecatedMaps.getMapSetByKey(state, setKey);

    if (!setByKey) {
      return dispatch(actionGeneralError$1("No set found for setKey ".concat(setKey, ".")));
    } else {
      return dispatch(actionSetSetView(setKey, view));
    }
  };
};

var setSetSync = function setSetSync(setKey, sync) {
  return function (dispatch, getState) {
    var state = getState();

    var setByKey = Select._deprecatedMaps.getMapSetByKey(state, setKey);

    if (!setByKey) {
      return dispatch(actionGeneralError$1("No set found for setKey ".concat(setKey, ".")));
    } else {
      return dispatch(actionSetSetSync(setKey, sync));
    }
  };
};

var orderSetByMapPeriod = function orderSetByMapPeriod(setKey) {
  return function (dispatch, getState) {
    var state = getState();

    var setMaps = Select._deprecatedMaps.getMapSetMapKeys(state, setKey);

    var maps = Select._deprecatedMaps.getMapsAsObject(state);

    var periods = Select.periods.getAllAsObject(state);

    if (setMaps && maps && periods) {
      var extendedSetMaps = setMaps.map(function (mapKey) {
        var map = _cloneDeep__default['default'](maps[mapKey]);

        var periodKey = map && map.data && map.data.metadataModifiers && map.data.metadataModifiers.period;

        if (periodKey && periods[periodKey]) {
          map.data.metadataModifiers.period = periods[periodKey].data.period || periods[periodKey].data.nameDisplay;
        }

        return map;
      });

      if (extendedSetMaps && extendedSetMaps.length) {
        var orderedExtendedSetMaps = _orderBy__default['default'](extendedSetMaps, ['data.metadataModifiers.period'], ['asc']);

        var orderedMapKeys = orderedExtendedSetMaps.map(function (map) {
          return map.key;
        });
        dispatch(actionSetSetMaps(setKey, orderedMapKeys));
      }
    }
  };
};

var addMap = function addMap(map) {
  return function (dispatch, getState) {
    if (map && !map.key) {
      return dispatch(actionGeneralError$1("Undefined mapKey for map ".concat(map)));
    } else {
      var state = getState();

      var mapByKey = Select._deprecatedMaps.getMapByKey(state, map.key);

      if (mapByKey) {
        return dispatch(actionGeneralError$1("Map with given mapKey (".concat(map.key, ") already exists ").concat(mapByKey)));
      } else {
        return dispatch(actionAddMap(map));
      }
    }
  };
};

var addMapForPeriod = function addMapForPeriod(periodKey, setKey) {
  return function (dispatch, getState) {
    var state = getState();

    var map = Select._deprecatedMaps.getMapByMetadata_deprecated(state, {
      period: periodKey
    });

    if (!map) {
      var mapKey = ptrUtils.utils.uuid();
      map = {
        key: mapKey,
        data: {
          metadataModifiers: {
            period: periodKey
          }
        }
      };
      dispatch(addMap(map));
    }

    dispatch(addMapToSet(setKey, map.key));
    dispatch(orderSetByMapPeriod(setKey));
  };
};

var removeMap = function removeMap(mapKey) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      var mapSets = Select._deprecatedMaps.getMapSets(state);

      if (mapSets) {
        _each__default['default'](mapSets, function (mapSet) {
          var mapSetMapKey = _includes__default['default'](mapSet.maps, mapKey);

          if (mapSetMapKey) {
            dispatch(removeMapKeyFromSet(mapSet.key, mapKey));
          }
        });
      }

      dispatch(actionRemoveMap(mapKey));
    }
  };
};

var removeMapForPeriod = function removeMapForPeriod(periodKey, setKey) {
  return function (dispatch, getState) {
    var state = getState();

    var map = Select._deprecatedMaps.getMapByMetadata_deprecated(state, {
      period: periodKey
    });

    if (!map) {
      dispatch(actionGeneralError$1("No map found for period ".concat(periodKey, ".")));
    } else {
      dispatch(removeMap(map.key));
    }
  };
};

var setMapName = function setMapName(mapKey, name) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      return dispatch(actionSetMapName(mapKey, name));
    }
  };
};

var setMapData = function setMapData(mapKey, data) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      return dispatch(actionSetMapData(mapKey, data));
    }
  };
};

var setMapView = function setMapView(mapKey, view) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      return dispatch(actionSetMapView(mapKey, view));
    }
  };
};

var addLayer = function addLayer(mapKey, layer, index, useActiveMetadataKeys) {
  return function (dispatch, getState) {
    var state = getState();

    if (!layer.key) {
      layer.key = ptrUtils.utils.uuid();
    }

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      dispatch(actionAddLayer(mapKey, layer, index));
      dispatch(use(mapKey, useActiveMetadataKeys));
    }
  };
};

var addLayers = function addLayers(mapKey, layers) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      return layers.map(function (layer) {
        return dispatch(addLayer(mapKey, layer));
      });
    }
  };
};

var removeLayer = function removeLayer(mapKey, layerKey) {
  return function (dispatch, getState) {
    if (!layerKey) {
      return dispatch(actionGeneralError$1("Undefined layer key."));
    } else {
      var state = getState();

      var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

      if (!mapByKey) {
        return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
      } else {
        //check if layer exist
        var layer = Select._deprecatedMaps.getMapLayerByMapKeyAndLayerKey(state, mapKey, layerKey);

        if (layer) {
          return dispatch(actionRemoveLayer(mapKey, layerKey));
        } else {
          return dispatch(actionGeneralError$1("No layer (".concat(layerKey, ") found in mapKey ").concat(mapKey, ".")));
        }
      }
    }
  };
};

var removeLayers = function removeLayers(mapKey, layersKeys) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      return layersKeys.map(function (layerKey) {
        return dispatch(removeLayer(mapKey, layerKey));
      });
    }
  };
};

var setLayerIndex = function setLayerIndex(mapKey, layerKey, index) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      dispatch(actionSetLayerIndex(mapKey, layerKey, index));
    }
  };
};

var setLayerHoveredFeatureKeys = function setLayerHoveredFeatureKeys(mapKey, layerKey, hoveredFeatureKeys) {
  return function (dispatch, getState) {
    var state = getState();

    var mapLayer = Select._deprecatedMaps.getMapLayerByMapKeyAndLayerKey(state, mapKey, layerKey);

    if (mapLayer) {
      var prevKeys = mapLayer && mapLayer.options && mapLayer.options.hovered && mapLayer.options.hovered.keys;

      if (prevKeys) {
        var prevKeysString = JSON.stringify(_sortBy__default['default'](prevKeys));
        var nextKeysString = JSON.stringify(_sortBy__default['default'](hoveredFeatureKeys));

        if (prevKeysString !== nextKeysString) {
          dispatch(actionSetMapLayerHoveredFeatureKeys(mapKey, layerKey, hoveredFeatureKeys));
        }
      } else {
        dispatch(actionSetMapLayerHoveredFeatureKeys(mapKey, layerKey, hoveredFeatureKeys));
      }
    } // TODO
    else {
        var set = Select._deprecatedMaps.getMapSetByMapKey(state, mapKey);
      }
  };
}; // TODO refactor - where to decide if selections are enabled


var setLayerSelectedFeatureKeys = function setLayerSelectedFeatureKeys(mapKey, layerKey, selectedFeatureKeys) {
  return function (dispatch, getState) {
    var state = getState();

    var mapLayer = Select._deprecatedMaps.getMapLayerByMapKeyAndLayerKey(state, mapKey, layerKey);

    var activeSelectionKey = Select.selections.getActiveKey(state);
    var selectionKey = activeSelectionKey || ptrUtils.utils.uuid(); // set selection in selections store

    if (!activeSelectionKey) {
      var defaultSelection = {
        key: selectionKey,
        data: {
          colour: "#00ffff",
          //style: styleKey // TODO???
          featureKeysFilter: {
            keys: selectedFeatureKeys
          }
        }
      };
      dispatch(SelectionsAction.add([defaultSelection]));
      dispatch(SelectionsAction.setActiveKey(selectionKey));
    } else {
      dispatch(SelectionsAction.setActiveSelectionFeatureKeysFilterKeys(selectedFeatureKeys));
    } // TODO it shouldn't be needed since this only clear and set again empty selection object
    // set selection in map store
    // if (mapLayer) {
    // 	dispatch(actionClearSelectionInAllLayers(mapKey, selectionKey));
    // 	dispatch(actionSetMapLayerSelection(mapKey, layerKey, selectionKey));
    // }
    //
    // // TODO
    // else {
    // 	let set = Select._deprecatedMaps.getMapSetByMapKey(state, mapKey);
    // 	if (set) {
    //
    // 	}
    // }

  };
};
/**
 * 
 * Similar like add layer.
 * It enables to set any layer property except layerKey. 
 * Layer object is merged with default layer option.
 */


var setMapLayer = function setMapLayer(mapKey, layerKey, layer) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      //check if layer exist
      var layerExists = Select._deprecatedMaps.getMapLayerByMapKeyAndLayerKey(state, mapKey, layerKey);

      if (layerExists) {
        dispatch(actionSetMapLayer(mapKey, layerKey, layer));
      } else {
        return dispatch(actionGeneralError$1("No layer (".concat(layerKey, ") found in mapKey ").concat(mapKey, ".")));
      }
    }
  };
};

var setMapLayerStyle = function setMapLayerStyle(mapKey, layerKey, style) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      //check if layer exist
      var layerExists = Select._deprecatedMaps.getMapLayerByMapKeyAndLayerKey(state, mapKey, layerKey);

      if (layerExists) {
        dispatch(actionSetMapLayerStyle(mapKey, layerKey, style));
      } else {
        return dispatch(actionGeneralError$1("No layer (".concat(layerKey, ") found in mapKey ").concat(mapKey, ".")));
      }
    }
  };
};
/**
 * 
 * It enables to update any layer property except layerKey. 
 * Layer object is merged with actual layer option.
 */


var updateMapLayer = function updateMapLayer(mapKey, layerKey, layer) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      //check if layer exist
      var layerExists = Select._deprecatedMaps.getMapLayerByMapKeyAndLayerKey(state, mapKey, layerKey);

      if (layerExists) {
        dispatch(actionUpdateMapLayer(mapKey, layerKey, layer));
      } else {
        return dispatch(actionGeneralError$1("No layer (".concat(layerKey, ") found in mapKey ").concat(mapKey, ".")));
      }
    }
  };
};

var updateMapAndSetView = function updateMapAndSetView(mapKey, update) {
  return function (dispatch, getState) {
    var set = Select._deprecatedMaps.getMapSetByMapKey(getState(), mapKey);

    var forSet = null;
    var forMap = null;

    if (set && set.sync) {
      // pick key-value pairs that are synced for set
      forSet = _pickBy__default['default'](update, function (updateVal, updateKey) {
        return set.sync[updateKey];
      });
      forMap = _omitBy__default['default'](update, function (updateVal, updateKey) {
        return set.sync[updateKey];
      });
    } else {
      forMap = update;
    }

    if (forSet && !_isEmpty__default['default'](forSet)) {
      //check data integrity
      forSet = ptrUtils.map.view.ensureViewIntegrity(forSet); //TODO test

      dispatch(actionUpdateSetView(set.key, forSet));
    }

    if (forMap && !_isEmpty__default['default'](forMap)) {
      //check data integrity
      forMap = ptrUtils.map.view.ensureViewIntegrity(forMap); //TODO test

      dispatch(actionUpdateMapView(mapKey, forMap));
    }
  };
};

var updateSetView = function updateSetView(setKey, update) {
  return function (dispatch, getState) {
    var activeMapKey = Select._deprecatedMaps.getMapSetActiveMapKey(getState(), setKey);

    dispatch(updateMapAndSetView(activeMapKey, update));
  };
};

var resetViewHeading = function resetViewHeading(mapKey) {
  return function (dispatch, getState) {
    var view = Select._deprecatedMaps.getView(getState(), mapKey);

    ptrUtils.map.resetHeading(view.heading, function (heading) {
      return dispatch(updateMapAndSetView(mapKey, {
        heading: heading
      }));
    });
  };
};

var setMapScope = function setMapScope(mapKey, scope) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      dispatch(actionSetMapScope(mapKey, scope));
    }
  };
};

var setMapScenario = function setMapScenario(mapKey, scenario) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      dispatch(actionSetMapScenario(mapKey, scenario));
    }
  };
};

var setMapPeriod = function setMapPeriod(mapKey, period) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      dispatch(actionSetMapPeriod(mapKey, period));
    }
  };
};

var setMapPlace = function setMapPlace(mapKey, place) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      dispatch(actionSetMapPlace(mapKey, place));
    }
  };
};

var setMapCase = function setMapCase(mapKey, caseKey) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      dispatch(actionSetMapCase(mapKey, caseKey));
    }
  };
};

var setMapBackgroundLayer = function setMapBackgroundLayer(mapKey, backgroundLayer) {
  return function (dispatch, getState) {
    var state = getState();

    if (backgroundLayer && !backgroundLayer.key) {
      backgroundLayer.key = ptrUtils.utils.uuid();
    }

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      dispatch(actionSetMapBackgroundLayer(mapKey, backgroundLayer));
      dispatch(deprecated_use(mapKey));
    }
  };
};
/**
 * Set (replace) all map layers, and refresh use
 * @param mapKey
 * @param layers - complete layers array
 * @returns {Function}
 */


var setMapLayers = function setMapLayers(mapKey, layers) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      dispatch(actionSetMapLayers(mapKey, layers));
      dispatch(use(mapKey));
    }
  };
};

var setSetBackgroundLayer = function setSetBackgroundLayer(setKey, backgroundLayer) {
  return function (dispatch, getState) {
    var state = getState();

    var setByKey = Select._deprecatedMaps.getMapSetByKey(state, setKey);

    if (!setByKey) {
      return dispatch(actionGeneralError$1("No map set found for setKey ".concat(setKey, ".")));
    } else {
      dispatch(actionSetSetBackgroundLayer(setKey, backgroundLayer));
    }
  };
};

var setSetLayers = function setSetLayers(setKey, layers) {
  return function (dispatch, getState) {
    var state = getState();

    var setByKey = Select._deprecatedMaps.getMapSetByKey(state, setKey);

    if (!setByKey) {
      return dispatch(actionGeneralError$1("No map set found for setKey ".concat(setKey, ".")));
    } else {
      dispatch(actionSetSetLayers(setKey, layers));
    }
  };
};

function use(mapKey, backgroundLayer, layers) {
  return function (dispatch, getState) {
    dispatch(useClear(mapKey));
    var state = getState(); // let filterByActive = Select._deprecatedMaps.getFilterByActiveByMapKey(state, mapKey);

    if (backgroundLayer || layers) {
      if (backgroundLayer) {
        backgroundLayer = _objectSpread2(_objectSpread2({}, backgroundLayer), {}, {
          key: 'pantherBackgroundLayer'
        });
        layers = layers || [];
        layers = [backgroundLayer].concat(_toConsumableArray(layers));
      }
    } else {
      layers = Select._deprecatedMaps.getAllLayersStateByMapKey(state, mapKey);
    }

    var activeKeys = commonSelectors.getAllActiveKeys(state);

    if (layers) {
      var componentId = "map_".concat(mapKey);
      layers.forEach(function (layer) {
        var filter = _objectSpread2({}, layer.metadataModifiers);

        if (layer.layerTemplateKey) {
          filter.layerTemplateKey = layer.layerTemplateKey;
          dispatch(LayerTemplatesAction.useKeys([layer.layerTemplateKey], componentId));
        } else if (layer.areaTreeLevelKey) {
          filter.areaTreeLevelKey = layer.areaTreeLevelKey;
          dispatch(AreasAction.areaTreeLevels.useKeys([layer.areaTreeLevelKey], componentId));
        }

        var filterByActive = layer.filterByActive || null;
        var mergedFilter = commonHelpers.mergeFilters(activeKeys, filterByActive, filter);
        /* Ensure spatial relations or area relations */

        if (layer.layerTemplateKey || layer.areaTreeLevelKey || mergedFilter.layerTemplateKey) {
          var action, select;

          if (layer.layerTemplateKey || mergedFilter.layerTemplateKey) {
            action = SpatialRelationsAction;
            select = Select.spatialRelations;
          } else if (layer.areaTreeLevelKey) {
            action = AreaRelationsAction;
            select = Select.areaRelations;
          }

          dispatch(action.useIndexedRegister(componentId, filterByActive, filter, null, 1, 1000));
          dispatch(action.ensureIndexed(mergedFilter, null, 1, 1000)).then(function () {
            /* Ensure spatial data sources */
            var relations = select.getFilteredData(getState(), mergedFilter);

            if (relations && relations.length) {
              var spatialFilters = relations.map(function (relation) {
                return {
                  spatialDataSourceKey: relation.spatialDataSourceKey,
                  fidColumnName: relation.fidColumnName
                };
              });

              var spatialDataSourcesKeys = _uniq__default['default'](spatialFilters.map(function (filter) {
                return filter.spatialDataSourceKey;
              }));

              dispatch(SpatialDataSourcesAction.useKeys(spatialDataSourcesKeys, componentId)).then(function () {
                var dataSources = Select.spatialDataSources.getByKeys(getState(), spatialDataSourcesKeys);

                if (dataSources) {
                  dataSources.forEach(function (dataSource) {
                    // TODO load raster data?
                    if (dataSource && dataSource.data && dataSource.data.type === 'vector') {
                      var spatialFilter = _find__default['default'](spatialFilters, {
                        spatialDataSourceKey: dataSource.key
                      });

                      dispatch(SpatialDataAction.useIndexed(null, spatialFilter, null, 1, 1, componentId));
                    }
                  });
                }
              });
            }
          });
        } // Ensure attribute data //todo
        // TODO layer.attributeKey case?
        // TODO handle "key: in {}" case in filters


        if (layer.attributeKeys) {
          dispatch(actions$3.useKeys(layer.attributeKeys, componentId));

          var attributeFilter = _objectSpread2(_objectSpread2({}, layer.attributeMetadataModifiers), {}, {
            attributeKey: {
              "in": layer.attributeKeys
            }
          });

          if (layer.layerTemplateKey) {
            attributeFilter.layerTemplateKey = layer.layerTemplateKey;
          } else if (layer.areaTreeLevelKey) {
            attributeFilter.areaTreeLevelKey = layer.areaTreeLevelKey;
          }

          var attributeFilterByActive = layer.attributeFilterByActive || null;
          var mergedAttributeFilter = commonHelpers.mergeFilters(activeKeys, attributeFilterByActive, attributeFilter);
          dispatch(actions$7.useIndexedRegister(componentId, attributeFilterByActive, attributeFilter, null, 1, 2000));
          dispatch(actions$7.ensureIndexed(mergedAttributeFilter, null, 1, 2000)).then(function () {
            /* Ensure data sources */
            var relations = Select.attributeRelations.getIndexed(getState(), attributeFilterByActive, attributeFilter, null, 1, 2000);

            if (relations && relations.length) {
              var filters = relations.map(function (relation) {
                return {
                  attributeDataSourceKey: relation.data && relation.data.attributeDataSourceKey,
                  fidColumnName: relation.data && relation.data.fidColumnName
                };
              });
              var dataSourcesKeys = filters.map(function (filter) {
                return filter.attributeDataSourceKey;
              });
              dispatch(actions$6.useKeys(dataSourcesKeys, componentId)).then(function () {
                var dataSources = Select.attributeDataSources.getByKeys(getState(), dataSourcesKeys);

                if (dataSources) {
                  var dataSourceKeys = [];
                  dataSources.forEach(function (dataSource) {
                    dataSourceKeys.push(dataSource.key);
                  }); // TODO fidColumnName!!!

                  var _filter = {
                    attributeDataSourceKey: {
                      "in": dataSourceKeys
                    },
                    fidColumnName: relations[0].data.fidColumnName
                  };
                  dispatch(actions$4.useIndexed(null, _filter, null, 1, 1, componentId));
                }
              });
            }
          });
        }

        if (layer.styleKey) {
          dispatch(StylesActions.useKeys([layer.styleKey], componentId));
        }
      });
    }
  };
}

function useClear(mapKey) {
  return function (dispatch) {
    dispatch(actions.useIndexedClear(ActionTypes.SPATIAL_RELATIONS)("map_".concat(mapKey)));
    dispatch(actions.useKeysClear(ActionTypes.SPATIAL_DATA_SOURCES)("map_".concat(mapKey)));
    dispatch(actions.useKeysClear(ActionTypes.LAYER_TEMPLATES)("map_".concat(mapKey)));
    dispatch(actions.useKeysClear(ActionTypes.AREAS.AREA_TREE_LEVELS)("map_".concat(mapKey)));
    dispatch(actions.useKeysClear(ActionTypes.STYLES)("map_".concat(mapKey)));
  };
}

function updateStateFromView$3(data) {
  return function (dispatch) {
    if (data) {
      dispatch(actionUpdate(data));
    }
  };
}

function goToPlace(placeString) {
  return function (dispatch, getState) {
    if (placeString && placeString.length) {
      ptrUtils.map.getLocationFromPlaceString(placeString).then(function (location) {
        if (location) {
          var mapKey = Select._deprecatedMaps.getActiveMapKey(getState());

          dispatch(updateMapAndSetView(mapKey, location)); // TODO temporary solution for old map state

          var navigatorUpdate = {
            range: location.boxRange,
            lookAtLocation: {
              latitude: location.center.lat,
              longitude: location.center.lon
            }
          };
          dispatch(deprecated_updateWorldWindNavigator(mapKey, navigatorUpdate)); // TODO deprecated
        }
      });
    }
  };
}
/* ==================================================
 * DEPRECATED CREATORS
 * ================================================== */


function deprecated_use(mapKey, useActiveMetadataKeys) {
  return function (dispatch, getState) {
    var state = getState();

    var layers = Select._deprecatedMaps.getLayersStateByMapKey_deprecated(state, mapKey, useActiveMetadataKeys);

    var backgroundLayer = Select._deprecatedMaps.getBackgroundLayerStateByMapKey_deprecated(state, mapKey);

    var finalLayers = [];

    if (backgroundLayer) {
      finalLayers.push(backgroundLayer);
    }

    if (layers) {
      finalLayers = finalLayers.concat(layers);
    }

    if (finalLayers.length) {
      var componentId = "map_".concat(mapKey);
      finalLayers.forEach(function (filters) {
        //assume, that spatial data dont need period
        var spatialRelationsFilter = _cloneDeep__default['default'](filters.mergedFilter);

        var spatialRelationsFilterByActive = _cloneDeep__default['default'](filters.filterByActive);

        if (spatialRelationsFilter.periodKey) {
          delete spatialRelationsFilter.periodKey;
        }

        if (spatialRelationsFilter.attributeKey) {
          delete spatialRelationsFilter.attributeKey;
        }

        if (spatialRelationsFilterByActive.attribute) {
          delete spatialRelationsFilterByActive.attribute;
        }

        dispatch(SpatialRelationsAction.useIndexedRegister(componentId, spatialRelationsFilterByActive, spatialRelationsFilter, null, 1, 1000));
        dispatch(SpatialRelationsAction.ensureIndexed(spatialRelationsFilter, null, 1, 1000)).then(function () {
          var spatialDataSourcesKeys = Select.spatialRelations.getDataSourceKeysFiltered(getState(), spatialRelationsFilter);

          if (spatialDataSourcesKeys && spatialDataSourcesKeys.length) {
            dispatch(SpatialDataSourcesAction.useKeys([spatialDataSourcesKeys[0]], componentId)).then(function () {
              var dataSource = Select.spatialDataSources.getByKeys(getState(), spatialDataSourcesKeys); //datasource is only one
              //if vector dataSource, then load attribute data

              if (dataSource && dataSource[0] && dataSource[0].data.type === 'vector') {
                var spatialDataSources = Select.spatialRelations.getFilteredData(getState(), spatialRelationsFilter);
                var spatialFilter = {
                  spatialDataSourceKey: dataSource[0].key,
                  fidColumnName: spatialDataSources[0].fidColumnName
                };
                var spatialData = Select.spatialDataSources.vector.getBatchByFilterOrder(getState(), spatialFilter, null); //if data already loaded, skip loading

                if (!spatialData) {
                  dispatch(SpatialDataSourcesAction.vector.loadLayerData(spatialFilter, componentId));
                }

                var attributeFilter = _cloneDeep__default['default'](filters.mergedFilter);

                dispatch(actions$7.useIndexedRegister(componentId, filters.filterByActive, attributeFilter, null, 1, 1000));
                dispatch(actions$7.ensureIndexedSpecific(attributeFilter, null, 1, 1000, componentId));
              }
            });
          }
        })["catch"](function (err) {
          dispatch(actions.actionGeneralError(err));
        }); // TODO register and ensure layer templates
      });
    }
  };
}

var deprecated_useClear = function deprecated_useClear(mapKey) {
  return function (dispatch) {
    dispatch(actions.useIndexedClear(ActionTypes.SPATIAL_RELATIONS)("map_".concat(mapKey)));
  };
};

var deprecated_checkWorldWindNavigatorIntegrity = function deprecated_checkWorldWindNavigatorIntegrity(WorldWindNavigator) {
  if (WorldWindNavigator.heading && WorldWindNavigator.heading > 360) {
    WorldWindNavigator.heading = WorldWindNavigator.heading - 360;
  }

  if (WorldWindNavigator.heading && WorldWindNavigator.heading < -360) {
    WorldWindNavigator.heading = WorldWindNavigator.heading + 360;
  }

  if (WorldWindNavigator.tilt && WorldWindNavigator.tilt < 0) {
    WorldWindNavigator.tilt = 0;
  }

  if (WorldWindNavigator.tilt && WorldWindNavigator.tilt > 90) {
    WorldWindNavigator.tilt = 90;
  }

  return WorldWindNavigator;
};

var deprecated_setMapWorldWindNavigator = function deprecated_setMapWorldWindNavigator(mapKey, worldWindNavigator) {
  return function (dispatch, getState) {
    var state = getState();

    var mapByKey = Select._deprecatedMaps.getMapByKey(state, mapKey);

    if (!mapByKey) {
      return dispatch(actionGeneralError$1("No map found for mapKey ".concat(mapKey, ".")));
    } else {
      return dispatch(deprecated_actionSetMapWorldWindNavigator(mapKey, worldWindNavigator));
    }
  };
};

var deprecated_setSetWorldWindNavigator = function deprecated_setSetWorldWindNavigator(setKey, worldWindNavigator) {
  return function (dispatch, getState) {
    var state = getState();

    var setByKey = Select._deprecatedMaps.getMapSetByKey(state, setKey);

    if (!setByKey) {
      return dispatch(actionGeneralError$1("No set found for setKey ".concat(setKey, ".")));
    } else {
      return dispatch(deprecated_actionSetSetWorldWindNavigator(setKey, worldWindNavigator));
    }
  };
};

var deprecated_updateWorldWindNavigator = function deprecated_updateWorldWindNavigator(mapKey, updates) {
  return function (dispatch, getState) {
    var set = Select._deprecatedMaps.getMapSetByMapKey(getState(), mapKey);

    var forSet = {};
    var forMap = {};

    if (set && set.sync) {
      forSet = _pickBy__default['default'](updates, function (updateVal, updateKey) {
        if (updateKey === 'lookAtLocation') {
          return set.sync['location'];
        } else {
          return set.sync[updateKey];
        }
      });
      forMap = _omitBy__default['default'](updates, function (updateVal, updateKey) {
        if (updateKey === 'lookAtLocation') {
          return set.sync['location'];
        } else {
          return set.sync[updateKey];
        }
      });
    } else {
      forMap = updates;
    }

    if (forSet && !_isEmpty__default['default'](forSet)) {
      //check data integrity
      forSet = deprecated_checkWorldWindNavigatorIntegrity(forSet); //TODO test

      dispatch(deprecated_actionUpdateSetWorldWindNavigator(set.key, forSet));
    }

    if (forMap && !_isEmpty__default['default'](forMap)) {
      //check data integrity
      forMap = deprecated_checkWorldWindNavigatorIntegrity(forMap); //TODO test

      dispatch(deprecated_actionUpdateMapWorldWindNavigator(mapKey, forMap));
    }
  };
};

var deprecated_resetWorldWindNavigatorHeading = function deprecated_resetWorldWindNavigatorHeading(mapKey, defaultIncrement) {
  return function (dispatch, getState) {
    var mapNavigator = Select._deprecatedMaps.getNavigator_deprecated(getState(), mapKey);

    var headingIncrement = 1.0;

    if (Math.abs(mapNavigator.heading) > 60) {
      headingIncrement = 2.0;
    } else if (Math.abs(mapNavigator.heading) > 120) {
      headingIncrement = 3.0;
    } //set shortest direction based on angle


    if (mapNavigator.heading > 0 && mapNavigator.heading < 180 || mapNavigator.heading < 0 && mapNavigator.heading < -180) {
      headingIncrement = -headingIncrement;
    }

    headingIncrement = defaultIncrement || headingIncrement;
    setTimeout(function () {
      var finalHeading;

      if (Math.abs(mapNavigator.heading) > Math.abs(headingIncrement)) {
        finalHeading = mapNavigator.heading + headingIncrement;
        dispatch(deprecated_updateWorldWindNavigator(mapKey, {
          heading: finalHeading
        }));
        dispatch(deprecated_resetWorldWindNavigatorHeading(mapKey, headingIncrement));
      } else {
        finalHeading = 0;
        dispatch(deprecated_updateWorldWindNavigator(mapKey, {
          heading: finalHeading
        }));
      }
    }, 20);
  };
};
/* ==================================================
 * ACTIONS
 * ================================================== */


var actionSetActiveMapKey = function actionSetActiveMapKey(mapKey) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET_ACTIVE_MAP_KEY,
    mapKey: mapKey
  };
};

var actionSetMapSetActiveMapKey = function actionSetMapSetActiveMapKey(setKey, mapKey) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET.SET_ACTIVE_MAP_KEY,
    mapKey: mapKey,
    setKey: setKey
  };
};

var actionSetActiveSetKey = function actionSetActiveSetKey(setKey) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET_ACTIVE_SET_KEY,
    setKey: setKey
  };
};

var actionAddSet = function actionAddSet(set) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET.ADD,
    set: set
  };
};

var actionRemoveSet = function actionRemoveSet(setKey) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET.REMOVE,
    setKey: setKey
  };
};

var actionAddMapToSet = function actionAddMapToSet(setKey, mapKey) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET.ADD_MAP,
    setKey: setKey,
    mapKey: mapKey
  };
};

var actionRemoveMapKeyFromSet = function actionRemoveMapKeyFromSet(setKey, mapKey) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET.REMOVE_MAP,
    setKey: setKey,
    mapKey: mapKey
  };
};

var actionSetSetView = function actionSetSetView(setKey, view) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET.VIEW.SET,
    setKey: setKey,
    view: view
  };
};

var actionUpdateSetView = function actionUpdateSetView(setKey, update) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET.VIEW.UPDATE,
    setKey: setKey,
    update: update
  };
};

var actionSetSetSync = function actionSetSetSync(setKey, sync) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET.SET_SYNC,
    setKey: setKey,
    sync: sync
  };
};

var actionSetSetMaps = function actionSetSetMaps(setKey, maps) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET.SET_MAPS,
    setKey: setKey,
    maps: maps
  };
};

var actionAddMap = function actionAddMap(map) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.MAP.ADD,
    map: map
  };
};

var actionRemoveMap = function actionRemoveMap(mapKey) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.MAP.REMOVE,
    mapKey: mapKey
  };
};

var actionSetMapName = function actionSetMapName(mapKey, name) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.MAP.SET_NAME,
    mapKey: mapKey,
    name: name
  };
};

var actionSetMapData = function actionSetMapData(mapKey, data) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.MAP.SET_DATA,
    mapKey: mapKey,
    data: data
  };
};

var actionSetMapView = function actionSetMapView(mapKey, view) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.MAP.VIEW.SET,
    mapKey: mapKey,
    view: view
  };
};

var actionUpdateMapView = function actionUpdateMapView(mapKey, update) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.MAP.VIEW.UPDATE,
    mapKey: mapKey,
    update: update
  };
};

var actionAddLayer = function actionAddLayer(mapKey, layer, index) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.LAYERS.LAYER.ADD,
    mapKey: mapKey,
    layer: layer,
    index: index
  };
};

var actionRemoveLayer = function actionRemoveLayer(mapKey, layerKey) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.LAYERS.LAYER.REMOVE,
    mapKey: mapKey,
    layerKey: layerKey
  };
};

var actionSetLayerIndex = function actionSetLayerIndex(mapKey, layerKey, index) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.LAYERS.LAYER.SET_INDEX,
    mapKey: mapKey,
    layerKey: layerKey,
    index: index
  };
};

var actionUpdateMapLayer = function actionUpdateMapLayer(mapKey, layerKey, layer) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.LAYERS.LAYER.UPDATE,
    mapKey: mapKey,
    layerKey: layerKey,
    layer: layer
  };
};

var actionSetMapLayer = function actionSetMapLayer(mapKey, layerKey, layer) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.LAYERS.LAYER.SET,
    mapKey: mapKey,
    layerKey: layerKey,
    layer: layer
  };
};

var actionSetMapLayerStyle = function actionSetMapLayerStyle(mapKey, layerKey, style) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.MAP.LAYERS.SET.STYLE,
    mapKey: mapKey,
    layerKey: layerKey,
    style: style
  };
};

var actionSetMapLayerHoveredFeatureKeys = function actionSetMapLayerHoveredFeatureKeys(mapKey, layerKey, hoveredFeatureKeys) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.MAP.LAYERS.SET.HOVERED_FEATURE_KEYS,
    mapKey: mapKey,
    layerKey: layerKey,
    hoveredFeatureKeys: hoveredFeatureKeys
  };
};

var actionSetMapBackgroundLayer = function actionSetMapBackgroundLayer(mapKey, backgroundLayer) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET_BACKGROUND_LAYER,
    mapKey: mapKey,
    backgroundLayer: backgroundLayer
  };
};

var actionSetSetBackgroundLayer = function actionSetSetBackgroundLayer(setKey, backgroundLayer) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET.SET_BACKGROUND_LAYER,
    setKey: setKey,
    backgroundLayer: backgroundLayer
  };
};

var actionSetSetLayers = function actionSetSetLayers(setKey, layers) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET.SET_LAYERS,
    setKey: setKey,
    layers: layers
  };
};

var actionSetMapLayers = function actionSetMapLayers(mapKey, layers) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.LAYERS.SET,
    mapKey: mapKey,
    layers: layers
  };
};

var actionSetMapCase = function actionSetMapCase(mapKey, caseKey) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET_CASE,
    mapKey: mapKey,
    "case": caseKey
  };
};

var actionSetMapScope = function actionSetMapScope(mapKey, scope) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET_SCOPE,
    mapKey: mapKey,
    scope: scope
  };
};

var actionSetMapScenario = function actionSetMapScenario(mapKey, scenario) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET_SCENARIO,
    mapKey: mapKey,
    scenario: scenario
  };
};

var actionSetMapPlace = function actionSetMapPlace(mapKey, place) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET_PLACE,
    mapKey: mapKey,
    place: place
  };
};

var actionSetMapPeriod = function actionSetMapPeriod(mapKey, period) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET_PERIOD,
    mapKey: mapKey,
    period: period
  };
};

var actionUpdate = function actionUpdate(data) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.UPDATE,
    data: data
  };
};
/* ==================================================
 * DEPRECATED ACTIONS
 * ================================================== */


var deprecated_actionSetSetWorldWindNavigator = function deprecated_actionSetSetWorldWindNavigator(setKey, worldWindNavigator) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET.WORLD_WIND_NAVIGATOR.SET,
    setKey: setKey,
    worldWindNavigator: worldWindNavigator
  };
};

var deprecated_actionUpdateSetWorldWindNavigator = function deprecated_actionUpdateSetWorldWindNavigator(setKey, worldWindNavigator) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.SET.WORLD_WIND_NAVIGATOR.UPDATE,
    setKey: setKey,
    worldWindNavigator: worldWindNavigator
  };
};

var deprecated_actionSetMapWorldWindNavigator = function deprecated_actionSetMapWorldWindNavigator(mapKey, worldWindNavigator) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.MAP.WORLD_WIND_NAVIGATOR.SET,
    mapKey: mapKey,
    worldWindNavigator: worldWindNavigator
  };
};

var deprecated_actionUpdateMapWorldWindNavigator = function deprecated_actionUpdateMapWorldWindNavigator(mapKey, worldWindNavigator) {
  return {
    type: ActionTypes._DEPRECATED_MAPS.MAP.WORLD_WIND_NAVIGATOR.UPDATE,
    mapKey: mapKey,
    worldWindNavigator: worldWindNavigator
  };
}; // ============ export ===========
// TODO better naming


var MapsAction = {
  addLayer: addLayer,
  addLayers: addLayers,
  addLayersToMaps: addLayersToMaps,
  // TODO ???
  addMap: addMap,
  addMapForPeriod: addMapForPeriod,
  addMapToSet: addMapToSet,
  addSet: addSet,
  goToPlace: goToPlace,
  removeLayer: removeLayer,
  removeLayers: removeLayers,
  removeMap: removeMap,
  removeMapForPeriod: removeMapForPeriod,
  removeMapKeyFromSet: removeMapKeyFromSet,
  removeSet: removeSet,
  resetViewHeading: resetViewHeading,
  setActiveMapKey: setActiveMapKey,
  setActiveSetKey: setActiveSetKey,
  setLayerHoveredFeatureKeys: setLayerHoveredFeatureKeys,
  setLayerSelectedFeatureKeys: setLayerSelectedFeatureKeys,
  setLayerIndex: setLayerIndex,
  setMapBackgroundLayer: setMapBackgroundLayer,
  setMapCase: setMapCase,
  setMapData: setMapData,
  setMapLayer: setMapLayer,
  setMapLayerStyle: setMapLayerStyle,
  setMapLayers: setMapLayers,
  setMapName: setMapName,
  setMapPeriod: setMapPeriod,
  setMapPlace: setMapPlace,
  setMapScenario: setMapScenario,
  setMapScope: setMapScope,
  setMapView: setMapView,
  setMapSetActiveMapKey: setMapSetActiveMapKey,
  setSetBackgroundLayer: setSetBackgroundLayer,
  setSetLayers: setSetLayers,
  setSetSync: setSetSync,
  setSetView: setSetView,
  setInitial: setInitial,
  updateMapLayer: updateMapLayer,
  updateStateFromView: updateStateFromView$3,
  updateMapAndSetView: updateMapAndSetView,
  updateSetView: updateSetView,
  use: use,
  useClear: useClear,
  // Deprecated
  deprecated_resetWorldWindNavigatorHeading: deprecated_resetWorldWindNavigatorHeading,
  deprecated_setMapWorldWindNavigator: deprecated_setMapWorldWindNavigator,
  deprecated_setSetWorldWindNavigator: deprecated_setSetWorldWindNavigator,
  deprecated_updateWorldWindNavigator: deprecated_updateWorldWindNavigator,
  deprecated_use: deprecated_use,
  deprecated_useClear: deprecated_useClear
};

var add$6 = actions.add(ActionTypes._DEPRECATED_SELECTIONS);
var setActiveKey$4 = actions.setActiveKey(ActionTypes._DEPRECATED_SELECTIONS);

function clearActiveSelection() {
  return function (dispatch, getState) {
    var activeKey = Select._deprecatedSelections.getActiveKey(getState());

    if (activeKey) {
      dispatch(setActiveKey$4(null));
      dispatch(actionRemove([activeKey]));
    }
  };
}

function updateActiveSelection(name, values, areas) {
  return function (dispatch, getState) {
    var active = Select._deprecatedSelections.getActive(getState());

    var data = {
      name: name,
      values: values,
      areas: areas
    };

    if (active) {
      var updated = _objectSpread2(_objectSpread2({}, active), {}, {
        data: _objectSpread2(_objectSpread2({}, active.data), data)
      });

      dispatch(add$6(updated));
    } else {
      dispatch(create$3(data));
    }
  };
}

function create$3(data) {
  return function (dispatch) {
    var selection = {
      key: ptrUtils.utils.uuid(),
      data: data
    };
    dispatch(add$6([selection]));
    dispatch(setActiveKey$4(selection.key));
  };
}

function updateStateFromView$4(data) {
  return function (dispatch) {
    if (data) {
      dispatch(actionUpdate$1(data));
    }
  };
} // ============ actions ===========


function actionRemove(keys) {
  return {
    type: ActionTypes._DEPRECATED_SELECTIONS.REMOVE,
    keys: keys
  };
}

var actionUpdate$1 = function actionUpdate(data) {
  return {
    type: ActionTypes._DEPRECATED_SELECTIONS.UPDATE_FROM_VIEW,
    data: data
  };
};

var _deprecatedSelections$1 = {
  clearActiveSelection: clearActiveSelection,
  updateActiveSelection: updateActiveSelection,
  updateStateFromView: updateStateFromView$4
};

var loadConfiguration = function loadConfiguration() {
  return function (dispatch, getState) {
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    var apiPath = 'backend/rest/applications/filtered/configurations';
    var applicationKey = selectors$3.getKey(getState());
    var payload = {
      filter: {
        applicationKey: applicationKey
      }
    };
    return request(localConfig, apiPath, 'POST', null, payload).then(function (result) {
      if (result.errors && result.errors.configurations || result.data && !result.data.configurations) {
        dispatch(actions.actionGeneralError(result.errors.configurations || new Error('no data')));
      } else if (result.data.configurations.length && result.data.configurations[0].data && result.data.configurations[0].data.data) {
        dispatch(actionReceiveConfiguration(result.data.configurations[0].data.data));
      } else {
        dispatch(actions.actionGeneralError(new Error('empty configuration')));
      }
    })["catch"](function (error) {
      dispatch(actions.actionGeneralError(error));
    });
  };
}; // ============ actions ===========


var actionSetKey = function actionSetKey(key) {
  return {
    type: ActionTypes.APP.SET_KEY,
    key: key
  };
};

var actionSetBaseUrl = function actionSetBaseUrl(url) {
  return {
    type: ActionTypes.APP.SET_BASE_URL,
    url: url
  };
};

var actionSetLocalConfiguration = function actionSetLocalConfiguration(path, value) {
  return {
    type: ActionTypes.APP.SET_LOCAL_CONFIGURATION,
    path: path,
    value: value
  };
};

var actionUpdateLocalConfiguration = function actionUpdateLocalConfiguration(update) {
  return {
    type: ActionTypes.APP.UPDATE_LOCAL_CONFIGURATION,
    update: update
  };
};

var actionReceiveConfiguration = function actionReceiveConfiguration(configuration) {
  return {
    type: ActionTypes.APP.RECEIVE_CONFIGURATION,
    configuration: configuration
  };
}; // ============ export ===========


var actions$8 = {
  add: actionReceiveConfiguration,
  setKey: actionSetKey,
  updateLocalConfiguration: actionUpdateLocalConfiguration,
  setBaseUrl: actionSetBaseUrl,
  setLocalConfiguration: actionSetLocalConfiguration,
  loadConfiguration: loadConfiguration
};

var setActiveKeys = actions.setActiveKeys(ActionTypes.ATTRIBUTE_SETS); // ============ export ===========

var actions$9 = {
  setActiveKeys: setActiveKeys
};

var add$7 = actions.add(ActionTypes.CASES);
var create$4 = actions.create(Select.cases.getSubstate, 'cases', ActionTypes.CASES);
var deleteItem$3 = actions["delete"](Select.cases.getSubstate, 'cases', ActionTypes.CASES);
var saveEdited$3 = actions.saveEdited(Select.cases.getSubstate, 'cases', ActionTypes.CASES);
var updateEdited$3 = actions.updateEdited(Select.cases.getSubstate, ActionTypes.CASES);
var updateStateFromView$5 = actions.updateSubstateFromView(ActionTypes.CASES);
var useKeys$9 = actions.useKeys(Select.cases.getSubstate, 'cases', ActionTypes.CASES);
var useKeysClear$6 = actions.useKeysClear(ActionTypes.CASES);
var useIndexed$a = actions.useIndexed(Select.cases.getSubstate, 'cases', ActionTypes.CASES);
var useIndexedClear$5 = actions.useIndexedClear(ActionTypes.CASES);
var refreshUses$4 = actions.refreshUses(Select.cases.getSubstate, "cases", ActionTypes.CASES);
var setActiveKeyAndEnsureDependencies$2 = actions.setActiveKeyAndEnsureDependencies(ActionTypes.CASES, 'case');
var setActiveKeysAndEnsureDependencies$1 = actions.setActiveKeysAndEnsureDependencies(ActionTypes.CASES, 'case');
var ensureIndexesWithFilterByActive$7 = actions.ensureIndexesWithFilterByActive(Select.cases.getSubstate, 'cases', ActionTypes.CASES);

function setActiveKey$5(key) {
  return function (dispatch) {
    dispatch(setActiveKeyAndEnsureDependencies$2(key));
  };
}

function setActiveKeys$1(keys) {
  return function (dispatch) {
    dispatch(setActiveKeysAndEnsureDependencies$1(keys));
  };
} // ============ actions ===========
// ============ export ===========


var actions$a = {
  add: add$7,
  create: create$4,
  "delete": deleteItem$3,
  ensureIndexesWithFilterByActive: ensureIndexesWithFilterByActive$7,
  refreshUses: refreshUses$4,
  saveEdited: saveEdited$3,
  setActiveKey: setActiveKey$5,
  setActiveKeys: setActiveKeys$1,
  updateEdited: updateEdited$3,
  updateStateFromView: updateStateFromView$5,
  useIndexed: useIndexed$a,
  useIndexedClear: useIndexedClear$5,
  useKeys: useKeys$9,
  useKeysClear: useKeysClear$6
};

var setInitial$1 = actions.setInitial(ActionTypes.CHARTS);

var use$1 = function use(chartKey, useActiveMetadataKeys) {
  return function (dispatch, getState) {
    var chart = Select.charts.getChartConfiguration(getState(), chartKey, useActiveMetadataKeys);
    var componentId = 'chart-' + chartKey;

    if (chart) {
      dispatch(actions$7.useIndexedRegister(componentId, chart.filterByActive, chart.mergedFilter, null, 1, 1000));
      dispatch(actions$7.ensureIndexedSpecific(chart.mergedFilter, null, 1, 1000, componentId));
    }
  };
};

var useClear$1 = function useClear(chartKey) {
  return function (dispatch) {
    dispatch(actions.useIndexedClear(ActionTypes.ATTRIBUTE_RELATIONS)("chart_".concat(chartKey)));
  };
};

var updateStateFromView$6 = function updateStateFromView(data) {
  return function (dispatch) {
    if (data) {
      dispatch(actionUpdate$2(data));
    }
  };
}; // ============ actions ===========


var actionUpdate$2 = function actionUpdate(data) {
  return {
    type: ActionTypes.CHARTS.UPDATE,
    data: data
  };
};

var actions$b = {
  updateStateFromView: updateStateFromView$6,
  use: use$1,
  useClear: useClear$1,
  setInitial: setInitial$1
};

// ============ creators ===========
function update(component, data) {
  return function (dispatch) {
    dispatch(actionUpdate$3(component, data));
  };
}

function updateStateFromView$7(components) {
  return function (dispatch) {
    if (components) {
      // TODO update all store at once
      _forIn__default['default'](components, function (data, component) {
        dispatch(actionUpdate$3(component, data));
      });
    }
  };
} // ============ actions ===========


function actionUpdate$3(component, data) {
  return {
    type: ActionTypes.COMPONENTS.UPDATE,
    component: component,
    update: data
  };
}

function actionSet(component, path, value) {
  return {
    type: ActionTypes.COMPONENTS.SET,
    component: component,
    path: path,
    value: value
  };
} // ============ export ===========


var actions$c = {
  update: update,
  updateStateFromView: updateStateFromView$7,
  set: actionSet
};

var actionTypes$1 = ActionTypes.DATA.ATTRIBUTE_RELATIONS;
var add$8 = actions.add(actionTypes$1);
var addIndex = actions.addIndex(actionTypes$1); // ============ creators ===========

/**
 * It ensure adding index and adding or updating received data from BE.
 * Add relations to state only when attributeRelations received, in case of empty attributeRelations it adds only index.
 * @param {Array} attributeRelations Array received from BE contains attributeRelations.
 * @param {Object} filter Filler object contains modifiers, layerTemplateKey or areaTreeLevelKey and styleKey.
 * @param {Array?} order
 * @param {Number} start
 * @param {Number} total
 * @param {string?} changedOn 
 */

function receiveIndexed$1(attributeRelations, filter, order, start, total, changedOn) {
  return function (dispatch) {
    // add attributeRelations to store
    if (attributeRelations.length) {
      dispatch(add$8(attributeRelations, filter));
    } // add to index


    dispatch(addIndex(filter, order, total, start, attributeRelations, changedOn));
  };
} // ============ actions ============
// ============ export ===========


var attributeRelations$1 = {
  receiveIndexed: receiveIndexed$1
};

var actionTypes$2 = ActionTypes.DATA.ATTRIBUTE_DATA_SOURCES;
var addIndex$1 = actions.addIndex(actionTypes$2);
var add$9 = actions.add(actionTypes$2); // ============ creators ===========

/**
 * It ensure adding index and adding or updating received data from BE.
 * Add dataSources to state only when attributeDataSources received, in case of empty attributeDataSources it adds only index.
 * @param {Array} attributeDataSources Array received from BE contains attributeDataSource definitions.
 * @param {Object} filter Filler object contains modifiers, layerTemplateKey or areaTreeLevelKey and styleKey.
 * @param {Array?} order
 * @param {Number} start
 * @param {Number} total
 * @param {string?} changedOn 
 */

function receiveIndexed$2(attributeDataSources, filter, order, start, total, changedOn) {
  return function (dispatch) {
    // add attributeDataSources to store
    if (attributeDataSources.length) {
      dispatch(add$9(attributeDataSources, filter));
    } // add to index


    dispatch(addIndex$1(filter, order, total, start, attributeDataSources, changedOn));
  };
} // ============ actions ============
// ============ export ===========


var attributeDataSources$1 = {
  add: add$9,
  receiveIndexed: receiveIndexed$2
};

var actionTypes$3 = ActionTypes.DATA.ATTRIBUTE_DATA; // ============ creators ===========

/**
 * It ensure adding index and adding or updating received data from BE.
 * Add data to state only when attributeData received, in case of empty attributeData it adds only index.
 * @param {Object} attributeData Object received from BE contains under attributeDataKey object of data attributes [id]: [value]. 
 * @param {Object} spatialData Object received from BE contains under spatialDataKey object of data attributes [id]: {data, spatialIndex}. 
 * @param {Object} filter Filler object contains modifiers, layerTemplateKey or areaTreeLevelKey and styleKey.
 * @param {Array?} order
 * @param {string?} changedOn 
 */

var receiveIndexed$3 = function receiveIndexed(attributeData, spatialData, filter, order, changedOn) {
  return function (dispatch) {
    if (!_isEmpty__default['default'](attributeData)) {
      dispatch(addDataAndIndex(filter, order, attributeData, spatialData, changedOn));
    } else {
      // add to index
      dispatch(createAndAddIndex(filter, order, attributeData, spatialData, changedOn));
    }
  };
};
/**
 * Add data and index at the same time
 *
 * @param spatialFilter {Object}
 * @param {Object} attributeData Object received from BE contains under attributeDataKey object of data attributes [id]: [value].
 * @param {Object} spatialData Object received from BE contains under spatialDataKey object of data attributes [id]: {data, spatialIndex}
 * @param order {Array}
 * @param changedOn {string}
 */


function addDataAndIndex(spatialFilter, order, attributeData, spatialData, changedOn) {
  return function (dispatch) {
    var indexData = getIndexData(spatialData, attributeData);

    for (var _i = 0, _Object$keys = Object.keys(attributeData); _i < _Object$keys.length; _i++) {
      var attributeDataSourceKey = _Object$keys[_i];
      dispatch(addDataAndIndexAction(attributeDataSourceKey, attributeData[attributeDataSourceKey], spatialFilter, order, [indexData], changedOn));
    }
  };
}
/**
 * Create and add index for given attribute data based on related spatial data index.
 * @param {Object} filter Filler object contains modifiers, layerTemplateKey or areaTreeLevelKey and styleKey.
 * @param {Array?} order
 * @param {Object} attributeData Object received from BE contains under attributeDataKey object of data attributes [id]: [value].
 * @param {Object} spatialData Object received from BE contains under spatialDataKey object of data attributes [id]: {data, spatialIndex}. SpatialData indexes are used as a templete for attribute data indexes.
 * @param {*} changedOn 
 */


function createAndAddIndex(filter, order, attributeData, spatialData, changedOn) {
  var indexByLevelByTileByDataSourceKey = getIndexData(spatialData, attributeData);
  return addIndexAction(filter, order, [indexByLevelByTileByDataSourceKey], changedOn);
}
/**
 * Create new index based on given level and tiles with loading indicator.
 * @param {Object} filter Filler object contains modifiers, layerTemplateKey or areaTreeLevelKey and styleKey.
 * @param {Array?} order
 * @param {Number} level 
 * @param {Array.[Array]} tiles
 */


function addLoadingIndex(filter, order, level, tiles) {
  var changedOn = null; //create index with tiles value "true" that indicates loading state

  var loadingTiles = _reduce__default['default'](tiles, function (acc, tile) {
    var tileId = tileAsString(tile);
    acc[tileId] = true;
    return acc;
  }, {});

  var index = _defineProperty({}, level, loadingTiles);

  return addIndexAction(filter, order, [index], changedOn);
} // ============ helpers ============

/**
 * Get data for indexing
 * @param {Object} spatialData
 * @param {Object} attributeData
 * @return {Object}
 */


function getIndexData(spatialData, attributeData) {
  var indexByLevelByTileByDataSourceKey = {}; //Attribute data indexes are stored in related spatial index
  //for all spatial data keys in spatialData

  for (var _i3 = 0, _Object$entries = Object.entries(spatialData); _i3 < _Object$entries.length; _i3++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2),
        spatialDataSourceKey = _Object$entries$_i[0],
        datasource = _Object$entries$_i[1];

    //for all levels in spatial data source
    for (var _i4 = 0, _Object$entries2 = Object.entries(datasource.spatialIndex); _i4 < _Object$entries2.length; _i4++) {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i4], 2),
          level = _Object$entries2$_i[0],
          tiles = _Object$entries2$_i[1];

      if (!indexByLevelByTileByDataSourceKey[level]) {
        indexByLevelByTileByDataSourceKey[level] = {};
      } //for all tiles in tiles


      for (var _i5 = 0, _Object$entries3 = Object.entries(tiles); _i5 < _Object$entries3.length; _i5++) {
        var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i5], 2),
            tile = _Object$entries3$_i[0],
            tileData = _Object$entries3$_i[1];

        // If empty attributeData, then rewrite "loading" state.
        // or
        // Prepare empty tile for new data if tile does not exists.
        if (!indexByLevelByTileByDataSourceKey[level][tile] || _isEmpty__default['default'](attributeData)) {
          indexByLevelByTileByDataSourceKey[level][tile] = {};
        }

        if (!_isEmpty__default['default'](attributeData)) {
          var _loop = function _loop() {
            var _indexByLevelByTileBy, _indexByLevelByTileBy2;

            var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i6], 2),
                attributeDataSourceKey = _Object$entries4$_i[0],
                attributeDataSource = _Object$entries4$_i[1];

            // Save only tileData that are incuded in attribute data keys
            var indexes = tileData.filter(function (e) {
              return Object.keys(attributeDataSource).includes(e.toString());
            }); //Add to existing index

            if (indexByLevelByTileByDataSourceKey !== null && indexByLevelByTileByDataSourceKey !== void 0 && (_indexByLevelByTileBy = indexByLevelByTileByDataSourceKey[level]) !== null && _indexByLevelByTileBy !== void 0 && (_indexByLevelByTileBy2 = _indexByLevelByTileBy[tile]) !== null && _indexByLevelByTileBy2 !== void 0 && _indexByLevelByTileBy2[attributeDataSourceKey]) {
              indexByLevelByTileByDataSourceKey[level][tile][attributeDataSourceKey] = [].concat(_toConsumableArray(indexByLevelByTileByDataSourceKey[level][tile][attributeDataSourceKey]), _toConsumableArray(indexes));
            } else {
              //Create new tile and insert dsKey index data
              indexByLevelByTileByDataSourceKey[level][tile][attributeDataSourceKey] = indexes;
            }
          };

          //for all attribute data source keys in attributeData
          for (var _i6 = 0, _Object$entries4 = Object.entries(attributeData); _i6 < _Object$entries4.length; _i6++) {
            _loop();
          }
        }
      }
    }
  }

  return indexByLevelByTileByDataSourceKey;
} // ============ actions ============

function removeIndexAction(filter, order) {
  return {
    type: actionTypes$3.INDEX.REMOVE,
    filter: filter,
    order: order
  };
}

function addDataAndIndexAction(attributeDataSourceKey, data, spatialFilter, order, indexData, changedOn) {
  return {
    type: actionTypes$3.ADD_WITH_INDEX,
    attributeDataSourceKey: attributeDataSourceKey,
    data: data,
    spatialFilter: spatialFilter,
    order: order,
    indexData: indexData,
    changedOn: changedOn
  };
}

function addIndexAction(filter, order, index, changedOn) {
  return {
    type: actionTypes$3.INDEX.ADD,
    spatialFilter: filter,
    order: order,
    indexData: index,
    changedOn: changedOn
  };
} // ============ export ===========


var attributeData$1 = {
  addLoadingIndex: addLoadingIndex,
  removeIndex: removeIndexAction,
  receiveIndexed: receiveIndexed$3
};

var actionTypes$4 = ActionTypes.DATA.SPATIAL_RELATIONS;
var addIndex$2 = actions.addIndex(actionTypes$4);
var add$a = actions.add(actionTypes$4); // ============ creators ===========

/**
 * It ensure adding index and adding received spatialRelations from BE.
 * Add relations to state only when spatialRelations received, in case of empty spatialRelations it adds only index.
 * @param {Object} spatialRelations Object received from BE. 
 * @param {Object} filter Filler object contains modifiers and layerTemplateKey or areaTreeLevelKey.
 * @param {Array?} order
 * @param {Number} start
 * @param {Number} total
 * @param {string?} changedOn 
 */

function receiveIndexed$4(spatialRelations, filter, order, start, total, changes) {
  return function (dispatch) {
    // add spatialRelations to store
    // There should be check if relation is already in the store.
    if (spatialRelations.length) {
      dispatch(add$a(spatialRelations, filter));
    } // add to index


    dispatch(addIndex$2(filter, order, total, start, spatialRelations, changes));
  };
} // ============ actions ============
// ============ export ===========


var actions$d = {
  receiveIndexed: receiveIndexed$4
};

var actionTypes$5 = ActionTypes.DATA.SPATIAL_DATA_SOURCES;
var addIndex$3 = actions.addIndex(actionTypes$5);
var add$b = actions.add(actionTypes$5); // ============ creators ===========

/**
 * It ensure adding index and adding received spatialDataSources from BE.
 * Add dataSources to state only when spatialDataSources received, in case of empty spatialDataSources it adds only index.
 * @param {Object} spatialDataSources Object received from BE. 
 * @param {Object} filter Filler object contains modifiers and layerTemplateKey or areaTreeLevelKey.
 * @param {Array?} order
 * @param {Number} start
 * @param {Number} total
 * @param {string?} changedOn 
 */

function receiveIndexed$5(spatialDataSources, filter, order, start, total, changedOn) {
  return function (dispatch) {
    // add spatialDataSources to store
    // There should be check if spatialDataSources is already in the store.
    if (spatialDataSources.length) {
      dispatch(add$b(spatialDataSources, filter));
    } // add to index


    dispatch(addIndex$3(filter, order, total, start, spatialDataSources, changedOn));
  };
} // ============ actions ============
// ============ export ===========


var actions$e = {
  add: add$b,
  receiveIndexed: receiveIndexed$5
};

var actionTypes$6 = ActionTypes.DATA.SPATIAL_DATA; // ============ creators ===========

/**
 * It ensure adding index and adding received data from BE.
 * Add data to state only when spatialData received, in case of empty spatialData it adds only index.
 * @param {Object} spatialData Object received from BE contains under spatialDataKey object of data attributes [id]: {data, spatialIndex}. 
 * @param {Object} filter Filler object contains modifiers and layerTemplateKey or areaTreeLevelKey.
 * @param {Array?} order
 * @param {string?} changedOn 
 */

var receiveIndexed$6 = function receiveIndexed(spatialData, filter, order, changedOn) {
  return function (dispatch) {
    // NEW WAY
    if (spatialData) {
      return dispatch(addDataAndIndex$1(spatialData, filter, order, changedOn));
    } else {
      // add to index
      return dispatch(createAndAddIndex$1(filter, order, spatialData, changedOn));
    }
  };
};
/**
 * Add data and index at the same time
 * Add data, even if data are empty, for replacing loading indicator.
 * @param spatialDataAndIndexByDataSourceKey {Object} [dataSourceKey]: {data: Object, spatialIndex: Object}
 * @param spatialFilter {Object}
 * @param order {Array}
 * @param changedOn {string}
 */


function addDataAndIndex$1(spatialDataAndIndexByDataSourceKey, spatialFilter, order, changedOn) {
  return function (dispatch) {
    var indexByLevelByTileByDataSourceKey = getIndexData$1(spatialDataAndIndexByDataSourceKey); // spatialData should be only from one level

    var level = Object.keys(indexByLevelByTileByDataSourceKey)[0];
    var spatialDataByDataSourceKey = {};

    _forIn__default['default'](spatialDataAndIndexByDataSourceKey, function (value, spatialDataSourceKey) {
      spatialDataByDataSourceKey[spatialDataSourceKey] = value.data;
    });

    dispatch(addDataAndIndexAction$1(spatialDataByDataSourceKey, level, spatialFilter, order, [indexByLevelByTileByDataSourceKey], changedOn)); // for(const dataSourceKey of Object.keys(spatialDataByDataSourceKey)) {
    // 	//spatialData should be only from one level
    // 	const levels = Object.keys(spatialDataByDataSourceKey[dataSourceKey].spatialIndex);
    // 	for (const level of levels) {
    // 		// It dispatch addDataWithIndex for each datasource and level in response with same indexByLevelByTileByDataSourceKey.
    // 		// Multiple datasources in one response is edge case at the moment.
    // 		dispatch(addDataAndIndexAction(dataSourceKey, spatialDataByDataSourceKey[dataSourceKey].data, level, spatialFilter, order, [indexByLevelByTileByDataSourceKey], changedOn));
    // 	}
    // }
  };
}
/**
 * Create and add spatial index based on spatialDataSourceKey, level and tiles.
 * @param {Object} filter Filler object contains modifiers and layerTemplateKey or areaTreeLevelKey.
 * @param {Array?} order
 * @param {Object} spatialData Object received from BE contains under spatialDataKey object of data attributes [id]: {data, spatialIndex}. 
 * @param {string?} changedOn 
 */


function createAndAddIndex$1(filter, order, spatialData, changedOn) {
  var indexByLevelByTileByDataSourceKey = getIndexData$1(spatialData);
  return addIndexAction$1(filter, order, [indexByLevelByTileByDataSourceKey], changedOn);
}
/**
 * Create new index based on given level and tiles with loading indicator.
 * @param {Object} filter Filler object contains modifiers and layerTemplateKey or areaTreeLevelKey.
 * @param {Array?} order
 * @param {Number} level 
 * @param {Array.[Array]} tiles
 */


function addLoadingIndex$1(filter, order, level, tiles) {
  var changedOn = null; //create index with tiles value "true" that indicates loading state

  var loadingTiles = _reduce__default['default'](tiles, function (acc, tile) {
    var tileId = tileAsString(tile);
    acc[tileId] = true;
    return acc;
  }, {});

  var index = _defineProperty({}, level, loadingTiles);

  return addIndexAction$1(filter, order, [index], changedOn);
} // ============ helpers ============

/**
 * Get data for indexing
 * @param spatialDataByDataSourceKey {Object} [dataSourceKey]: {data: Object, spatialIndex: Object}
 * @return {Object}
 */


function getIndexData$1(spatialDataByDataSourceKey) {
  var indexByLevelByTileByDataSourceKey = {};

  for (var _i3 = 0, _Object$entries = Object.entries(spatialDataByDataSourceKey); _i3 < _Object$entries.length; _i3++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2),
        dsKey = _Object$entries$_i[0],
        datasource = _Object$entries$_i[1];

    for (var _i4 = 0, _Object$entries2 = Object.entries(datasource.spatialIndex); _i4 < _Object$entries2.length; _i4++) {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i4], 2),
          level = _Object$entries2$_i[0],
          tiles = _Object$entries2$_i[1];

      if (!indexByLevelByTileByDataSourceKey[level]) {
        indexByLevelByTileByDataSourceKey[level] = {};
      }

      for (var _i5 = 0, _Object$entries3 = Object.entries(tiles); _i5 < _Object$entries3.length; _i5++) {
        var _indexByLevelByTileBy;

        var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i5], 2),
            tile = _Object$entries3$_i[0],
            tileData = _Object$entries3$_i[1];

        //Add to existing index
        if (indexByLevelByTileByDataSourceKey !== null && indexByLevelByTileByDataSourceKey !== void 0 && (_indexByLevelByTileBy = indexByLevelByTileByDataSourceKey[level]) !== null && _indexByLevelByTileBy !== void 0 && _indexByLevelByTileBy[tile]) {
          indexByLevelByTileByDataSourceKey[level][tile] = _objectSpread2(_objectSpread2({}, indexByLevelByTileByDataSourceKey[level][tile]), {}, _defineProperty({}, dsKey, tileData));
        } else {
          //Create new tile and insert dsKey index data
          indexByLevelByTileByDataSourceKey[level][tile] = _defineProperty({}, dsKey, tileData);
        }
      }
    }
  }

  return indexByLevelByTileByDataSourceKey;
} // ============ actions ============


function removeIndexAction$1(filter, order) {
  return {
    type: actionTypes$6.INDEX.REMOVE,
    filter: filter,
    order: order
  };
}

function addDataAndIndexAction$1(dataByDataSourceKey, level, spatialFilter, order, indexData, changedOn) {
  return {
    type: actionTypes$6.ADD_WITH_INDEX,
    dataByDataSourceKey: dataByDataSourceKey,
    level: level,
    spatialFilter: spatialFilter,
    order: order,
    indexData: indexData,
    changedOn: changedOn
  };
}

function addIndexAction$1(filter, order, index, changedOn) {
  return {
    type: actionTypes$6.INDEX.ADD,
    spatialFilter: filter,
    order: order,
    indexData: index,
    changedOn: changedOn
  };
} // ============ export ===========


var actions$f = {
  addLoadingIndex: addLoadingIndex$1,
  removeIndex: removeIndexAction$1,
  receiveIndexed: receiveIndexed$6
};

// Layer data types that supports vector tiling.
// Tiled vectors has spatial and attributes indexes with loading indication.
// TODO 'vector' is only temporary, remove it once it is modified on BE
var TILED_VECTOR_LAYER_TYPES = ['vector', 'tiled-vector'];

var DEFAULT_RELATIONS_PAGE = {
  offset: 0,
  limit: 100
};
/**
 * Central method for getting PAGE_SIZE from state or configDefaults.
 * @param {Object} state App state
 * @return {Number}
 */

var getPageSize = function getPageSize(state) {
  var localConfig = Select.app.getCompleteLocalConfiguration(state);
  var PAGE_SIZE = localConfig.requestPageSize || ptrCore.configDefaults.requestPageSize;
  return PAGE_SIZE;
};

var getRestRelationsPages = function getRestRelationsPages(attributeRelationsCount, spatialRelationsCount, PAGE_SIZE) {
  // What is higer to load? attributeRelations or spatialRelations
  var maxCountValue = Math.max(attributeRelationsCount, spatialRelationsCount);

  if (maxCountValue === 0) {
    return 0;
  } else {
    var remainingPageCount = Math.ceil((maxCountValue - PAGE_SIZE) / PAGE_SIZE);
    return remainingPageCount;
  }
};
/**
 * Helper function. Usually second step in requesting data.
 * Calculate if relations requests are missing based on attributeRelationsCount and spatialRelationsCount.
 * Each relations request loads one next tile from spatialFilter.
 * Rest tiles are loaded without relatiions.
 * @param {bool} loadGeometry Whether response should contain geometry
 * @param {Object} spatialFilter Spatial defined filter of level and its tiles
 * @param {string?} styleKey UUID
 * @param {Array?} order
 * @param {Object} mergedSpatialFilter Filler object contains modifiers and layerTemplateKey or areaTreeLevelKey.
 * @param {Object} mergedAttributeFilter Filler object contains modifiers, layerTemplateKey or areaTreeLevelKey and styleKey.
 * @param {Number} attributeRelationsCount Count of known attribute relations. Used for determinate further requests.
 * @param {Number} spatialRelationsCount Count of known spatial relations. Used for determinate further requests.
 * @param {Array} preloadedSpatialDataSources SpatialDataSources loaded by previous request.
 * @return {function} Return promise. 
 */


function loadMissingRelationsAndData(loadGeometry, spatialFilter, styleKey, order, mergedSpatialFilter, mergedAttributeFilter, attributeRelationsCount, spatialRelationsCount) {
  var preloadedSpatialDataSources = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];
  return function (dispatch, getState) {
    var PAGE_SIZE = getPageSize(getState()); // FIXME - add attributeFilter support
    // attributeFilter is null at the moment

    var attributeFilter = null;
    var dataSourceKeys = null;
    var featureKeys = null;
    var promises = []; // load remaining relations pages

    var remainingRelationsPageCount = getRestRelationsPages(attributeRelationsCount, spatialRelationsCount, PAGE_SIZE);
    var tilesPagination = 0;
    var loadRelations = true;

    for (var i = 1; i <= remainingRelationsPageCount; i++) {
      var relations = {
        offset: i * PAGE_SIZE,
        limit: PAGE_SIZE
      };
      tilesPagination = i;
      var spatialIndex = {
        tiles: [spatialFilter.tiles[tilesPagination]]
      };
      promises.push(dispatch(loadIndexedPage$1(styleKey, relations, featureKeys, spatialIndex, spatialFilter, attributeFilter, loadGeometry, loadRelations, dataSourceKeys, order, mergedSpatialFilter, mergedAttributeFilter)));
    } // 
    //load rest of tiles
    // 


    var remainingTilesPageCount = spatialFilter.tiles.length; //first tile was loaded before loadMissingRelationsAndData first request

    for (var _i = tilesPagination + 1; _i < remainingTilesPageCount; _i++) {
      var _spatialIndex = {
        tiles: [spatialFilter.tiles[_i]]
      };
      var _relations = {};
      var loadRestTilesRelations = false;
      promises.push(dispatch(loadIndexedPage$1(styleKey, _relations, featureKeys, _spatialIndex, spatialFilter, attributeFilter, loadGeometry, loadRestTilesRelations, dataSourceKeys, order, mergedSpatialFilter, mergedAttributeFilter)));
    }

    return Promise.all(promises).then(function () {
      var response = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      // All relations are loaded at this moment. 
      // Check if all spatialDataSources relations from response and preloadedSpatialDataSources are type of "unsupported" like raster/wms/wmts.
      // If all spatialDataSources are unsupported, then received data are empty and indexes needs to be removed.
      // If only some of spatialDataSources relations are unsupported, then loading status on index will be replaced by data.
      var spatialDataSourcesTypes = _.flattenDeep(response.map(function (r) {
        var _r$data, _r$data$spatialDataSo;

        return r === null || r === void 0 ? void 0 : (_r$data = r.data) === null || _r$data === void 0 ? void 0 : (_r$data$spatialDataSo = _r$data.spatialDataSources) === null || _r$data$spatialDataSo === void 0 ? void 0 : _r$data$spatialDataSo.map(function (sds) {
          return {
            type: sds.data.type,
            key: sds.key
          };
        });
      }));

      var spatialDataSourcesPairs = [].concat(_toConsumableArray(spatialDataSourcesTypes), _toConsumableArray(preloadedSpatialDataSources));
      var allSourcesAreUnsupported = spatialDataSourcesPairs.every(function (ds) {
        return !TILED_VECTOR_LAYER_TYPES.includes(ds.type);
      }); // Check if all of returned spatialDataSources are unsupported type.
      // Indexes for unsupported layers can be cleared.

      if (allSourcesAreUnsupported) {
        // AttributeData and spatialData index represented by mergedSpatialFilter, mergedAttributeFilter and order can be deleted
        dispatch(actions$f.removeIndex(mergedSpatialFilter, order));
        dispatch(attributeData$1.removeIndex(mergedAttributeFilter, order));
      }
    });
  };
}
/**
 * Ensure load missing attribute data for tiles defined in spatialFilter that are not loaded or loading in state.
 * 
 * @param {Object} spatialFilter Spatial defined filter of level and its tiles
 * @param {string?} styleKey UUID
 * @param {Array?} order
 * @param {Object} mergedSpatialFilter Filler object contains modifiers and layerTemplateKey or areaTreeLevelKey.
 * @param {Object} mergedAttributeFilter Filler object contains modifiers, layerTemplateKey or areaTreeLevelKey and styleKey.
 * @return {function}
 */


function loadMissingAttributeData(spatialFilter, styleKey, order, mergedSpatialFilter, mergedAttributeFilter) {
  return function (dispatch, getState) {
    var PAGE_SIZE = getPageSize(getState());
    var relations = {
      // start: 0,
      // length: 1000,
      offset: 0,
      limit: PAGE_SIZE
    }; //
    // which attribute data to load
    //
    //get attribute data index with loaded and loading data

    var attributeDataIndex = Select.data.attributeData.getIndex(getState(), "spatialIndexes", mergedAttributeFilter, order) || []; //diff loaded attribute data from index with wanted spatial data

    var missingAttributeDataTiles = getMissingTiles(attributeDataIndex, spatialFilter) || [];
    var missingAttributeDataTilesAsArrays = missingAttributeDataTiles.map(tileAsArray); // Load relations and data sources in first request if they are not already loaded.

    var attributeRelations = Select.data.attributeRelations.getIndex(getState(), mergedAttributeFilter, order);
    var attributeDataSources = Select.data.attributeDataSources.getIndex(getState(), mergedAttributeFilter, order);
    var loadRelationsAndDS = !(!_.isEmpty(attributeRelations) && !_.isEmpty(attributeDataSources)); //load only attribute data

    var loadGeometry = false; //FIXME - add support for attributeFilter

    var attributeFilter = null;
    var dataSourceKeys = null;
    var featureKeys = null; // Modified spatial filter with only missing attribute data tiles

    var spatialFilterWithMissingTiles = _objectSpread2(_objectSpread2({}, spatialFilter), {}, {
      tiles: missingAttributeDataTilesAsArrays
    }); // Relations for given filters are missing


    if (loadRelationsAndDS) {
      var spatialIndex = null;
      var loadRelations = true; // Load relations 

      return dispatch(loadIndexedPage$1(styleKey, relations, featureKeys, spatialIndex, spatialFilterWithMissingTiles, attributeFilter, loadGeometry, loadRelations, dataSourceKeys, order, mergedSpatialFilter, mergedAttributeFilter)).then(function (response) {
        var _response$data;

        if (response instanceof Error) {
          return;
        }

        var spatialDataSources = (response === null || response === void 0 ? void 0 : (_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.spatialDataSources) || [];
        var preloadSpatialDataSources = spatialDataSources.map(function (sds) {
          return {
            type: sds.data.type,
            key: sds.key
          };
        });
        var attributeRelationsCount = response.total.attributeRelations;
        var spatialRelationsCount = response.total.spatialRelations;
        return dispatch(loadMissingRelationsAndData(loadGeometry, spatialFilterWithMissingTiles, styleKey, order, mergedSpatialFilter, mergedAttributeFilter, attributeRelationsCount, spatialRelationsCount, preloadSpatialDataSources));
      });
    } else {
      var promises = [];
      var _loadRelations = false;

      var _iterator = _createForOfIteratorHelper(missingAttributeDataTiles),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var tile = _step.value;
          var _spatialIndex2 = {
            tiles: [tile]
          };
          promises.push(dispatch(loadIndexedPage$1(styleKey, relations, featureKeys, _spatialIndex2, spatialFilter, attributeFilter, loadGeometry, _loadRelations, dataSourceKeys, order, mergedSpatialFilter, mergedAttributeFilter)));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return Promise.all(promises);
    }
  };
}
/**
 * Ensure load missing spatial data for tiles defined in spatialFilter that are not loaded or loading in state.
 * @param {Object} spatialFilter Spatial defined filter of level and its tiles
 * @param {string?} styleKey UUID
 * @param {Array?} order
 * @param {Object} mergedSpatialFilter Filler object contains modifiers and layerTemplateKey or areaTreeLevelKey.
 * @param {Object} mergedAttributeFilter Filler object contains modifiers, layerTemplateKey or areaTreeLevelKey and styleKey.
 * @return {function}
 */


function loadMissingSpatialData(spatialFilter, styleKey, order, mergedSpatialFilter, mergedAttributeFilter) {
  return function (dispatch, getState) {
    //
    //which spatial data to load
    //
    //get spatial data index with loaded and loading data
    var spatialDataIndex = Select.data.spatialData.getIndex(getState(), mergedSpatialFilter, order) || []; //diff spatial data loaded/loading and to load

    var missingSpatialDataTiles = getMissingTiles(spatialDataIndex, spatialFilter) || [];
    var promises = [];

    var _iterator2 = _createForOfIteratorHelper(missingSpatialDataTiles),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var tile = _step2.value;
        var spatialIndex = {
          tiles: [tile]
        };
        var relations = {};
        var attributeFilter = null;
        var loadGeometry = true;
        var loadRelations = false;
        var dataSourceKeys = null;
        var featureKeys = null;
        promises.push(dispatch(loadIndexedPage$1(styleKey, relations, featureKeys, spatialIndex, spatialFilter, attributeFilter, loadGeometry, loadRelations, dataSourceKeys, order, mergedSpatialFilter, mergedAttributeFilter)));
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return Promise.all(promises);
  };
}
/**
 * Ensure load spatial data, attribute data and relations for tiles defined in spatialFilter.
 * @param {Object} spatialFilter Spatial defined filter of level and its tiles
 * @param {string?} styleKey UUID
 * @param {Array?} order
 * @param {Object} mergedSpatialFilter Filler object contains modifiers and layerTemplateKey or areaTreeLevelKey.
 * @param {Object} mergedAttributeFilter Filler object contains modifiers, layerTemplateKey or areaTreeLevelKey and styleKey.
 * @return {function}
 */


function ensureDataAndRelations(spatialFilter, styleKey, order, mergedSpatialFilter, mergedAttributeFilter) {
  return function (dispatch, getState) {
    var PAGE_SIZE = getPageSize(getState());
    var relations = {
      // start: 0,
      // length: 1000,
      offset: 0,
      limit: PAGE_SIZE
    }; // FIXME - add attributeFilter support
    // attributeFilter is null at the moment

    var attributeFilter = null;
    var loadGeometry = true;
    var loadRelations = true;
    var dataSourceKeys = null;
    var featureKeys = null;
    var spatialIndex = null;

    if (spatialFilter && !_.isEmpty(spatialFilter)) {
      return dispatch(loadIndexedPage$1(styleKey, relations, featureKeys, spatialIndex, spatialFilter, attributeFilter, loadGeometry, loadRelations, dataSourceKeys, order, mergedSpatialFilter, mergedAttributeFilter)).then(function (response) {
        var _response$data2;

        if (response instanceof Error) {
          return;
        }

        var attributeRelationsCount = response.total.attributeRelations;
        var spatialRelationsCount = response.total.spatialRelations;
        var restRelationsPages = getRestRelationsPages(attributeRelationsCount, spatialRelationsCount, PAGE_SIZE);
        var spatialDataSources = (response === null || response === void 0 ? void 0 : (_response$data2 = response.data) === null || _response$data2 === void 0 ? void 0 : _response$data2.spatialDataSources) || [];
        var preloadSpatialDataSources = spatialDataSources.map(function (sds) {
          return {
            type: sds.data.type,
            key: sds.key
          };
        });
        var allSourcesAreUnsupported = spatialDataSources.every(function (ds) {
          var _ds$data;

          return !TILED_VECTOR_LAYER_TYPES.includes((_ds$data = ds.data) === null || _ds$data === void 0 ? void 0 : _ds$data.type);
        }); // Check if all of returned spatialDataSources are unsupported type.
        // If so, is no reason to make further requests.
        // Indexes for unsupported layers can be cleared.

        if (restRelationsPages === 0 && allSourcesAreUnsupported) {
          // AttributeData and spatialData index represented by mergedSpatialFilter, mergedAttributeFilter and order can be deleted
          dispatch(actions$f.removeIndex(mergedSpatialFilter, order));
          dispatch(attributeData$1.removeIndex(mergedAttributeFilter, order));
          return;
        } else {
          return dispatch(loadMissingRelationsAndData(loadGeometry, spatialFilter, styleKey, order, mergedSpatialFilter, mergedAttributeFilter, attributeRelationsCount, spatialRelationsCount, preloadSpatialDataSources));
        }
      })["catch"](function (err) {
        if ((err === null || err === void 0 ? void 0 : err.message) === 'Index outdated') {
          dispatch(refreshIndex(getSubstate, dataType, filter, order, actionTypes, categoryPath));
        } else {
          throw new Error("data/actions#ensure: ".concat(err));
        }
      });
    } else {
      return dispatch(actions.actionGeneralError(new Error('Missing spatial filter')));
    }
  };
}
/**
 * Find out all tiles from spatialFilter without loaded attribute data
 * @param {Object} attributeDataIndex 
 * @param {Object} spatialFilter Spatial defined filter of level and its tiles
 */


var hasMissingAttributesData = function hasMissingAttributesData(attributeDataIndex, spatialFilter) {
  var missingAttributeDataTiles = getMissingTiles(attributeDataIndex, spatialFilter) || spatialFilter.tiles;
  return missingAttributeDataTiles && missingAttributeDataTiles.length && missingAttributeDataTiles.length > 0 ? true : false;
};
/**
 * Find out all tiles from spatialFilter without loaded attribute data
 * @param {Object} spatialDataIndex 
 * @param {Object} spatialFilter Spatial defined filter of level and its tiles
 */


var hasMissingSpatialData = function hasMissingSpatialData(spatialDataIndex, spatialFilter) {
  var missingSpatialDataTiles = getMissingTiles(spatialDataIndex, spatialFilter) || spatialFilter.tiles;
  return missingSpatialDataTiles && missingSpatialDataTiles.length && missingSpatialDataTiles.length > 0 ? true : false;
};
/**
 * It find out if for given ltKey/atlKey and mergedSpatialFilter exists relations index.
 * The Existence of index means it is loading or loaded.
 * TODO - add support of areaTrees
 * @param {Object} state App state object
 * @param {string?} areaTreeLevelKey Optional area tree key
 * @param {string?} layerTemplateKey Optional layer template key
 * @param {Object} mergedSpatialFilter Filler object contains modifiers and layerTemplateKey or areaTreeLevelKey.
 * @param {Array} order 
 * @return {bool}
 */


var hasSpatialOrAreaRelations = function hasSpatialOrAreaRelations(state, areaTreeLevelKey, layerTemplateKey, mergedSpatialFilter, order) {
  var spatialRelationsIndex = null;
  var areaRelationsIndex = null;

  if (layerTemplateKey) {
    spatialRelationsIndex = Select.data.spatialRelations.getIndex(state, mergedSpatialFilter, order);
  } // FIXME - add support for areaTreeLevels

  return spatialRelationsIndex !== null || areaRelationsIndex !== null;
};
/**
 * Entry function for requesting of loading new data. In first step are identified loaded indexes based on filters.
 * Next phase is request only data that are missing.
 * @param filter {Object}
 * @return {function}
 */


function ensure(filter) {
  return function (dispatch, getState) {
    // Filter params - see Panther docs: Code/API/Data endpoint
    var styleKey = filter.styleKey,
        data = filter.data,
        mergedFilter = filter.mergedFilter;
    var spatialFilter = data.spatialFilter;
    var areaTreeLevelKey = mergedFilter.areaTreeLevelKey,
        layerTemplateKey = mergedFilter.layerTemplateKey;
    var mergedSpatialFilter = mergedFilter;

    var mergedAttributeFilter = _objectSpread2(_objectSpread2({}, mergedFilter), {}, {
      styleKey: styleKey
    }); // select indexes


    var order = null;
    var spatialDataIndex = Select.data.spatialData.getIndex(getState(), mergedSpatialFilter, order) || [];
    var attributeDataIndex = Select.data.attributeData.getIndex(getState(), "spatialIndexes", mergedAttributeFilter, order) || [];
    var missingAttributesData = hasMissingAttributesData(attributeDataIndex, spatialFilter);
    var missingSpatialData = hasMissingSpatialData(spatialDataIndex, spatialFilter);
    var filterHasSpatialOrAreaRelations = hasSpatialOrAreaRelations(getState(), areaTreeLevelKey, layerTemplateKey, mergedSpatialFilter, order); // 
    // Skip over load request on already loaded/loading data
    // 

    if (!filterHasSpatialOrAreaRelations && missingSpatialData) {
      return dispatch(ensureDataAndRelations(spatialFilter, styleKey, order, mergedSpatialFilter, mergedAttributeFilter));
    }

    if (missingSpatialData) {
      return dispatch(loadMissingSpatialData(spatialFilter, styleKey, order, mergedSpatialFilter, mergedAttributeFilter));
    }

    if (missingAttributesData) {
      return dispatch(loadMissingAttributeData(spatialFilter, styleKey, order, mergedSpatialFilter, mergedAttributeFilter));
    }
  };
}
/**
 * 
 * @param {string?} styleKey 
 * @param {Object?} relations Pagination for relations.
 * @param {Array?} featureKeys Array of feature keys that should be loaded.
 * @param {Object?} spatialIndex Object where under "tiles" key is array of tiles that should be loaded.
 * @param {Object} spatialFilter Spatial defined filter of level and its tiles
 * @param {Object?} attributeFilter Filter for requested attribute data.
 * @param {bool} loadGeometry Whether response should contain geometry
 * @param {bool} loadRelations Whether response should contain relations
 * @param {Array?} dataSourceKeys Another optional filter parameter. Possible to use insted of layerTemplateKey or areaTreeKey
 * @param {Array?} order 
 * @param {Object} mergedSpatialFilter Filler object contains modifiers and layerTemplateKey or areaTreeLevelKey.
 * @param {Object} mergedAttributeFilter Filler object contains modifiers, layerTemplateKey or areaTreeLevelKey and styleKey.
 */


function loadIndexedPage$1(styleKey, relations, featureKeys, spatialIndex, spatialFilter, attributeFilter, loadGeometry, loadRelations, dataSourceKeys, order, mergedSpatialFilter, mergedAttributeFilter) {
  return function (dispatch, getState) {
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    var apiPath = 'backend/rest/data/filtered';

    var areaTreeLevelKey = mergedSpatialFilter.areaTreeLevelKey,
        layerTemplateKey = mergedSpatialFilter.layerTemplateKey,
        modifiers = _objectWithoutProperties(mergedSpatialFilter, ["areaTreeLevelKey", "layerTemplateKey"]);

    var usedRelations = relations ? _objectSpread2({}, relations) : DEFAULT_RELATIONS_PAGE; //register indexes
    ////
    // Spatial
    ////

    if (loadGeometry) {
      var loadingTilesGeometry = (spatialIndex === null || spatialIndex === void 0 ? void 0 : spatialIndex.tiles) || spatialFilter.tiles;
      dispatch(actions$f.addLoadingIndex(mergedSpatialFilter, order, spatialFilter.level, loadingTilesGeometry));
    } ////
    // Attribute
    ////


    var loadingTilesAttributes = (spatialIndex === null || spatialIndex === void 0 ? void 0 : spatialIndex.tiles) || spatialFilter.tiles;
    dispatch(attributeData$1.addLoadingIndex(mergedAttributeFilter, order, spatialFilter.level, loadingTilesAttributes)); // Create payload

    var payload = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({
      modifiers: modifiers
    }, layerTemplateKey && {
      layerTemplateKey: layerTemplateKey
    }), areaTreeLevelKey && {
      areaTreeLevelKey: areaTreeLevelKey
    }), styleKey && {
      styleKey: styleKey
    }), {}, {
      // pagination for relations (& data sources)
      relations: usedRelations,
      data: _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, featureKeys && {
        featureKeys: featureKeys
      }), spatialIndex && {
        spatialIndex: spatialIndex
      }), {}, {
        // extent
        spatialFilter: spatialFilter
      }, attributeFilter && {
        attributeFilter: attributeFilter
      }), {}, {
        //request for geometry
        geometry: !!loadGeometry,
        //request for relations
        relations: !!loadRelations
      }, dataSourceKeys && {
        dataSourceKeys: dataSourceKeys
      })
    });

    return request(localConfig, apiPath, 'POST', null, payload).then(function (result) {
      if (result.errors) {
        throw new Error(result.errors[dataType] || 'no data');
      } else {
        if (result.data) {
          ////
          // Attributes
          ////
          if (!!loadRelations && result.data.attributeRelations && !_.isEmpty(result.data.attributeRelations)) {
            var changes = null;
            dispatch(attributeRelations$1.receiveIndexed(result.data.attributeRelations, mergedAttributeFilter, order, relations.offset, result.total.attributeRelations, changes));
          }

          if (!!loadRelations && result.data.attributeDataSources && !_.isEmpty(result.data.attributeDataSources)) {
            var _changes = null;
            dispatch(attributeDataSources$1.receiveIndexed(result.data.attributeDataSources, mergedAttributeFilter, order, relations.offset, result.total.attributeRelations, _changes));
          }

          if (result.data.spatialData && result.data.attributeData) {
            var _changes2 = null;
            dispatch(attributeData$1.receiveIndexed(result.data.attributeData, result.data.spatialData, mergedAttributeFilter, order, _changes2));
          } ////
          // Spatial data
          ////


          if (!!loadRelations && result.data.spatialRelations && !_.isEmpty(result.data.spatialRelations)) {
            var _changes3 = null;
            dispatch(actions$d.receiveIndexed(result.data.spatialRelations, mergedSpatialFilter, order, relations.offset, result.total.spatialRelations, _changes3));
          }

          if (!!loadRelations && result.data.spatialDataSources && !_.isEmpty(result.data.spatialDataSources)) {
            var _changes4 = null;
            dispatch(actions$e.receiveIndexed(result.data.spatialDataSources, mergedSpatialFilter, order, relations.offset, result.total.spatialRelations, _changes4));
          }

          if (!!loadGeometry) {
            // Add data even if data are empty.
            // Override loading indicator in state index    
            var _changes5 = null;
            dispatch(actions$f.receiveIndexed(result.data.spatialData, mergedSpatialFilter, order, _changes5));
          }

          return result;
        } else {
          var error = new Error('no data');
          dispatch(actions.actionGeneralError(error));
          return error;
        }
      }
    })["catch"](function (error) {
      dispatch(actions.actionGeneralError(error));
      return error; //todo do we need to return this
    });
  };
}

var DataActions = {
  attributeData: attributeData$1,
  attributeDataSources: attributeDataSources$1,
  attributeRelations: attributeRelations$1,
  spatialData: actions$f,
  spatialDataSources: actions$e,
  spatialRelations: actions$d,
  ensure: ensure,
  //todo TESTS
  loadMissingSpatialData: loadMissingSpatialData,
  //todo TESTS
  ensureDataAndRelations: ensureDataAndRelations //todo TESTS

};

var TTL$1 = 3; // ============ creators ===========

function loadForAoiLayer(aoi, wmsLayer, ttl) {
  if (_isUndefined__default['default'](ttl)) ttl = TTL$1;
  return function (dispatch, getState) {
    var state = getState();
    var apiBackendProtocol = Select.app.getLocalConfiguration(state, 'apiBackendProtocol');
    var apiBackendHost = Select.app.getLocalConfiguration(state, 'apiBackendHost');
    var apiBackendPath = Select.app.getLocalConfiguration(state, 'apiBackendPath');
    var apiBackendAoiLayerPeriodsPath = Select.app.getLocalConfiguration(state, 'apiBackendAoiLayerPeriodsPath');

    if (!_isObject__default['default'](aoi)) {
      aoi = _find__default['default'](Select.aoi.getAois(getState()), {
        key: aoi
      });
    }

    if (!_isObject__default['default'](wmsLayer)) {
      wmsLayer = _find__default['default'](getState().wmsLayers.data, {
        key: wmsLayer
      });
    }

    dispatch(actionLoadForAoiRequest(aoi.key, wmsLayer.key));
    var url = apiBackendProtocol + '://' + path__default['default'].join(apiBackendHost, apiBackendPath, apiBackendAoiLayerPeriodsPath);
    var body = {
      data: {
        geometry: aoi.geometry,
        layerName: wmsLayer.layerName
      }
    };
    return fetch__default['default'](url, {
      method: 'POST',
      body: JSON.stringify(body),
      headers: {
        'content-type': 'application/json'
      }
    }).then(function (response) {
      console.log('#### LayerPeriods receive', response);

      if (response.ok) {
        response.json().then(function (data) {
          if (data) {
            dispatch(actionLoadForAoiLayerReceive(aoi.key, wmsLayer.key, data.dates));
          } else {
            dispatch(actionloadForAoiLayerError(aoi.key, wmsLayer.key, 'no data returned'));
          }
        })["catch"](function (err) {
          if (ttl - 1) {
            loadForAoiLayer(aoi, wmsLayer, ttl - 1);
          }
        });
      } else {
        dispatch(actionloadForAoiLayerError(aoi.key, wmsLayer.key, response));
      }
    });
  };
}

function loadForPlaceLayer(place, wmsLayer, ttl) {
  if (_isUndefined__default['default'](ttl)) ttl = TTL$1;
  return function (dispatch, getState) {
    var state = getState();
    var apiBackendProtocol = Select.app.getLocalConfiguration(state, 'apiBackendProtocol');
    var apiBackendHost = Select.app.getLocalConfiguration(state, 'apiBackendHost');
    var apiBackendPath = Select.app.getLocalConfiguration(state, 'apiBackendPath');
    var apiBackendAoiLayerPeriodsPath = Select.app.getLocalConfiguration(state, 'apiBackendAoiLayerPeriodsPath');

    if (!_isObject__default['default'](place)) {
      place = _find__default['default'](Select.places.getPlaces(getState()), {
        key: place
      });
    }

    if (!_isObject__default['default'](wmsLayer)) {
      wmsLayer = _find__default['default'](getState().wmsLayers.data, {
        key: wmsLayer
      });
    }

    dispatch(actionLoadForPlaceRequest(place.key, wmsLayer.key));
    var url = apiBackendProtocol + '://' + path__default['default'].join(apiBackendHost, apiBackendPath, apiBackendAoiLayerPeriodsPath);
    var body = {
      data: {
        geometry: place.geometry,
        layerName: wmsLayer.layerName
      }
    };
    return fetch__default['default'](url, {
      method: 'POST',
      body: JSON.stringify(body),
      headers: {
        'content-type': 'application/json'
      }
    }).then(function (response) {
      console.log('#### LayerPeriods receive', response);

      if (response.ok) {
        response.json().then(function (data) {
          if (data) {
            dispatch(actionLoadForPlaceLayerReceive(place.key, wmsLayer.key, data.dates));
          } else {
            dispatch(actionLoadForPlaceLayerError(place.key, wmsLayer.key, 'no data returned'));
          }
        })["catch"](function (err) {
          if (ttl - 1) {
            loadForPlaceLayer(place, wmsLayer, ttl - 1);
          }
        });
      } else {
        dispatch(actionLoadForPlaceLayerError(place.key, wmsLayer.key, response));
      }
    });
  };
}

function loadForKeyLayer(key, geometry, wmsLayer, ttl) {
  if (_isUndefined__default['default'](ttl)) ttl = TTL$1;
  return function (dispatch, getState) {
    var state = getState();
    var localConfig = Select.app.getCompleteLocalConfiguration(state);

    if (!_isObject__default['default'](wmsLayer)) {
      wmsLayer = _find__default['default'](state.wmsLayers.data, {
        key: wmsLayer
      });
    }

    dispatch(actionLoadForKeyLayerRequest(key, geometry, wmsLayer.key));
    var url = localConfig.apiBackendProtocol + '://' + path__default['default'].join(localConfig.apiBackendHost, localConfig.apiBackendPath, localConfig.apiBackendAoiLayerPeriodsPath);
    var body = {
      data: {
        geometry: geometry,
        layerName: wmsLayer.layerName
      }
    };
    return fetch__default['default'](url, {
      method: 'POST',
      body: JSON.stringify(body),
      headers: {
        'content-type': 'application/json'
      }
    }).then(function (response) {
      console.log('#### LayerPeriods receive', response);

      if (response.ok) {
        response.json().then(function (data) {
          if (data) {
            dispatch(actionLoadForKeyLayerReceive(key, geometry, wmsLayer.key, data.dates));
          } else {
            dispatch(actionLoadForKeyLayerError(key, geometry, wmsLayer.key, 'no data returned'));
          }
        })["catch"](function (err) {
          if (ttl - 1) {
            loadForKeyLayer(key, geometry, wmsLayer, ttl - 1);
          }
        });
      } else {
        dispatch(actionLoadForKeyLayerError(key, geometry, wmsLayer.key, response));
      }
    });
  };
}

function loadForAoi(aoiKey) {
  return function (dispatch, getState) {
    var state = getState();

    var aoi = _find__default['default'](Select.aoi.getAois(state), {
      key: aoiKey
    });

    _each__default['default'](state.wmsLayers.data, function (wmsLayer) {
      if (wmsLayer.getDates) dispatch(loadForAoiLayer(aoi, wmsLayer));
    });
  };
}

function loadForPlace(placeKey) {
  return function (dispatch, getState) {
    var state = getState();

    var place = _find__default['default'](Select.places.getPlaces(state), {
      key: placeKey
    });

    if (place && place.geometry) {
      _each__default['default'](state.wmsLayers.data, function (wmsLayer) {
        if (wmsLayer.getDates) dispatch(loadForPlaceLayer(place, wmsLayer));
      });
    }
  };
}

function loadForKey(key, geometry) {
  return function (dispatch, getState) {
    var state = getState();
    var layers = Select.wmsLayers.getLayersWithGetDate(state);

    _each__default['default'](layers, function (wmsLayer) {
      dispatch(loadForKeyLayer(key, geometry, wmsLayer));
    });
  };
} //function loadReceive(features, aoiLayer) {
//	return dispatch => {
//		features = _.map(features, feature => {
//			return {
//				key: feature.properties[aoiLayer.fidColumn || 'fid'],
//				code: feature.properties[aoiLayer.idColumn]
//			};
//		});
//		dispatch(actionLoadReceive(features));
//	};
//}
// ============ actions ===========


function actionLoadForAoiRequest(aoiKey, layerKey) {
  return {
    type: ActionTypes.LAYER_PERIODS_AOI_LAYER_REQUEST,
    aoiKey: aoiKey,
    layerKey: layerKey
  };
}

function actionLoadForAoiLayerReceive(aoiKey, layerKey, periods) {
  return {
    type: ActionTypes.LAYER_PERIODS_AOI_LAYER_RECEIVE,
    aoiKey: aoiKey,
    layerKey: layerKey,
    periods: periods
  };
}

function actionloadForAoiLayerError(aoiKey, layerKey, error) {
  return {
    type: ActionTypes.LAYER_PERIODS_AOI_LAYER_REQUEST_ERROR,
    aoiKey: aoiKey,
    layerKey: layerKey,
    error: error
  };
}

function actionLoadForPlaceRequest(placeKey, layerKey) {
  return {
    type: ActionTypes.LAYER_PERIODS_PLACE_LAYER_REQUEST,
    placeKey: placeKey,
    layerKey: layerKey
  };
}

function actionLoadForPlaceLayerReceive(placeKey, layerKey, periods) {
  return {
    type: ActionTypes.LAYER_PERIODS_PLACE_LAYER_RECEIVE,
    placeKey: placeKey,
    layerKey: layerKey,
    periods: periods
  };
}

function actionLoadForPlaceLayerError(placeKey, layerKey, error) {
  return {
    type: ActionTypes.LAYER_PERIODS_PLACE_LAYER_REQUEST_ERROR,
    placeKey: placeKey,
    layerKey: layerKey,
    error: error
  };
}

function actionLoadForKeyLayerRequest(key, geometry, layerKey) {
  return {
    type: ActionTypes.LAYER_PERIODS_KEY_LAYER_REQUEST,
    key: key,
    geometry: geometry,
    layerKey: layerKey
  };
}

function actionLoadForKeyLayerReceive(key, geometry, layerKey, periods) {
  return {
    type: ActionTypes.LAYER_PERIODS_KEY_LAYER_RECEIVE,
    key: key,
    geometry: geometry,
    layerKey: layerKey,
    periods: periods
  };
}

function actionLoadForKeyLayerError(key, geometry, layerKey, error) {
  return {
    type: ActionTypes.LAYER_PERIODS_KEY_LAYER_REQUEST_ERROR,
    key: key,
    geometry: geometry,
    layerKey: layerKey,
    error: error
  };
} // ============ export ===========


var LayerPeriods = {
  loadForAoi: loadForAoi,
  loadForPlace: loadForPlace,
  loadForKey: loadForKey
};

var create$5 = actions.create(Select.layerTrees.getSubstate, 'layerTrees', ActionTypes.LAYER_TREES, 'applications');
var deleteItem$4 = actions["delete"](Select.layerTrees.getSubstate, 'layerTrees', ActionTypes.LAYER_TREES, 'applications');
var saveEdited$4 = actions.saveEdited(Select.layerTrees.getSubstate, 'layerTrees', ActionTypes.LAYER_TREES, 'applications');
var updateEdited$4 = actions.updateEdited(Select.layerTrees.getSubstate, ActionTypes.LAYER_TREES);
var useKeys$a = actions.useKeys(Select.layerTrees.getSubstate, 'layerTrees', ActionTypes.LAYER_TREES, 'applications');
var useKeysClear$7 = actions.useKeysClear(ActionTypes.LAYER_TREES);
var useIndexedClear$6 = actions.useIndexedClear(ActionTypes.LAYER_TREES);
var useIndexed$b = actions.useIndexed(Select.layerTrees.getSubstate, 'layerTrees', ActionTypes.LAYER_TREES, 'applications');
var refreshUses$5 = actions.refreshUses(Select.layerTrees.getSubstate, 'layerTrees', ActionTypes.LAYER_TREES, 'applications');
var updateStateFromView$8 = actions.updateSubstateFromView(ActionTypes.LAYER_TREES); // ============ actions ===========

function ensureData(filter, componentId) {
  return function (dispatch) {
    return dispatch(useIndexed$b(null, filter, null, 1, 100, componentId)).then();
  };
} // ============ export ===========


var LayerTrees$1 = {
  create: create$5,
  "delete": deleteItem$4,
  ensureData: ensureData,
  refreshUses: refreshUses$5,
  saveEdited: saveEdited$4,
  updateEdited: updateEdited$4,
  updateStateFromView: updateStateFromView$8,
  useIndexed: useIndexed$b,
  useIndexedClear: useIndexedClear$6,
  useKeys: useKeys$a,
  useKeysClear: useKeysClear$7
};

/* ==================================================
 * CREATORS
 * ================================================== */

/**
 * @param mapKey {string}
 * @param backgroundLayer {Object} background layer definition
 * @param layers {Object} layers definition
 * @param mapWidth {number} width of map component in px
 * @param mapHeight {number} height of map component in px
 */

function use$2(mapKey, backgroundLayer, layers, mapWidth, mapHeight) {
  return function (dispatch, getState) {
    // TODO clear use for given mapKey, if exists
    var state = getState();
    var componentId = "map_".concat(mapKey);
    var spatialFilter = {};

    if (mapWidth && mapHeight) {
      var view = Select.maps.getViewByMapKey(state, mapKey);
      var tiles = selectorHelpers.getTiles(mapWidth, mapHeight, view.center, view.boxRange);
      var level = selectorHelpers.getZoomLevel(mapWidth, mapHeight, view.boxRange);
      spatialFilter.tiles = tiles;
      spatialFilter.level = level;
    } else {
      //spatial filter is required
      return;
    }

    var activeKeys = commonSelectors.getAllActiveKeys(state); // uncontrolled map - the map is not controlled from store, but layer data is collected based on stored metadata.

    if (backgroundLayer || layers) {
      layers = selectorHelpers.mergeBackgroundLayerWithLayers(layers, backgroundLayer);
    } // controlled map (with stateMapKey) - the map is completely controlled from store
    else {
        layers = Select.maps.getAllLayersStateByMapKey(state, mapKey);
      }

    if (layers) {
      layers.forEach(function (layer) {
        return (// apply layerUse asynchronous on each leyer
          // it cause better FPS and prevent long synchronous tasks
          setTimeout(function () {
            dispatch(layerUse(componentId, activeKeys, layer, spatialFilter));
          }, 0)
        );
      });
    }
  };
}
/**
 * @param componentId {string}
 * @param activeKeys {Object} active metadata keys (such as activeApplicationKey, activeScopeKey etc.)
 * @param layerState {Object} layer definition
 * @param spatialFilter {{level: number}, {tiles: Array}}
 */


function layerUse(componentId, activeKeys, layerState, spatialFilter) {
  return function (dispatch, getState) {
    var state = getState(); // TODO ensure style here for now

    if (layerState.styleKey) {
      dispatch(StylesActions.useKeys([layerState.styleKey], layerState.key + "_layerUse"));
    } // modifiers defined by key


    var metadataDefinedByKey = layerState.metadataModifiers ? _objectSpread2({}, layerState.metadataModifiers) : {}; // add layerTemplate od areaTreeLevelKey

    if (layerState.layerTemplateKey) {
      metadataDefinedByKey.layerTemplateKey = layerState.layerTemplateKey; // TODO use layerTemplate here?
    } else if (layerState.areaTreeLevelKey) {
      metadataDefinedByKey.areaTreeLevelKey = layerState.areaTreeLevelKey; // TODO use areaTreeLevelKey here?
    } // Get actual metadata keys defined by filterByActive


    var activeMetadataKeys = layerState.filterByActive ? commonSelectors.getActiveKeysByFilterByActive(state, layerState.filterByActive) : null; // Merge metadata, metadata defined by key have priority

    var mergedMetadataKeys = commonHelpers.mergeMetadataKeys(metadataDefinedByKey, activeMetadataKeys); // Decouple modifiers from templates

    var areaTreeLevelKey = mergedMetadataKeys.areaTreeLevelKey,
        layerTemplateKey = mergedMetadataKeys.layerTemplateKey,
        applicationKey = mergedMetadataKeys.applicationKey,
        modifiers = _objectWithoutProperties(mergedMetadataKeys, ["areaTreeLevelKey", "layerTemplateKey", "applicationKey"]); // It converts modifiers from metadataKeys: ["A", "B"] to metadataKey: {in: ["A", "B"]}


    var modifiersForRequest = commonHelpers.convertModifiersToRequestFriendlyFormat(modifiers);

    if (layerTemplateKey || areaTreeLevelKey) {
      var mergedFilter = {};

      if (areaTreeLevelKey) {
        mergedFilter = _objectSpread2(_objectSpread2({}, modifiersForRequest), {}, {
          areaTreeLevelKey: areaTreeLevelKey
        });
      }

      if (layerTemplateKey) {
        mergedFilter = _objectSpread2(_objectSpread2({}, modifiersForRequest), {}, {
          layerTemplateKey: layerTemplateKey
        });
      }

      if (layerTemplateKey) {
        var order = null;
        var spatialDataSources = Select.data.spatialDataSources.getByFilteredIndex(state, mergedFilter, order);
        var sdsContainsVector = (spatialDataSources === null || spatialDataSources === void 0 ? void 0 : spatialDataSources.some(function (spatialDataSource) {
          var _spatialDataSource$da;

          return TILED_VECTOR_LAYER_TYPES.includes(spatialDataSource === null || spatialDataSource === void 0 ? void 0 : (_spatialDataSource$da = spatialDataSource.data) === null || _spatialDataSource$da === void 0 ? void 0 : _spatialDataSource$da.type);
        })) || false; // load only dataSources that are supported type

        if (spatialDataSources && !sdsContainsVector) {
          return;
        }
      } // TODO register use?


      dispatch(DataActions.ensure({
        styleKey: layerState.styleKey || null,
        data: {
          spatialFilter: spatialFilter
        },
        mergedFilter: mergedFilter
      }));
    }
  };
}
/**
 * @param mapKey {string}
 * @param layerKey {string}
 * @param selectedFeatureKeys {Array}
 */


function setLayerSelectedFeatureKeys$1(mapKey, layerKey, selectedFeatureKeys) {
  return function (dispatch, getState) {
    var _layer$options;

    var state = getState();
    var layer = Select.maps.getLayerStateByLayerKeyAndMapKey(state, mapKey, layerKey);

    if (layer !== null && layer !== void 0 && (_layer$options = layer.options) !== null && _layer$options !== void 0 && _layer$options.selectable) {
      var _layer$options$select;

      var activeSelectionKey = Select.selections.getActiveKey(state);

      if (activeSelectionKey && (_layer$options$select = layer.options.selected) !== null && _layer$options$select !== void 0 && _layer$options$select.hasOwnProperty(activeSelectionKey)) {
        // TODO possible conflicts if features with same key from different layers are selected
        dispatch(SelectionsAction.setActiveSelectionFeatureKeysFilterKeys(selectedFeatureKeys));
      }
    }
  };
}
/**
 * @param mapKey {string}
 * @param layerKey {string}
 * @param styleKey {string}
 */


function setMapLayerStyleKey(mapKey, layerKey, styleKey) {
  return function (dispatch) {
    dispatch(actionSetMapLayerStyleKey(mapKey, layerKey, styleKey));
  };
}
/**
 * @param mapKey {string}
 */


function setMapSetActiveMapKey$1(mapKey) {
  return function (dispatch, getState) {
    var set = Select.maps.getMapSetByMapKey(getState(), mapKey);

    if (set) {
      dispatch(actionSetMapSetActiveMapKey$1(set.key, mapKey));
    }
  };
}
/**
 * @param setKey {string}
 * @param backgroundLayer {Object} background layer definition
 */


function setMapSetBackgroundLayer(setKey, backgroundLayer) {
  return function (dispatch, getState) {
    dispatch(actionSetMapSetBackgroundLayer(setKey, backgroundLayer));
    var maps = Select.maps.getMapSetMaps(getState(), setKey);

    if (maps) {
      maps.forEach(function (map) {
        var _map$data, _map$data$viewport, _map$data2, _map$data2$viewport;

        // TODO is viewport always defined?
        dispatch(use$2(map.key, null, null, map === null || map === void 0 ? void 0 : (_map$data = map.data) === null || _map$data === void 0 ? void 0 : (_map$data$viewport = _map$data.viewport) === null || _map$data$viewport === void 0 ? void 0 : _map$data$viewport.width, map === null || map === void 0 ? void 0 : (_map$data2 = map.data) === null || _map$data2 === void 0 ? void 0 : (_map$data2$viewport = _map$data2.viewport) === null || _map$data2$viewport === void 0 ? void 0 : _map$data2$viewport.height));
      });
    }
  };
}
/**
 * @param setKey {string}
 */


function refreshMapSetUse(setKey) {
  return function (dispatch, getState) {
    var maps = Select.maps.getMapSetMaps(getState(), setKey);

    if (maps) {
      maps.forEach(function (map) {
        var _map$data3, _map$data3$viewport, _map$data4, _map$data4$viewport;

        // TODO is viewport always defined?
        dispatch(use$2(map.key, null, null, map === null || map === void 0 ? void 0 : (_map$data3 = map.data) === null || _map$data3 === void 0 ? void 0 : (_map$data3$viewport = _map$data3.viewport) === null || _map$data3$viewport === void 0 ? void 0 : _map$data3$viewport.width, map === null || map === void 0 ? void 0 : (_map$data4 = map.data) === null || _map$data4 === void 0 ? void 0 : (_map$data4$viewport = _map$data4.viewport) === null || _map$data4$viewport === void 0 ? void 0 : _map$data4$viewport.height));
      });
    }
  };
}
/**
 * @param mapKey {string}
 * @param update {Object} map view fragment
 */


function updateMapAndSetView$1(mapKey, update) {
  return function (dispatch, getState) {
    var set = Select.maps.getMapSetByMapKey(getState(), mapKey);
    var forSet, forMap;

    if (set && set.sync) {
      // pick key-value pairs that are synced for set
      forSet = _pickBy__default['default'](update, function (updateVal, updateKey) {
        return set.sync[updateKey];
      });
      forMap = _omitBy__default['default'](update, function (updateVal, updateKey) {
        return set.sync[updateKey];
      });
    } else {
      forMap = update;
    }

    if (forSet && !_isEmpty__default['default'](forSet)) {
      //check data integrity
      forSet = ptrUtils.map.view.ensureViewIntegrity(forSet); //TODO test

      dispatch(actionUpdateSetView$1(set.key, forSet));
    }

    if (forMap && !_isEmpty__default['default'](forMap)) {
      //check data integrity
      forMap = ptrUtils.map.view.ensureViewIntegrity(forMap); //TODO test

      dispatch(actionUpdateMapView$1(mapKey, forMap));
    }
  };
}
/**
 * @param setKey {string}
 * @param update {Object} map view fragment
 */


function updateSetView$1(setKey, update) {
  return function (dispatch, getState) {
    var activeMapKey = Select.maps.getMapSetActiveMapKey(getState(), setKey);
    dispatch(updateMapAndSetView$1(activeMapKey, update));
  };
}
/**
 * Update whole maps state from view definition
 * @param data {Object}
 */


function updateStateFromView$9(data) {
  return function (dispatch) {
    if (data) {
      dispatch(actionUpdate$4(data));
    }
  };
}
/* ==================================================
 * ACTIONS
 * ================================================== */


var actionSetMapLayerStyleKey = function actionSetMapLayerStyleKey(mapKey, layerKey, styleKey) {
  return {
    type: ActionTypes.MAPS.MAP.LAYERS.SET_STYLE_KEY,
    mapKey: mapKey,
    layerKey: layerKey,
    styleKey: styleKey
  };
};

var actionSetMapSetActiveMapKey$1 = function actionSetMapSetActiveMapKey(setKey, mapKey) {
  return {
    type: ActionTypes.MAPS.SET.SET_ACTIVE_MAP_KEY,
    mapKey: mapKey,
    setKey: setKey
  };
};

var actionSetMapSetBackgroundLayer = function actionSetMapSetBackgroundLayer(setKey, backgroundLayer) {
  return {
    type: ActionTypes.MAPS.SET.SET_BACKGROUND_LAYER,
    setKey: setKey,
    backgroundLayer: backgroundLayer
  };
};

var actionSetMapViewport = function actionSetMapViewport(mapKey, width, height) {
  return {
    type: ActionTypes.MAPS.MAP.VIEWPORT.SET,
    mapKey: mapKey,
    width: width,
    height: height
  };
};

var actionUpdate$4 = function actionUpdate(data) {
  return {
    type: ActionTypes.MAPS.UPDATE,
    data: data
  };
};

var actionUpdateMapView$1 = function actionUpdateMapView(mapKey, update) {
  return {
    type: ActionTypes.MAPS.MAP.VIEW.UPDATE,
    mapKey: mapKey,
    update: update
  };
};

var actionUpdateSetView$1 = function actionUpdateSetView(setKey, update) {
  return {
    type: ActionTypes.MAPS.SET.VIEW.UPDATE,
    setKey: setKey,
    update: update
  };
}; // ============ export ===========


var Maps$1 = {
  refreshMapSetUse: refreshMapSetUse,
  setLayerSelectedFeatureKeys: setLayerSelectedFeatureKeys$1,
  setMapLayerStyleKey: setMapLayerStyleKey,
  setMapSetActiveMapKey: setMapSetActiveMapKey$1,
  setMapSetBackgroundLayer: setMapSetBackgroundLayer,
  setMapViewport: actionSetMapViewport,
  updateMapAndSetView: updateMapAndSetView$1,
  updateSetView: updateSetView$1,
  updateStateFromView: updateStateFromView$9,
  use: use$2
};

var add$c = actions.add(ActionTypes.PERIODS);
var create$6 = actions.create(Select.periods.getSubstate, 'periods', ActionTypes.PERIODS);
var deleteItem$5 = actions["delete"](Select.periods.getSubstate, 'periods', ActionTypes.PERIODS);
var saveEdited$5 = actions.saveEdited(Select.periods.getSubstate, 'periods', ActionTypes.PERIODS);
var updateEdited$5 = actions.updateEdited(Select.periods.getSubstate, ActionTypes.PERIODS);
var updateStateFromView$a = actions.updateSubstateFromView(ActionTypes.PERIODS);
var useKeys$b = actions.useKeys(Select.periods.getSubstate, 'periods', ActionTypes.PERIODS);
var useKeysClear$8 = actions.useKeysClear(ActionTypes.PERIODS);
var useIndexed$c = actions.useIndexed(Select.periods.getSubstate, 'periods', ActionTypes.PERIODS);
var useIndexedClear$7 = actions.useIndexedClear(ActionTypes.PERIODS);
var refreshUses$6 = actions.refreshUses(Select.periods.getSubstate, "periods", ActionTypes.PERIODS);
var setActiveKeyAndEnsureDependencies$3 = actions.setActiveKeyAndEnsureDependencies(ActionTypes.PERIODS, 'period');
var setActiveKeysAndEnsureDependencies$2 = actions.setActiveKeysAndEnsureDependencies(ActionTypes.PERIODS, 'period');
var ensureIndexesWithFilterByActive$8 = actions.ensureIndexesWithFilterByActive(Select.periods.getSubstate, 'periods', ActionTypes.PERIODS);

function setActiveKey$6(key) {
  return function (dispatch) {
    dispatch(setActiveKeyAndEnsureDependencies$3(key));
  };
}

function setActiveKeys$2(keys) {
  return function (dispatch) {
    dispatch(setActiveKeysAndEnsureDependencies$2(keys));
  };
} // ============ actions ===========
// ============ export ===========


var PeriodsAction = {
  add: add$c,
  create: create$6,
  "delete": deleteItem$5,
  ensureIndexesWithFilterByActive: ensureIndexesWithFilterByActive$8,
  refreshUses: refreshUses$6,
  saveEdited: saveEdited$5,
  setActiveKey: setActiveKey$6,
  setActiveKeys: setActiveKeys$2,
  updateEdited: updateEdited$5,
  updateStateFromView: updateStateFromView$a,
  useIndexed: useIndexed$c,
  useIndexedClear: useIndexedClear$7,
  useKeys: useKeys$b,
  useKeysClear: useKeysClear$8
};

var add$d = actions.add(ActionTypes.PLACES);
var create$7 = actions.create(Select.places.getSubstate, 'places', ActionTypes.PLACES);
var deleteItem$6 = actions["delete"](Select.places.getSubstate, 'places', ActionTypes.PLACES);
var saveEdited$6 = actions.saveEdited(Select.places.getSubstate, 'places', ActionTypes.PLACES);
var setActiveKey$7 = actions.setActiveKey(ActionTypes.PLACES);
var setActiveKeys$3 = actions.setActiveKeys(ActionTypes.PLACES);
var updateEdited$6 = actions.updateEdited(Select.places.getSubstate, ActionTypes.PLACES);
var updateStateFromView$b = actions.updateSubstateFromView(ActionTypes.PLACES);
var useIndexed$d = actions.useIndexed(Select.places.getSubstate, 'places', ActionTypes.PLACES);
var useIndexedClear$8 = actions.useIndexedClear(ActionTypes.PLACES);
var useKeys$c = actions.useKeys(Select.places.getSubstate, 'places', ActionTypes.PLACES);
var useKeysClear$9 = actions.useKeysClear(ActionTypes.PLACES);
var refreshUses$7 = actions.refreshUses(Select.places.getSubstate, "places", ActionTypes.PLACES);
var ensureIndexesWithFilterByActive$9 = actions.ensureIndexesWithFilterByActive(Select.places.getSubstate, 'places', ActionTypes.PLACES); // ============ export ===========

var PlacesAction = {
  add: add$d,
  create: create$7,
  "delete": deleteItem$6,
  ensureIndexesWithFilterByActive: ensureIndexesWithFilterByActive$9,
  refreshUses: refreshUses$7,
  saveEdited: saveEdited$6,
  setActiveKey: setActiveKey$7,
  setActiveKeys: setActiveKeys$3,
  updateEdited: updateEdited$6,
  updateStateFromView: updateStateFromView$b,
  useIndexed: useIndexed$d,
  useIndexedClear: useIndexedClear$8,
  useKeys: useKeys$c,
  useKeysClear: useKeysClear$9
};

var requestIntervals = {};
var TTL$2 = 5; // ============ creators ===========

var add$e = actions.add(ActionTypes.SCENARIOS);
var updateStateFromView$c = actions.updateSubstateFromView(ActionTypes.SCENARIOS); // Edited data

function addEditedScenario(key, options) {
  return function (dispatch, getState) {
    var activeCaseScenarioKeys = Select.scenarios.cases.getActiveCaseScenarioKeys(getState());
    var activeCaseEditedScenarioKeys = Select.scenarios.cases.getActiveCaseEditedScenarioKeys(getState());
    var updatedScenarioKeys = activeCaseEditedScenarioKeys ? [].concat(_toConsumableArray(activeCaseEditedScenarioKeys), [key]) : activeCaseScenarioKeys ? [].concat(_toConsumableArray(activeCaseScenarioKeys), [key]) : [key];
    dispatch(actionUpdateEditedScenarios([_objectSpread2({
      key: key
    }, options)]));
    dispatch(updateEditedActiveCase('scenarios', updatedScenarioKeys));
  };
}
/**
 * It removes edited scenarios for active case
 */


function removeActiveCaseEditedScenarios() {
  return function (dispatch, getState) {
    var activeCaseScenarioKeys = Select.scenarios.cases.getActiveCaseScenarioKeys(getState());
    var activeCaseEditedScenarioKeys = Select.scenarios.cases.getActiveCaseEditedScenarioKeys(getState());
    var keys = [];

    if (activeCaseScenarioKeys) {
      keys = [].concat(_toConsumableArray(keys), _toConsumableArray(activeCaseScenarioKeys));
    }

    if (activeCaseEditedScenarioKeys) {
      keys = [].concat(_toConsumableArray(keys), _toConsumableArray(activeCaseEditedScenarioKeys));
    }

    dispatch(actionRemoveEditedScenarios(keys));
  };
}

function updateEditedActiveCase(key, value) {
  return function (dispatch, getState) {
    var state = getState();
    var activeCaseKey = Select.scenarios.cases.getActiveKey(state);
    var activeCase = Select.scenarios.cases.getActive(state);
    var sameValue = false;

    if (activeCase && activeCase.data) {
      if ((key === 'geometry' || key === 'scenarios') && activeCase.data[key]) {
        var val = _cloneDeep__default['default'](activeCase.data[key]);

        sameValue = JSON.stringify(value) === JSON.stringify(val);
      }

      if (sameValue || value === activeCase.data[key] || !activeCase.data[key] && value.length === 0) {
        dispatch(actionRemovePropertyFromEditedCase(activeCaseKey, key));
      } else {
        dispatch(actionUpdateEditedCases([{
          key: activeCaseKey,
          data: _defineProperty({}, key, value)
        }]));
      }
    } else {
      dispatch(actionUpdateEditedCases([{
        key: activeCaseKey,
        data: _defineProperty({}, key, value)
      }]));
    }
  };
} // it just remove scenario from active case (if it isn't last). Todo unlinking and delete scenario


function removeScenarioFromActiveCase(scenarioKey) {
  return function (dispatch, getState) {
    var activeCase = Select.scenarios.cases.getActive(getState());

    if (activeCase && activeCase.data && activeCase.data.scenarios) {
      var updatedScenarios = _without__default['default'](activeCase.data.scenarios, scenarioKey);

      var updatedCase = _objectSpread2(_objectSpread2({}, activeCase), {}, {
        data: _objectSpread2(_objectSpread2({}, activeCase.data), {}, {
          scenarios: updatedScenarios
        })
      });

      dispatch(removeActiveScenario(scenarioKey));
      dispatch(apiUpdateCases([updatedCase], []));
    }
  };
}

function removeScenarioFromActiveCaseEdited(scenarioKey) {
  return function (dispatch, getState) {
    var activeCaseEdited = Select.scenarios.cases.getActiveCaseEdited(getState());

    if (activeCaseEdited && activeCaseEdited.data && activeCaseEdited.data.scenarios) {
      var updatedScenarios = _without__default['default'](activeCaseEdited.data.scenarios, scenarioKey);

      dispatch(updateEditedActiveCase('scenarios', updatedScenarios));
    }
  };
}

function updateEditedScenario(scenarioKey, key, value) {
  return function (dispatch, getState) {
    var state = getState();
    var scenario = Select.scenarios.scenarios.getByKey(state, scenarioKey);
    var activeCaseKey = Select.scenarios.cases.getActiveKey(state);
    var activeCaseScenarioKeys = Select.scenarios.cases.getActiveCaseScenarioKeys(state);
    var activeCaseEditedScenarioKeys = Select.scenarios.cases.getActiveCaseEditedScenarioKeys(state);
    var updatedScenarioKeys = [];

    if (activeCaseScenarioKeys) {
      updatedScenarioKeys = _union__default['default'](updatedScenarioKeys, activeCaseScenarioKeys);
    }

    if (activeCaseEditedScenarioKeys) {
      updatedScenarioKeys = _union__default['default'](updatedScenarioKeys, activeCaseEditedScenarioKeys);
    } // delete property from edited, if the value in update is the same as in state


    if (scenario && (value === scenario.data[key] || !scenario.data[key] && value.length === 0)) {
      dispatch(actionRemovePropertyFromEditedScenario(scenarioKey, key));
    } else {
      dispatch(actionUpdateEditedCases([{
        key: activeCaseKey,
        data: {
          scenarios: updatedScenarioKeys
        }
      }]));
      dispatch(actionUpdateEditedScenarios([{
        key: scenarioKey,
        data: _defineProperty({}, key, value)
      }]));
    }
  };
}

function setActiveCase(key) {
  return function (dispatch, getState) {
    var previousCase = Select.scenarios.cases.getActiveKey(getState());
    dispatch(actionSetActiveCase(key));

    if (key) {
      var scenarios = Select.scenarios.cases.getActiveCaseScenarioKeys(getState());

      if (key !== previousCase) {
        dispatch(actionSetActiveKeys$1(scenarios));
      }
    } else {
      dispatch(actionSetActiveKeys$1(null));
    }
  };
}

function addActiveScenario(key) {
  return function (dispatch, getState) {
    var activeScenarioKeys = Select.scenarios.scenarios.getActiveKeys(getState());

    var stateUpdate = _union__default['default'](activeScenarioKeys, [key]);

    dispatch(actionSetActiveKeys$1(stateUpdate));
  };
}

function removeActiveScenario(key) {
  return function (dispatch, getState) {
    var activeScenarioKeys = Select.scenarios.scenarios.getActiveKeys(getState());

    var stateUpdate = _without__default['default'](activeScenarioKeys, key);

    dispatch(actionSetActiveKeys$1(stateUpdate));
  };
}

function applyDataviewSettings(data) {
  return function (dispatch, getState) {
    dispatch(setActiveCase(data.cases.activeKey));
    dispatch(load(data.cases.activeKey));
    dispatch(actionSetActiveKeys$1(data.scenarios.activeKeys));
    dispatch(actionSetDefaultSituationActive(data.scenarios.defaultSituationActive));
  };
}

function updateCases(data) {
  return function (dispatch) {
    dispatch(actionUpdateCases(data));
  };
}

function removeCases(keys) {
  return function (dispatch, getState) {
    dispatch(actionRemoveCases(keys));
  };
}

function load(caseKey) {
  return function (dispatch, getState) {
    var state = getState();
    var localConfig = Select.app.getCompleteLocalConfiguration(state);

    if (state.scenarios.loading) ; else {
      dispatch(actionLoadRequest(caseKey));
      var query = {
        scenario_case_id: caseKey
      };
      dispatch(actions.request(localConfig, 'backend/rest/metadata/scenarios', "GET", query, null, loadReceive, actionLoadError));
    }
  };
}

function loadReceive(data) {
  //todo cancel loading for caseKey?
  data = data.scenarios ? data.scenarios : data;
  return function (dispatch) {
    if (data) {
      data = _map__default['default'](data, function (_ref) {
        var id = _ref.id,
            model = _objectWithoutProperties(_ref, ["id"]);

        return _objectSpread2(_objectSpread2({}, model), {}, {
          key: id
        });
      });
      dispatch(actionLoadReceive(data));
      dispatch(scenariosLoadedForActiveCase());
    } else {
      console.error("Scenarios actions#loadReceive: No scenarios loaded"); // TODO
    }
  };
}

function scenariosLoadedForActiveCase() {
  return function (dispatch, getState) {
    var activeCase = Select.scenarios.cases.getActive(getState());

    if (activeCase) {
      var updatedCase = _objectSpread2(_objectSpread2({}, activeCase), {}, {
        data: _objectSpread2(_objectSpread2({}, activeCase.data), {}, {
          scenariosLoaded: true
        })
      });

      dispatch(updateCases([updatedCase]));
      dispatch(MapsAction.updateWithScenarios());
    }
  };
}

function loadCases(ttl) {
  if (_isUndefined__default['default'](ttl)) ttl = TTL$2;
  return function (dispatch, getState) {
    var state = getState();
    var localConfig = Select.app.getCompleteLocalConfiguration(state);

    if (state.scenarios.loading) ; else {
      dispatch(actionLoadCasesRequest());
      var activePlaceKey = Select.places.getActiveKey(state);

      if (activePlaceKey) {
        var url = localConfig.apiBackendProtocol + '://' + path__default['default'].join(localConfig.apiBackendHost, localConfig.apiBackendPath, 'backend/rest/metadata/scenario_cases');
        var query = queryString__default['default'].stringify({
          place_id: activePlaceKey
        });

        if (query) {
          url += '?' + query;
        }

        return fetch__default['default'](url, {
          method: 'GET',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          }
        }).then(function (response) {
          console.log('#### load scenarios cases response', response);
          var contentType = response.headers.get('Content-type');

          if (response.ok && contentType && contentType.indexOf('application/json') !== -1) {
            return response.json().then(function (data) {
              if (data.data && data.data.scenario_cases) {
                dispatch(loadCasesReceive(data.data.scenario_cases));
              } else {
                dispatch(actionLoadCasesError('no data returned'));
              }
            });
          } else {
            dispatch(actionLoadCasesError(response));
          }
        }, function (error) {
          console.log('#### load scenario cases error', error);

          if (ttl - 1) {
            dispatch(loadCases(ttl - 1));
          } else {
            dispatch(actionLoadCasesError("scenarios#actions load cases: cases weren't loaded!"));
          }
        });
      } else {
        dispatch(actionLoadCasesError('scenarios#actions load cases: no active place'));
      }
    }
  };
}

function loadCasesReceive(models) {
  return function (dispatch) {
    models = _map__default['default'](models, function (_ref2) {
      var id = _ref2.id,
          data = _ref2.data,
          model = _objectWithoutProperties(_ref2, ["id", "data"]);

      var scenario_ids = data.scenario_ids,
          modelData = _objectWithoutProperties(data, ["scenario_ids"]);

      return _objectSpread2(_objectSpread2({}, model), {}, {
        key: id,
        data: _objectSpread2(_objectSpread2({}, modelData), {}, {
          geometry: JSON.parse(modelData.geometry),
          scenarios: scenario_ids
        })
      });
    });
    dispatch(actionLoadCasesReceive(models));
  };
}

function saveActiveCase() {
  return function (dispatch, getState) {
    var state = getState();
    var saved = Select.scenarios.cases.getActive(state);
    var edited = Select.scenarios.cases.getActiveCaseEdited(state);

    var editedScenarios = _filter__default['default'](Select.scenarios.scenarios.getEditedAll(state), function (scenario) {
      var keys = edited && edited.data && edited.data.scenarios ? edited.data.scenarios : saved.data.scenarios;
      return _includes__default['default'](keys, scenario.key);
    });

    var activePlaceKey = Select.places.getActiveKey(state);

    if (saved) {
      // update
      dispatch(apiUpdateCases(edited ? [edited] : [], editedScenarios));
    } else {
      // create
      dispatch(apiCreateCases(edited ? [edited] : [], editedScenarios, activePlaceKey));
    }
  };
}

function deleteActiveCase() {
  return function (dispatch, getState) {
    var state = getState();
    var activeCase = Select.scenarios.cases.getActive(state);

    if (activeCase) {
      dispatch(apiDeleteCases([activeCase]));
    }
  };
}

function apiCreateCases(cases, scenarios, placeKey, ttl) {
  if (_isUndefined__default['default'](ttl)) ttl = TTL$2;
  return function (dispatch, getState) {
    dispatch(actionApiCreateCasesRequest(_map__default['default'](cases, 'key')));
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    var url = localConfig.apiBackendProtocol + '://' + path__default['default'].join(localConfig.apiBackendHost, localConfig.apiBackendPath, 'backend/rest/metadata');
    var payload = {
      data: {
        scenario_cases: _map__default['default'](cases, function (model) {
          var caseData = _objectSpread2(_objectSpread2({}, model.data), {}, {
            scenario_ids: model.data.scenarios
          });

          delete caseData.scenarios;
          return {
            uuid: model.key,
            data: _objectSpread2(_objectSpread2({}, caseData), {}, {
              place_ids: [placeKey]
            })
          };
        }),
        scenarios: _map__default['default'](scenarios, function (model) {
          var scenarioData = _objectSpread2({}, model.data);

          delete scenarioData['file'];
          return {
            uuid: model.key,
            data: _objectSpread2({}, scenarioData)
          };
        })
      }
    };
    return fetch__default['default'](url, {
      method: 'POST',
      credentials: 'include',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify(payload)
    }).then(function (response) {
      console.log('#### create scenario cases response', response);
      var contentType = response.headers.get('Content-type');

      if (response.ok && contentType && contentType.indexOf('application/json') !== -1) {
        return response.json().then(function (data) {
          if (data.data) {
            dispatch(apiCreateCasesReceive(data.data));
            var uploadedScenarioFiles = [];

            _each__default['default'](data.data.scenarios, function (createdScenario) {
              var scenarioToCreate = _find__default['default'](scenarios, {
                key: createdScenario.uuid
              });

              if (scenarioToCreate) {
                uploadedScenarioFiles.push({
                  key: createdScenario.id,
                  data: scenarioToCreate.data
                });
              }
            });

            dispatch(apiUploadScenarioFiles(uploadedScenarioFiles));
          } else {
            dispatch(actionApiCreateCasesError('no data returned'));
          }
        });
      } else {
        dispatch(actionApiCreateCasesError(response));
      }
    }, function (error) {
      console.log('#### create scenario case error', error);

      if (ttl - 1) {
        dispatch(apiCreateCases(cases, scenarios, placeKey, ttl - 1));
      } else {
        dispatch(actionApiCreateCasesError("scenarios#actions create cases: cases weren't created!"));
      }
    });
  };
}

function apiUpdateCases(updates, editedScenarios, ttl) {
  if (_isUndefined__default['default'](ttl)) ttl = TTL$2;
  return function (dispatch, getState) {
    dispatch(actionApiUpdateCasesRequest(_map__default['default'](updates, 'key')));
    var state = getState();
    var localConfig = Select.app.getCompleteLocalConfiguration(state);
    var url = localConfig.apiBackendProtocol + '://' + path__default['default'].join(localConfig.apiBackendHost, localConfig.apiBackendPath, 'backend/rest/metadata');
    var payload = {
      data: {
        scenario_cases: _map__default['default'](updates, function (model) {
          var caseData = _objectSpread2(_objectSpread2({}, model.data), {}, {
            scenario_ids: model.data.scenarios
          });

          delete caseData.scenarios;

          if (caseData.scenariosLoaded) {
            delete caseData.scenariosLoaded;
          }

          return {
            id: model.key,
            data: caseData
          };
        }),
        scenarios: _map__default['default'](editedScenarios, function (model) {
          var scenario = {
            data: _objectSpread2({}, model.data)
          };

          if (typeof model.key === "number") {
            scenario.id = model.key;
          } else {
            scenario.uuid = model.key;
          }

          delete scenario.data['file'];
          return scenario;
        })
      }
    };
    return fetch__default['default'](url, {
      method: 'PUT',
      credentials: 'include',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify(payload)
    }).then(function (response) {
      var contentType = response.headers.get('Content-type');

      if (response.ok && contentType && contentType.indexOf('application/json') !== -1) {
        return response.json().then(function (data) {
          if (data.data) {
            dispatch(apiUpdateCasesReceive(data.data));
            var uploadedScenarioFiles = [];
            var duplicatedScenarios = [];

            _each__default['default'](data.data.scenarios, function (createdScenario) {
              var scenarioToCreate = _find__default['default'](editedScenarios, {
                key: createdScenario.uuid || createdScenario.id
              });

              if (scenarioToCreate && scenarioToCreate.data.file) {
                uploadedScenarioFiles.push({
                  key: createdScenario.id,
                  data: scenarioToCreate.data
                });
              } else if (scenarioToCreate && scenarioToCreate.dataSourceCloneKey) {
                var clonedDataSource = Select.spatialDataSources.getDataSource(getState(), scenarioToCreate.dataSourceCloneKey);
                duplicatedScenarios.push({
                  key: createdScenario.id,
                  layerName: clonedDataSource.data.layer_name,
                  data: scenarioToCreate.data
                });
              }
            });

            if (uploadedScenarioFiles.length) {
              dispatch(apiUploadScenarioFiles(uploadedScenarioFiles));
            }

            if (duplicatedScenarios.length) {
              dispatch(apiExecuteMultipleMatlabProcessAndPublisResults(_map__default['default'](duplicatedScenarios, function (duplicatedScenario) {
                return {
                  scenario_id: duplicatedScenario.key,
                  scope_id: Select.scopes.getActiveScopeKey(state),
                  place_id: Select.places.getActiveKey(state),
                  localLayer: duplicatedScenario.layerName
                };
              })));
            }
          } else {
            dispatch(actionApiUpdateCasesError('no data returned'));
          }
        });
      } else {
        dispatch(actionApiUpdateCasesError(response));
      }
    }, function (error) {
      console.log('#### update scenario case error', error);

      if (ttl - 1) {
        dispatch(apiUpdateCases(updates, editedScenarios, ttl - 1));
      } else {
        dispatch(actionApiUpdateCasesError("scenarios#actions load cases: cases weren't loaded!"));
      }
    });
  };
}

function apiDeleteCases(cases, ttl) {
  if (_isUndefined__default['default'](ttl)) ttl = TTL$2;
  return function (dispatch, getState) {
    dispatch(actionApiDeleteCasesRequest(_map__default['default'](cases, 'key')));
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    var url = localConfig.apiBackendProtocol + '://' + path__default['default'].join(localConfig.apiBackendHost, localConfig.apiBackendPath, 'backend/rest/metadata');
    var payload = {
      data: {
        scenario_cases: _map__default['default'](cases, function (model) {
          return {
            id: model.key
          };
        })
      }
    };
    return fetch__default['default'](url, {
      method: 'DELETE',
      credentials: 'include',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify(payload)
    }).then(function (response) {
      console.log('#### delete scenario case response', response);
      var contentType = response.headers.get('Content-type');

      if (response.ok && contentType && contentType.indexOf('application/json') !== -1) {
        return response.json().then(function (data) {
          if (data && data.data && data.data.scenario_cases) {
            var caseKeys = [];
            data.data.scenario_cases.map(function (scenarioCase) {
              if (scenarioCase.deleted) {
                caseKeys.push(scenarioCase.id);
              }
            });
            dispatch(removeCases(caseKeys));
          } else {
            dispatch(apiDeleteCasesError('no data about scenario cases returned'));
          }
        });
      } else {
        dispatch(apiDeleteCasesError(response));
      }
    }, function (error) {
      console.log('#### delete scenario case error', error);

      if (ttl - 1) {
        dispatch(apiDeleteCases(cases, ttl - 1));
      } else {
        dispatch(apiDeleteCasesError("scenarios#actions load cases: cases weren't loaded!"));
      }
    });
  };
}

function apiDeleteCasesError(message) {
  return function (dispatch) {
    dispatch(actionApiDeleteCasesError(message));
  };
}

function apiUploadScenarioFiles(scenarios) {
  return function (dispatch, getState) {
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    var url = localConfig.apiBackendProtocol + '://' + path__default['default'].join(localConfig.apiBackendHost, localConfig.apiBackendPath, 'backend/rest/importer/upload');
    var promises = [];
    var scenarioKeys = [];
    scenarios.forEach(function (scenario) {
      if (scenario && scenario.data && scenario.data.file) {
        dispatch(apiProcessingScenarioFileStarted(scenario.key));
        scenarioKeys.push(scenario.key);
        var postData = new FormData();
        postData.append('file', scenario.data.file);
        promises.push(fetch__default['default'](url, {
          method: 'POST',
          credentials: 'include',
          body: postData
        }).then(function (response) {
          return response.json();
        }, function (error) {
          dispatch(apiProcessingScenarioFileError(scenario.key, error));
        }).then(function (response) {
          return {
            scenarioKey: scenario.key,
            uploadKey: response.data.uploadKey
          };
        })["catch"](function (error) {
          dispatch(apiProcessingScenarioFileError(scenario.key, error));
        }));
      }
    });

    if (promises.length) {
      return Promise.all(promises).then(function (results) {
        dispatch(apiExecutePucsMatlabProcessOnUploadedScenarioFiles(results));
      })["catch"](function (error) {
        dispatch(apiProcessingScenarioFilesError(scenarioKeys, error));
      });
    }
  };
}

function clearRequestInterval(uuid) {
  if (requestIntervals.hasOwnProperty(uuid)) {
    clearInterval(requestIntervals[uuid]);
  }
}

function apiExecuteMultipleMatlabProcessAndPublisResults(processes) {
  return function (dispatch, getState) {
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    processes = _isArray__default['default'](processes) ? processes : [processes];
    processes.forEach(function (process) {
      if (process.scenario_id) {
        dispatch(apiProcessingScenarioFileStarted(process.scenario_id));
      }
    });
    getBodyForMatlabProcessesRequest(processes).then(function (body) {
      var execute = function execute() {
        executeMatlabProcessRequest(body, localConfig).then(function (results) {
          return processMatlabProcessRequestResults(results, dispatch);
        }).then(function (repeat) {
          if (repeat) {
            setTimeout(function () {
              execute();
            }, 2000);
          }
        })["catch"](function (error) {
          console.log("apiExecuteMultipleMatlabProcessAndPublisResults#error", error);
        });
      };

      execute();
    });
  };
}

function processMatlabProcessRequestResults(results, dispatch) {
  return Promise.resolve().then(function () {
    var running = false;
    results.data.forEach(function (resultData) {
      if (resultData.status === "running") {
        running = true;
      }
    });

    if (!running) {
      var dataSourcesIds = [];
      results.data.forEach(function (resultData) {
        if (resultData.status === "done" && resultData["spatial_relations"]) {
          _each__default['default'](resultData['spatial_relations'], function (relation) {
            dataSourcesIds.push(relation.data.data_source_id);
          });

          dispatch(SpatialRelationsAction.loadRelationsReceive(resultData['spatial_relations']));
          dispatch(apiProcessingScenarioFileSuccess(resultData.data.scenario_id));
        }
      });
      dispatch(SpatialDataSourcesAction.loadFiltered({
        'id': dataSourcesIds
      }));
    } else {
      return running;
    }
  });
}

function executeMatlabProcessRequest(body, localConfig) {
  return fetch__default['default'](localConfig.apiBackendProtocol + '://' + path__default['default'].join(localConfig.apiBackendHost, localConfig.apiBackendPath, 'backend/rest/pucs/publish'), {
    method: "POST",
    credentials: 'include',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    },
    body: JSON.stringify(body)
  }).then(function (response) {
    if (response.status === 200) {
      return response.json();
    } else {
      throw new Error('wrong status');
    }
  });
}

function getBodyForMatlabProcessesRequest(processes) {
  return Promise.resolve().then(function () {
    return {
      data: _map__default['default'](processes, function (process) {
        return {
          uuid: ptrUtils.utils.uuid(),
          data: process
        };
      })
    };
  });
}

function apiExecutePucsMatlabProcessOnUploadedScenarioFiles(uploads) {
  return function (dispatch, getState) {
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    var url = localConfig.apiBackendProtocol + '://' + path__default['default'].join(localConfig.apiBackendHost, localConfig.apiBackendPath, 'backend/rest/pucs/execute_matlab');
    var state = getState();
    var scenarioKeys = [];
    uploads.forEach(function (upload) {
      scenarioKeys.push(upload.scenarioKey);
      var uuid = ptrUtils.utils.uuid();

      var requestAttempt = function requestAttempt() {
        fetch__default['default'](url, {
          method: 'POST',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body: JSON.stringify({
            data: {
              uploadKey: upload.uploadKey,
              placeId: Select.places.getActiveKey(state),
              scopeId: Select.scopes.getActiveScopeKey(state)
            }
          })
        }).then(function (response) {
          return response.json().then(function (data) {
            if (!response.ok || data.hasOwnProperty('success') && !data.success) {
              clearRequestInterval(uuid);
              dispatch(apiProcessingScenarioFilesError(scenarioKeys, response.statusText));
            } else if (data.result) {
              clearRequestInterval(uuid);
              dispatch(apiCreateRelationsForScenarioProcessResults([{
                scenarioKey: upload.scenarioKey,
                processResults: JSON.parse(data.result)
              }]));
            }
          })["catch"](function (error) {
            clearRequestInterval(uuid);
            dispatch(apiProcessingScenarioFilesError(scenarioKeys, error));
          });
        })["catch"](function (error) {
          clearRequestInterval(uuid);
          dispatch(apiProcessingScenarioFilesError(scenarioKeys, error));
        });
      };

      requestAttempt();
      requestIntervals[uuid] = setInterval(function () {
        requestAttempt();
      }, 5000);
    });
  };
}

function apiCreateRelationsForScenarioProcessResults(results) {
  return function (dispatch, getState) {
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    var url = localConfig.apiBackendProtocol + '://' + path__default['default'].join(localConfig.apiBackendHost, localConfig.apiBackendPath, 'backend/rest/relations');
    var activePlace = Select.places.getActive(getState());
    var activePlaceKey = activePlace ? activePlace.key : null;
    var inputVectorTemplateId, outputRasterHwdTemplateId, outputRasterUhiTemplateId;
    var configuration = Select.scopes.getActiveScopeConfiguration(getState());

    if (configuration.pucsLandUseScenarios && configuration.pucsLandUseScenarios.templates) {
      var templates = configuration.pucsLandUseScenarios.templates;
      inputVectorTemplateId = templates.sourceVector;
      outputRasterHwdTemplateId = templates.hwd;
      outputRasterUhiTemplateId = templates.uhi;
    } else {
      console.error("Scenarios actions#apiCreateRelationsForScenarioProcessResults: pucsLandUseScenarios configuration is missing!");
    }

    var relations = [];
    var scenarioKeys = [];
    results.forEach(function (result) {
      if (activePlaceKey && result.scenarioKey) {
        scenarioKeys.push(result.scenarioKey);
        var inputVectors = result.processResults[0].inputVectors;
        var outputRasters = result.processResults[0].outputRasters;
        var inputVector = inputVectors[0];

        var outputHwd = _find__default['default'](outputRasters, {
          indicator: 'hwd'
        });

        var outputUhi = _find__default['default'](outputRasters, {
          indicator: 'uhi'
        });

        if (inputVector && outputHwd && outputUhi) {
          relations.push({
            data: {
              place_id: Number(activePlaceKey),
              scenario_id: Number(result.scenarioKey),
              layer_template_id: inputVectorTemplateId,
              data_source_id: inputVector.spatialDataSourceId
            }
          });
          relations.push({
            data: {
              place_id: Number(activePlaceKey),
              scenario_id: Number(result.scenarioKey),
              layer_template_id: outputRasterHwdTemplateId,
              data_source_id: outputHwd.spatialDataSourceId
            }
          });
          relations.push({
            data: {
              place_id: Number(activePlaceKey),
              scenario_id: Number(result.scenarioKey),
              layer_template_id: outputRasterUhiTemplateId,
              data_source_id: outputUhi.spatialDataSourceId
            }
          });
        }
      }
    });

    if (relations.length) {
      return fetch__default['default'](url, {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          "data": {
            "spatial": relations
          }
        })
      }).then(function (relationResults) {
        return relationResults.json();
      }).then(function (relationResults) {
        if (relationResults.data.spatial) {
          // todo why there are data apart of key, while in SpatialRelationsAction.load response are not?
          var dataSourcesIds = _compact__default['default'](_map__default['default'](relationResults.data.spatial, function (spatialRelation) {
            return spatialRelation.data.data_source_id;
          }));

          dispatch(SpatialRelationsAction.loadRelationsReceive(relationResults.data.spatial));
          dispatch(SpatialDataSourcesAction.loadFiltered({
            'id': dataSourcesIds
          }));
          dispatch(apiProcessingScenarioFilesSuccess(scenarioKeys));
        } else {
          dispatch(apiProcessingScenarioFilesError(scenarioKeys, "Relations were not loaded"));
        }
      })["catch"](function (error) {
        dispatch(apiProcessingScenarioFilesError(scenarioKeys, error));
      });
    }
  };
}

function apiProcessingScenarioFileStarted(scenarioKey) {
  return function (dispatch, getState) {
    var scenario = Select.scenarios.scenarios.getByKey(getState(), scenarioKey);

    if (scenario) {
      var updated = _objectSpread2(_objectSpread2({}, scenario), {}, {
        fileProcessing: {
          started: true
        }
      });

      dispatch(actionApiProcessingScenarioFileStarted([updated]));
    }
  };
}

function apiProcessingScenarioFilesSuccess(scenarioKeys) {
  return function (dispatch, getState) {
    scenarioKeys.forEach(function (key) {
      dispatch(apiProcessingScenarioFileSuccess(key));
    });
  };
}

function apiProcessingScenarioFilesError(scenarioKeys, message) {
  return function (dispatch, getState) {
    scenarioKeys.forEach(function (key) {
      dispatch(apiProcessingScenarioFileError(key, message));
    });
  };
}

function apiProcessingScenarioFileSuccess(scenarioKey) {
  return function (dispatch, getState) {
    var scenario = Select.scenarios.scenarios.getByKey(getState(), scenarioKey);

    if (scenario) {
      var updated = _objectSpread2(_objectSpread2({}, scenario), {}, {
        fileProcessing: {
          started: true,
          finished: true
        }
      });

      dispatch(actionApiProcessingScenarioFileSuccess([updated]));
    }
  };
}

function apiProcessingScenarioFileError(scenarioKey, error) {
  return function (dispatch, getState) {
    var scenario = Select.scenarios.scenarios.getByKey(getState(), scenarioKey);

    if (scenario) {
      var updated = _objectSpread2(_objectSpread2({}, scenario), {}, {
        fileProcessing: {
          started: true,
          finished: true,
          error: true,
          message: error
        }
      });

      dispatch(actionApiProcessingScenarioFileError([updated]));
      console.error('Scenarios/actions#apiProcessingScenarioFileError', error);
    }
  };
}

function apiCreateCasesReceive(data) {
  return function (dispatch, getState) {
    var cases = data.scenario_cases;
    var scenarios = data.scenarios; // add to data

    dispatch(loadCasesReceive(cases));
    dispatch(apiCreateScenariosReceive(scenarios)); // change active key if of temporary case

    var activeCaseKey = Select.scenarios.cases.getActiveKey(getState());

    if (activeCaseKey) {
      var activeCaseCreated = _find__default['default'](cases, {
        uuid: activeCaseKey
      });

      if (activeCaseCreated) {
        dispatch(actionSetActiveCase(activeCaseCreated.id));
      }
    } // remove from editedData


    dispatch(actionRemoveEditedCases(_map__default['default'](cases, 'uuid')));
  };
}

function apiUpdateCasesReceive(data) {
  return function (dispatch) {
    var cases = data.scenario_cases;
    var scenarios = data.scenarios;

    if (scenarios.length) {
      // remove from editedData
      dispatch(removeActiveCaseEditedScenarios()); // add/update data

      dispatch(loadReceive(scenarios));
    }

    dispatch(loadCasesReceive(cases));
    dispatch(actionRemoveActiveCaseFromEdited());
  };
}

function apiCreateScenariosReceive(data) {
  return function (dispatch, getState) {
    // add to data
    dispatch(loadReceive(data)); // change keys in (edited) cases

    var editedCases = Select.scenarios.cases.getEditedAll(getState());
    var updates = [];

    _each__default['default'](editedCases, function (editedCase) {
      var scenariosChanged;

      var newScenarios = _map__default['default'](editedCase.data.scenarios, function (scenarioKey) {
        var createdScenario = _find__default['default'](data, {
          'uuid': scenarioKey
        });

        if (createdScenario) {
          scenariosChanged = true;
          return createdScenario.id;
        } else {
          return scenarioKey;
        }
      });

      if (scenariosChanged) {
        updates.push({
          key: editedCase.key,
          data: {
            'scenarios': newScenarios
          }
        });
      }
    });

    if (updates.length) {
      dispatch(actionUpdateEditedCases(updates));
    } // remove from editedData


    dispatch(removeActiveCaseEditedScenarios());
  };
} // ============ actions ===========


function actionSetActive(scenario) {
  return {
    type: ActionTypes.SCENARIOS_SET_ACTIVE,
    data: scenario
  };
}

function actionSetActiveKeys$1(scenarios) {
  return {
    type: ActionTypes.SCENARIOS_SET_ACTIVE_MULTI,
    keys: scenarios
  };
}

function actionSetActiveCase(caseKey) {
  return {
    type: ActionTypes.SCENARIOS_CASES_SET_ACTIVE,
    key: caseKey
  };
}

function actionSetDefaultSituationActive(active) {
  return {
    type: ActionTypes.SCENARIOS_SET_DEFAULT_SITUATION_ACTIVE,
    active: active
  };
}

function actionUpdateCases(data) {
  return {
    type: ActionTypes.SCENARIOS_CASES_UPDATE,
    data: data
  };
}

function actionLoadRequest(caseKey) {
  return {
    type: ActionTypes.SCENARIOS_REQUEST,
    caseKey: caseKey
  };
}

function actionLoadReceive(data) {
  return {
    type: ActionTypes.SCENARIOS_RECEIVE,
    data: data
  };
}

function actionLoadError(error) {
  return {
    type: ActionTypes.SCENARIOS_REQUEST_ERROR,
    error: error
  };
}

function actionLoadCasesRequest() {
  return {
    type: ActionTypes.SCENARIOS_CASES_REQUEST
  };
}

function actionLoadCasesReceive(data) {
  return {
    type: ActionTypes.SCENARIOS_CASES_RECEIVE,
    data: data
  };
}

function actionLoadCasesError(error) {
  return {
    type: ActionTypes.SCENARIOS_CASES_REQUEST_ERROR,
    error: error
  };
}

function actionUpdateEditedCases(data) {
  return {
    type: ActionTypes.SCENARIOS_CASES_EDITED_UPDATE,
    data: data
  };
}

function actionUpdateEditedScenarios(data) {
  return {
    type: ActionTypes.SCENARIOS_EDITED_UPDATE,
    data: data
  };
}

function actionRemoveActiveCaseFromEdited() {
  return {
    type: ActionTypes.SCENARIOS_CASES_EDITED_REMOVE_ACTIVE
  };
}

function actionRemoveCases(keys) {
  return {
    type: ActionTypes.SCENARIOS_CASES_REMOVE,
    keys: keys
  };
}

function actionRemoveEditedCases(keys) {
  return {
    type: ActionTypes.SCENARIOS_CASES_EDITED_REMOVE,
    keys: keys
  };
}

function actionRemovePropertyFromEditedCase(caseKey, property) {
  return {
    type: ActionTypes.SCENARIOS_CASES_EDITED_REMOVE_PROPERTY,
    caseKey: caseKey,
    property: property
  };
}

function actionRemoveEditedScenarios(keys) {
  return {
    type: ActionTypes.SCENARIOS_EDITED_REMOVE,
    keys: keys
  };
}

function actionRemovePropertyFromEditedScenario(scenarioKey, property) {
  return {
    type: ActionTypes.SCENARIOS_EDITED_REMOVE_PROPERTY,
    scenarioKey: scenarioKey,
    property: property
  };
}

function actionApiCreateCasesRequest(keys) {
  return {
    type: ActionTypes.SCENARIOS_CASES_API_CREATE_REQUEST,
    keys: keys
  };
}

function actionApiCreateCasesError(error) {
  return {
    type: ActionTypes.SCENARIOS_CASES_API_CREATE_ERROR,
    error: error
  };
}

function actionApiDeleteCasesRequest(keys) {
  return {
    type: ActionTypes.SCENARIOS_CASES_API_DELETE_REQUEST,
    keys: keys
  };
}

function actionApiDeleteCasesError(error) {
  return {
    type: ActionTypes.SCENARIOS_CASES_API_DELETE_REQUEST,
    error: error
  };
}

function actionApiUpdateCasesRequest(keys) {
  return {
    type: ActionTypes.SCENARIOS_CASES_API_UPDATE_REQUEST,
    keys: keys
  };
}

function actionApiUpdateCasesError(keys) {
  return {
    type: ActionTypes.SCENARIOS_CASES_API_UPDATE_ERROR,
    keys: keys
  };
}

function actionApiProcessingScenarioFileStarted(data) {
  return {
    type: ActionTypes.SCENARIOS_API_PROCESSING_FILE_STARTED,
    data: data
  };
}

function actionApiProcessingScenarioFileSuccess(data) {
  return {
    type: ActionTypes.SCENARIOS_API_PROCESSING_FILE_SUCCESS,
    data: data
  };
}

function actionApiProcessingScenarioFileError(data) {
  return {
    type: ActionTypes.SCENARIOS_API_PROCESSING_FILE_ERROR,
    data: data
  };
} // ============ export ===========


var Scenarios$1 = {
  add: add$e,
  setActive: actionSetActive,
  removeEditedActiveCase: actionRemoveActiveCaseFromEdited,
  applyDataviewSettings: applyDataviewSettings,
  setDefaultSituationActive: actionSetDefaultSituationActive,
  addActiveScenario: addActiveScenario,
  removeActiveScenario: removeActiveScenario,
  deleteActiveCase: deleteActiveCase,
  saveActiveCase: saveActiveCase,
  setActiveCase: setActiveCase,
  load: load,
  loadCases: loadCases,
  addEditedScenario: addEditedScenario,
  removeActiveCaseEditedScenarios: removeActiveCaseEditedScenarios,
  removeScenarioFromActiveCase: removeScenarioFromActiveCase,
  removeScenarioFromActiveCaseEdited: removeScenarioFromActiveCaseEdited,
  updateEditedActiveCase: updateEditedActiveCase,
  updateEditedScenario: updateEditedScenario,
  updateStateFromView: updateStateFromView$c
};

// ============ creators ===========
var add$f = actions.add(ActionTypes.SCOPES);
var create$8 = actions.create(Select.scopes.getSubstate, 'scopes', ActionTypes.SCOPES);
var deleteItem$7 = actions["delete"](Select.scopes.getSubstate, 'scopes', ActionTypes.SCOPES);
var saveEdited$7 = actions.saveEdited(Select.scopes.getSubstate, 'scopes', ActionTypes.SCOPES);
var updateEdited$7 = actions.updateEdited(Select.scopes.getSubstate, ActionTypes.SCOPES);
var useKeys$d = actions.useKeys(Select.scopes.getSubstate, 'scopes', ActionTypes.SCOPES);
var useKeysClear$a = actions.useKeysClear(ActionTypes.SCOPES);
var useIndexedClear$9 = actions.useIndexedClear(ActionTypes.SCOPES);
var useIndexed$e = actions.useIndexed(Select.scopes.getSubstate, 'scopes', ActionTypes.SCOPES);
var refreshUses$8 = actions.refreshUses(Select.scopes.getSubstate, "scopes", ActionTypes.SCOPES);
var setActiveKeyAndEnsureDependencies$4 = actions.setActiveKeyAndEnsureDependencies(ActionTypes.SCOPES, 'scope');
var ensureIndexesWithFilterByActive$a = actions.ensureIndexesWithFilterByActive(Select.scopes.getSubstate, 'scopes', ActionTypes.SCOPES);

function setActiveKey$8(key) {
  return function (dispatch, getState) {
    dispatch(setActiveKeyAndEnsureDependencies$4(key)); // TODO move somewhere else (probably after implementing areas)

    var activeScope = Select.scopes.getActive(getState());

    if (activeScope && activeScope.data && activeScope.data.configuration && activeScope.data.configuration.areaNameAttributeKey) {
      dispatch(actions$7.ensureIndexedSpecific({
        scopeKey: key,
        attributeKey: activeScope.data.configuration.areaNameAttributeKey
      }, null, 1, 10, 'scopes.actions#setActiveScope', true));
    } //load filter countries


    if (activeScope && activeScope.data && activeScope.data.configuration && activeScope.data.configuration.countryCodeAttributeKey) {
      dispatch(actions$7.ensureIndexedSpecific({
        scopeKey: key,
        attributeKey: activeScope.data.configuration.countryCodeAttributeKey
      }, null, 1, 10, 'scopes.actions#setActiveScope', true));
    }
  };
}

function updateStateFromView$d(data) {
  return function (dispatch) {
    if (data) {
      if (data && data.byKey) {
        dispatch(add$f(_values__default['default'](data.byKey)));
      }

      if (data && data.activeKey) {
        dispatch(setActiveKey$8(data.activeKey));
      }
    }
  };
} // ============ actions ===========
// ============ export ===========


var ScopesAction = {
  add: add$f,
  create: create$8,
  "delete": deleteItem$7,
  ensureIndexesWithFilterByActive: ensureIndexesWithFilterByActive$a,
  refreshUses: refreshUses$8,
  saveEdited: saveEdited$7,
  setActiveKey: setActiveKey$8,
  updateEdited: updateEdited$7,
  updateStateFromView: updateStateFromView$d,
  useIndexed: useIndexed$e,
  useIndexedClear: useIndexedClear$9,
  useKeys: useKeys$d,
  useKeysClear: useKeysClear$a
};

var timeouts = {}; // ============ creators ===========

function addOrUpdate(setKey, lineage, width, minActiveWidth, component, props) {
  return function (dispatch, getState) {
    var existingScreen = Select.screens.getScreenByLineage(getState(), lineage);

    if (existingScreen) {
      if (timeouts[lineage]) {
        clearTimeout(timeouts[lineage]);
      }

      dispatch(actionUpdate$5(setKey, lineage, {
        width: width,
        minActiveWidth: minActiveWidth,
        desiredState: 'opening',
        component: component,
        props: props
      }));
    } else {
      dispatch(actionAdd$1(setKey, lineage, {
        width: width,
        minActiveWidth: minActiveWidth,
        desiredState: 'opening',
        component: component,
        props: props
      }));
    } // TODO timeout is necessary to actually trigger associated selectors twice


    setTimeout(function () {
      dispatch(open(setKey, lineage));
    }, 1);
  };
}

function ensureSet(setKey) {
  return function (dispatch, getState) {
    var existingSet = Select.screens.getSetByKey(getState(), setKey);

    if (!existingSet) {
      dispatch(actionAddSet$1(setKey));
    }
  };
}

function open(setKey, screenLineage) {
  return function (dispatch, getState) {
    if (screenLineage !== 'base') {
      dispatch(actionOpen(setKey, screenLineage));
    }

    dispatch(actionTopHistory(setKey, screenLineage));
  };
}

function close(setKey, screenLineage) {
  return function (dispatch, getState) {
    dispatch(actionClose(setKey, screenLineage));
    dispatch(actionTopHistory(setKey, screenLineage));
    timeouts[screenLineage] = setTimeout(function () {
      dispatch(actionRemove$1(setKey, screenLineage));
    }, 550);
  };
}

function removeAllScreensFromSet(setKey) {
  return function (dispatch) {
    dispatch(actionRemoveAllScreensFromSet(setKey));
  };
}

function retract(setKey, screenLineage) {
  return function (dispatch, getState) {
    dispatch(actionRetract(setKey, screenLineage));
    dispatch(actionTopHistory(setKey, screenLineage));
  };
}

function topHistory(setKey, screenLineage) {
  return function (dispatch) {
    dispatch(ensureSet(setKey));
    dispatch(actionTopHistory(setKey, screenLineage));
  };
} // ============ actions ===========


var actionAdd$1 = function actionAdd(setKey, lineage, data) {
  return {
    type: ActionTypes.SCREENS.ADD,
    setKey: setKey,
    lineage: lineage,
    data: data
  };
};

var actionAddSet$1 = function actionAddSet(setKey) {
  return {
    type: ActionTypes.SCREENS.SETS.ADD,
    setKey: setKey
  };
};

var actionOpen = function actionOpen(setKey, lineage) {
  return {
    type: ActionTypes.SCREENS.OPEN,
    setKey: setKey,
    lineage: lineage
  };
};

var actionClose = function actionClose(setKey, lineage) {
  return {
    type: ActionTypes.SCREENS.CLOSE,
    setKey: setKey,
    lineage: lineage
  };
};

var actionRemove$1 = function actionRemove(setKey, lineage) {
  return {
    type: ActionTypes.SCREENS.REMOVE,
    setKey: setKey,
    lineage: lineage
  };
};

var actionRemoveAllScreensFromSet = function actionRemoveAllScreensFromSet(setKey) {
  return {
    type: ActionTypes.SCREENS.REMOVE_ALL,
    setKey: setKey
  };
};

var actionRetract = function actionRetract(setKey, lineage) {
  return {
    type: ActionTypes.SCREENS.RETRACT,
    setKey: setKey,
    lineage: lineage
  };
};

var actionTopHistory = function actionTopHistory(setKey, lineage) {
  return {
    type: ActionTypes.SCREENS.TOP_HISTORY,
    setKey: setKey,
    lineage: lineage
  };
};

var actionUpdate$5 = function actionUpdate(setKey, lineage, data) {
  return {
    type: ActionTypes.SCREENS.UPDATE,
    setKey: setKey,
    lineage: lineage,
    data: data
  };
}; // ============ export ===========


var Screens$1 = {
  addOrUpdate: addOrUpdate,
  addSet: actionAddSet$1,
  close: close,
  open: open,
  removeAllScreensFromSet: removeAllScreensFromSet,
  retract: retract,
  topHistory: topHistory
};

// ============ creators ===========
var add$g = function add(data) {
  return function (dispatch) {
    if (!_isArray__default['default'](data)) data = [data];
    dispatch(actionAdd$2(data));
  };
};

var remove = function remove(keys) {
  return function (dispatch) {
    if (!_isArray__default['default'](keys)) keys = [keys];
    dispatch(actionRemove$2(keys));
  };
};

var createMapSnapshot = function createMapSnapshot() {
  return function (dispatch) {
    window.Stores.generateSnapshot().then(function (snapshots) {
      snapshots.forEach(function (snapshot) {
        dispatch(add$g({
          key: snapshot.uuid,
          data: {
            name: snapshot.name,
            type: "map",
            source: snapshot.source
          }
        }));
      });
    });
  };
}; // ============ actions ===========


function actionAdd$2(data) {
  return {
    type: ActionTypes.SNAPSHOTS_ADD,
    data: data
  };
}

function actionRemove$2(keys) {
  return {
    type: ActionTypes.SNAPSHOTS_REMOVE,
    keys: keys
  };
} // ============ export ===========


var Snapshots$1 = {
  add: add$g,
  remove: remove,
  createMapSnapshot: createMapSnapshot
};

var create$9 = actions.create(Select.tags.getSubstate, 'tags', ActionTypes.TAGS);
var deleteItem$8 = actions["delete"](Select.tags.getSubstate, 'tags', ActionTypes.TAGS);
var saveEdited$8 = actions.saveEdited(Select.tags.getSubstate, 'tags', ActionTypes.TAGS);
var updateEdited$8 = actions.updateEdited(Select.tags.getSubstate, ActionTypes.TAGS);
var useKeys$e = actions.useKeys(Select.tags.getSubstate, 'tags', ActionTypes.TAGS);
var useKeysClear$b = actions.useKeysClear(ActionTypes.TAGS);
var useIndexedClear$a = actions.useIndexedClear(ActionTypes.TAGS);
var useIndexed$f = actions.useIndexed(Select.tags.getSubstate, 'tags', ActionTypes.TAGS);
var refreshUses$9 = actions.refreshUses(Select.tags.getSubstate, "tags", ActionTypes.TAGS);
var ensureIndexesWithFilterByActive$b = actions.ensureIndexesWithFilterByActive(Select.tags.getSubstate, 'tags', ActionTypes.TAGS); // ============ actions ===========
// ============ export ===========

var Tags$1 = {
  create: create$9,
  "delete": deleteItem$8,
  ensureIndexesWithFilterByActive: ensureIndexesWithFilterByActive$b,
  saveEdited: saveEdited$8,
  updateEdited: updateEdited$8,
  useKeys: useKeys$e,
  useKeysClear: useKeysClear$b,
  refreshUses: refreshUses$9,
  useIndexed: useIndexed$f,
  useIndexedClear: useIndexedClear$a
};

var TTL$3 = 5; // ============ creators ===========

var add$h = actions.add(ActionTypes.USERS);
var setActiveKey$9 = actions.setActiveKey(ActionTypes.USERS);

var refreshUses$a = function refreshUses() {
  return function (dispatch) {
    dispatch(actions.refreshUses(Select.users.getSubstate, 'users', ActionTypes.USERS, 'user')());
    dispatch(actions.refreshUses(Select.users.getGroupsSubstate, 'groups', ActionTypes.USERS.GROUPS, 'user')());
  };
};

var useKeys$f = actions.useKeys(Select.users.getSubstate, 'users', ActionTypes.USERS, 'user');
var useKeysClear$c = actions.useKeysClear(ActionTypes.USERS);
var useIndexedUsers = actions.useIndexed(Select.users.getSubstate, 'users', ActionTypes.USERS, 'user');
var useIndexedGroups = actions.useIndexed(Select.users.getGroupsSubstate, 'groups', ActionTypes.USERS.GROUPS, 'user');

function onLogin() {
  return function (dispatch) {
    dispatch(actions.actionDataSetOutdated());
    dispatch(apiLoadCurrentUser());
    dispatch(ScopesAction.refreshUses());
    dispatch(PlacesAction.refreshUses());
    dispatch(PeriodsAction.refreshUses());
    dispatch(refreshUses$a());
  };
}

function onLogout() {
  return function (dispatch) {
    dispatch(actionLogout());
    dispatch(setActiveKey$9(null));
    dispatch(ScopesAction.refreshUses());
    dispatch(PlacesAction.refreshUses());
    dispatch(PeriodsAction.refreshUses());
    dispatch(refreshUses$a());
  };
}

function apiLoginUser(email, password) {
  return function (dispatch, getState) {
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    dispatch(actionApiLoginRequest());
    var payload = {
      username: email,
      password: password
    };
    return request(localConfig, 'backend/api/login/login', 'POST', null, payload).then(function (result) {
      if (result.data.status === "ok") {
        dispatch(onLogin());
      }
    })["catch"](function (error) {
      dispatch(actions.actionGeneralError(error));
      return error;
    });
  };
} // function apiLoad(ttl) {
// 	if (_.isUndefined(ttl)) ttl = TTL;
// 	return (dispatch, getState) => {
// 		let state = getState();
// 		if (state.users.loading) {
// 			// already loading, do nothing
// 		} else {
// 			dispatch(actionApiLoadRequest());
//
// 			let url = config.apiBackendProtocol + '://' + path.join(config.apiBackendHost, 'backend/rest/user');
//
// 			return fetch(url, {
// 				method: 'GET',
// 				credentials: 'include',
// 				headers: {
// 					'Content-Type': 'application/json',
// 					'Accept': 'application/json'
// 				}
// 			}).then(
// 				response => {
// 					let contentType = response.headers.get('Content-type');
// 					if (response.ok && contentType && (contentType.indexOf('application/json') !== -1)) {
// 						return response.json().then(data => {
// 							Promise.all(data.data.map(user => {
// 								return new User({data: user}).then(user => {
// 									user.key = user.id;
// 									return user;
// 								});
// 							})).then(users => {
// 								dispatch(actionAdd(users));
// 							});
// 						});
// 					} else {
// 						dispatch(actionApiLoadRequestError('scopes#action Problem with loading scopes.'));
// 					}
// 				},
// 				error => {
// 					if (ttl - 1) {
// 						dispatch(apiLoad(ttl - 1));
// 					} else {
// 						dispatch(actionApiLoadRequestError('scopes#action Problem with loading scopes.'));
// 					}
// 				}
// 			);
// 		}
// 	};
// }


function apiLoadCurrentUser() {
  return function (dispatch, getState) {
    var localConfig = Select.app.getCompleteLocalConfiguration(getState());
    dispatch(actionApiLoadCurrentUserRequest());
    return request(localConfig, 'backend/rest/user/current', 'GET', null, null).then(function (result) {
      if (result.errors) {
        //todo how do we return errors here?
        throw new Error(result.errors);
      } else {
        if (result.key === 0) {
          // no logged in user = guest
          dispatch(actionAddGroups(transformGroups(result.groups)));
        } else if (result.key) {
          // logged in user
          dispatch(setActiveKey$9(result.key));
          dispatch(add$h(transformUser(result)));
          dispatch(actionAddGroups(transformGroups(result.groups)));
        }
      }
    })["catch"](function (error) {
      dispatch(actions.actionGeneralError(error));
      return error;
    });
  };
}

function apiLogoutUser(ttl) {
  if (_isUndefined__default['default'](ttl)) ttl = TTL$3;
  return function (dispatch, getState) {
    var apiBackendProtocol = Select.app.getLocalConfiguration(getState(), 'apiBackendProtocol');
    var apiBackendHost = Select.app.getLocalConfiguration(getState(), 'apiBackendHost');
    dispatch(actionApiLogoutRequest());
    var url = apiBackendProtocol + '://' + path__default['default'].join(apiBackendHost, 'backend/api/login/logout');
    return fetch__default['default'](url, {
      method: 'POST',
      credentials: 'include',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      }
    }).then(function (response) {
      console.log('#### logout user response', response);

      if (response.ok) {
        // window.location.reload();
        dispatch(onLogout());
      } else {
        dispatch(actionApiLogoutRequestError('user#action logout Problem with logging out the User, please try later.'));
      }
    }, function (error) {
      console.log('#### logout user error', error);

      if (ttl - 1) {
        dispatch(apiLogoutUser(ttl - 1));
      } else {
        dispatch(actionApiLogoutRequestError('user#action logout Problem with logging out the User, please try later.'));
      }
    });
  };
} // ============ helpers ===========


function transformUser(user) {
  return _objectSpread2(_objectSpread2({}, user), {}, {
    //TODO remove -> workaround with permissions.guest.get
    permissions: _objectSpread2(_objectSpread2({}, user.permissions), {}, {
      guest: {
        get: false
      }
    }),
    groups: _map__default['default'](user.groups, 'key')
  });
} //TODO remove -> workaround with permissions.guest.get


function transformGroups(groups) {
  return groups.map(function (group) {
    return _objectSpread2(_objectSpread2({}, group), {}, {
      permissions: {
        guest: {
          get: false
        }
      }
    });
  });
} // ============ actions ===========


function actionClearUsersUseIndexed(componentId) {
  return {
    type: ActionTypes.USERS.USE.INDEXED.CLEAR,
    componentId: componentId
  };
}

function actionClearGroupsUseIndexed(componentId) {
  return {
    type: ActionTypes.USERS.GROUPS.USE.INDEXED.CLEAR,
    componentId: componentId
  };
}

function actionAddGroups(groups) {
  return {
    type: ActionTypes.USERS.GROUPS.ADD,
    data: groups
  };
}

function actionApiLogoutRequest() {
  return {
    type: ActionTypes.USERS_LOGOUT_REQUEST
  };
}

function actionApiLogoutRequestError(error) {
  return {
    type: ActionTypes.USERS_LOGOUT_REQUEST_ERROR,
    error: error
  };
}

function actionApiLoginRequest() {
  return {
    type: ActionTypes.USERS.LOGIN.REQUEST
  };
}

function actionApiLoadCurrentUserRequest() {
  return {
    type: ActionTypes.USERS.CURRENT.REQUEST
  };
}

function actionLogout() {
  return {
    type: ActionTypes.COMMON.DATA.CLEANUP_ON_LOGOUT
  };
} // ============ export ===========


var Users$1 = {
  add: add$h,
  // apiLoad: apiLoad,
  apiLoadCurrentUser: apiLoadCurrentUser,
  apiLoginUser: apiLoginUser,
  apiLogoutUser: apiLogoutUser,
  refreshUses: refreshUses$a,
  useKeys: useKeys$f,
  useKeysClear: useKeysClear$c,
  useIndexedUsers: useIndexedUsers,
  useIndexedGroups: useIndexedGroups,
  useIndexedUsersClear: actionClearUsersUseIndexed,
  useIndexedGroupsClear: actionClearGroupsUseIndexed // update: update

};

// ============ creators ===========
var add$i = actions.add(ActionTypes.VIEWS);
var setActiveKey$a = actions.setActiveKey(ActionTypes.VIEWS);
var setActiveKeys$4 = actions.setActiveKeys(ActionTypes.VIEWS);
var create$a = actions.create(Select.views.getSubstate, 'views', ActionTypes.VIEWS, 'views');
var deleteItem$9 = actions["delete"](Select.views.getSubstate, 'views', ActionTypes.VIEWS, 'views');
var saveEdited$9 = actions.saveEdited(Select.views.getSubstate, 'views', ActionTypes.VIEWS, 'views');
var updateEdited$9 = actions.updateEdited(Select.views.getSubstate, ActionTypes.VIEWS, 'views');
var useKeys$g = actions.useKeys(Select.views.getSubstate, 'views', ActionTypes.VIEWS, 'views');
var useKeysClear$d = actions.useKeysClear(ActionTypes.VIEWS);
var useIndexedClear$b = actions.useIndexedClear(ActionTypes.VIEWS);
var useIndexed$g = actions.useIndexed(Select.views.getSubstate, 'views', ActionTypes.VIEWS, 'views');
var refreshUses$b = actions.refreshUses(Select.views.getSubstate, "views", ActionTypes.VIEWS, 'views');
var ensureIndexesWithFilterByActive$c = actions.ensureIndexesWithFilterByActive(Select.views.getSubstate, 'views', ActionTypes.VIEWS, 'views'); // ============ actions ===========

var apply = function apply(key, actions$1) {
  return function (dispatch, getState) {
    return dispatch(actions.ensureKeys(Select.views.getSubstate, 'views', ActionTypes.VIEWS, [key], 'views')).then(function () {
      var data = Select.views.getDataByKey(getState(), key);

      if (data && data.state) {
        var actionCreators = [];

        _each__default['default'](actions$1, function (storeActions, key) {
          if (storeActions.hasOwnProperty('updateStateFromView') && data.state[key]) {
            actionCreators.push(storeActions.updateStateFromView(data.state[key]));
          }
        });

        if (actions$1.specific) {
          _each__default['default'](actions$1.specific, function (storeActions, key) {
            if (storeActions.hasOwnProperty('updateStateFromView') && data.state[key]) {
              actionCreators.push(storeActions.updateStateFromView(data.state[key]));
            }
          });
        }

        dispatch(actionCreators);
      } else {
        dispatch(actions.actionGeneralError("Views#apply: View or state of view doesn't exist! View key: " + key));
      }
    })["catch"](function (err) {
      dispatch(actions.actionGeneralError("Views#apply: " + err));
    });
  };
}; // ============ export ===========


var Views$1 = {
  add: add$i,
  apply: apply,
  setActiveKey: setActiveKey$a,
  setActiveKeys: setActiveKeys$4,
  create: create$a,
  "delete": deleteItem$9,
  ensureIndexesWithFilterByActive: ensureIndexesWithFilterByActive$c,
  saveEdited: saveEdited$9,
  updateEdited: updateEdited$9,
  useKeys: useKeys$g,
  useKeysClear: useKeysClear$d,
  refreshUses: refreshUses$b,
  useIndexed: useIndexed$g,
  useIndexedClear: useIndexedClear$b
};

// TODO add or update

function addOrOpen(setKey, windowKey, settings, component, props) {
  return function (dispatch, getState) {
    var existingWindow = Select.windows.getWindow(getState(), windowKey);

    if (existingWindow) {
      dispatch(actionOpen$1(setKey, windowKey));
    } else {
      dispatch(actionAdd$3(setKey, windowKey, 'open', settings, component, props));
    }
  };
}

function updateSettings(windowKey, settings) {
  return function (dispatch, getState) {
    var window = Select.windows.getWindow(getState(), windowKey);

    var updatedData = _objectSpread2(_objectSpread2({}, window.data), {}, {
      settings: _objectSpread2(_objectSpread2({}, window.data.settings), settings)
    });

    dispatch(actionUpdate$6(windowKey, updatedData));
  };
} // ============ actions ===========


var actionAdd$3 = function actionAdd(setKey, windowKey, state, settings, component, props) {
  return {
    type: ActionTypes.WINDOWS.ADD,
    setKey: setKey,
    windowKey: windowKey,
    state: state,
    settings: settings,
    component: component,
    props: props
  };
};

var actionOpen$1 = function actionOpen(setKey, windowKey) {
  return {
    type: ActionTypes.WINDOWS.OPEN,
    setKey: setKey,
    windowKey: windowKey
  };
};

var actionRemove$3 = function actionRemove(setKey, windowKey) {
  return {
    type: ActionTypes.WINDOWS.REMOVE,
    setKey: setKey,
    windowKey: windowKey
  };
};

var actionTopWindow = function actionTopWindow(setKey, windowKey) {
  return {
    type: ActionTypes.WINDOWS.TOP,
    setKey: setKey,
    windowKey: windowKey
  };
};

var actionUpdate$6 = function actionUpdate(windowKey, data) {
  return {
    type: ActionTypes.WINDOWS.UPDATE,
    windowKey: windowKey,
    data: data
  };
}; // ============ export ===========


var Windows$1 = {
  addOrOpen: addOrOpen,
  remove: actionRemove$3,
  topWindow: actionTopWindow,
  updateSettings: updateSettings
};

var Action = {
  _deprecatedSelections: _deprecatedSelections$1,
  app: actions$8,
  areas: AreasAction,
  areaRelations: AreaRelationsAction,
  attributes: actions$3,
  attributeData: actions$4,
  attributeDataSources: actions$6,
  attributeRelations: actions$7,
  attributeStatistics: actions$5,
  attributeSets: actions$9,
  cases: actions$a,
  charts: actions$b,
  components: actions$c,
  data: DataActions,
  layerPeriods: LayerPeriods,
  layerTemplates: LayerTemplatesAction,
  layerTrees: LayerTrees$1,
  maps: Maps$1,
  _deprecatedMaps: MapsAction,
  periods: PeriodsAction,
  places: PlacesAction,
  scenarios: Scenarios$1,
  scopes: ScopesAction,
  screens: Screens$1,
  selections: SelectionsAction,
  snapshots: Snapshots$1,
  spatialData: SpatialDataAction,
  spatialDataSources: SpatialDataSourcesAction,
  spatialRelations: SpatialRelationsAction,
  styles: StylesActions,
  tags: Tags$1,
  users: Users$1,
  views: Views$1,
  windows: Windows$1
};

describe('state/_common/actions', function () {
  this.afterEach(function () {
    resetFetch();
  });
  var dispatchedActions = [];

  var dispatch = function dispatch(action) {
    dispatchedActions.push(action);
  };

  var clearDispatchedActions = function clearDispatchedActions() {
    dispatchedActions = [];
  };

  var runFunctionActions = function runFunctionActions(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return new Promise(function (resolve, reject) {
      var promises = [];

      for (var i = 0; i < dispatchedActions.length; i++) {
        var action = dispatchedActions[i];

        if (typeof action === 'function') {
          promises.push(action(dispatch, getState));
          dispatchedActions[i] = null;
        } else if (action instanceof Promise) {
          promises.push(action);
          dispatchedActions[i] = null;
        }
      }

      dispatchedActions = dispatchedActions.filter(function (a) {
        return a !== null;
      });

      if (promises.length > 0) {
        return Promise.all(promises).then(function () {
          return runFunctionActions({
            dispatch: dispatch,
            getState: getState
          });
        }).then(function () {
          return resolve();
        });
      }

      resolve();
    });
  };

  afterEach(function () {
    clearDispatchedActions();
  });
  it('add', function () {
    actions.add({
      ADD: 'ADD'
    })('data', 'filter')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'ADD',
      data: ['data'],
      filter: 'filter'
    }]);
  });
  it('addBatch', function () {
    actions.addBatch({
      ADD_BATCH: 'ADD_BATCH'
    })('data', 'key')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'ADD_BATCH',
      data: ['data'],
      key: 'key'
    }]);
  });
  it('addBatchIndex', function () {
    actions.addBatchIndex({
      INDEX: {
        ADD_BATCH: 'ADD_BATCH_INDEX'
      }
    })('filter', 'order', 'data', 'key')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'ADD_BATCH_INDEX',
      data: 'data',
      filter: 'filter',
      order: 'order',
      key: 'key'
    }]);
  });
  describe('action', function () {
    var tests = [{
      name: 'simple path',
      actionTypes: {
        ACTION: 'STR_ACTION'
      },
      type: 'ACTION',
      payload: {
        p: true
      },
      expectedAction: {
        type: 'STR_ACTION',
        p: true
      }
    }, {
      name: 'complex path',
      actionTypes: {
        SCOPE: {
          ACTION: 'STR_SCOPE_ACTION'
        }
      },
      type: 'SCOPE.ACTION',
      payload: {
        p: true
      },
      expectedAction: {
        type: 'STR_SCOPE_ACTION',
        p: true
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(actions.action(test.actionTypes, test.type, test.payload), test.expectedAction);
      });
    });
  });
  it('actionGeneralError', function () {
    chai.assert.deepStrictEqual(actions.actionGeneralError(new Error()), {
      type: 'ERROR'
    });
  });
  it('creator', function () {
    var action = function action() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return {
        type: 'action',
        args: args
      };
    };

    actions.creator(action)({
      ADD: 'ADD'
    })('arg1')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'action',
      args: [{
        ADD: 'ADD'
      }, 'arg1']
    }]);
  });
  it('apiUpdate', function () {
    var getSubState = function getSubState(state) {
      return state.sub;
    };

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        sub: {
          byKey: {
            k1: {
              data: {
                name: 'old'
              }
            }
          },
          editedByKey: {
            k1: {
              data: {
                name: 'old'
              }
            }
          },
          indexes: [{
            filter: {
              name: 'new'
            }
          }, {
            filter: {
              name: 'old'
            }
          }]
        }
      };
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/user', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          data: {
            users: [{
              key: 'k1',
              data: {
                name: 'new'
              }
            }]
          }
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'PUT'
      });
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(JSON.parse(options.body));
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: options.body
      });
    });
    return actions.apiUpdate(getSubState, 'users', {
      ADD: 'ADD',
      UPDATE: 'UPDATE',
      INDEX: {
        CLEAR_INDEX: 'CLEAR_INDEX'
      }
    }, 'user', [{
      key: 'k1',
      data: {
        name: 'new'
      }
    }])(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ADD',
        filter: undefined,
        data: [{
          key: 'k1',
          data: {
            name: 'new'
          }
        }]
      }, {
        type: 'CLEAR_INDEX',
        filter: {
          name: 'new'
        },
        order: undefined
      }, {
        type: 'CLEAR_INDEX',
        filter: {
          name: 'old'
        },
        order: undefined
      }]);
    });
  });
  it('create', function () {
    var getSubState = function getSubState(state) {
      return state.sub;
    };

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        sub: {
          indexes: [{
            filter: {
              applicationKey: 'ak'
            }
          }]
        }
      };
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/user', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          data: {
            users: [{
              key: 'k1',
              data: {
                applicationKey: 'ak'
              }
            }]
          }
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(JSON.parse(options.body));
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: options.body
      });
    });
    return actions.create(getSubState, 'users', {
      ADD: 'ADD',
      INDEX: {
        CLEAR_INDEX: 'CLEAR_INDEX'
      }
    }, 'user')('k1', 'ak')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ADD',
        filter: undefined,
        data: [{
          key: 'k1',
          data: {
            applicationKey: 'ak'
          }
        }]
      }, {
        type: 'CLEAR_INDEX',
        filter: {
          applicationKey: 'ak'
        },
        order: undefined
      }]);
    });
  });
  it('deleteItem', function () {
    var getSubState = function getSubState(state) {
      return state.sub;
    };

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        sub: {}
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);
        dispatchedActions.push(res);
        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/user', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          data: {
            users: [{
              key: 'k1'
            }]
          }
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'DELETE'
      });
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(JSON.parse(options.body));
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: options.body
      });
    });
    return actions["delete"](getSubState, 'users', {
      MARK_DELETED: 'MARK_DELETED'
    }, 'user')({
      key: 'k1'
    })(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      delete dispatchedActions[0]['date'];
      chai.assert.deepStrictEqual(dispatchedActions, [{
        key: 'k1',
        type: 'MARK_DELETED'
      }, {
        type: 'COMMON.EDITED.REMOVE_PROPERTY_VALUES',
        dataType: 'users',
        keys: ['k1']
      }]);
    });
  });
  it('ensureKeys', function () {
    var getSubState = function getSubState(state) {
      return state.sub;
    };

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        sub: {
          byKey: {
            k2: {
              key: 'k2'
            }
          }
        }
      };
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/user/filtered/users', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            key: {
              "in": ['k1']
            }
          }
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve({
            data: {
              users: [{
                key: 'k1'
              }]
            }
          });
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: options.body
      });
    });
    return actions.ensureKeys(getSubState, 'users', {
      ADD: 'ADD'
    }, ['k1', 'k2'], 'user')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ADD',
        filter: undefined,
        data: [{
          key: 'k1'
        }]
      }]);
    });
  });
  describe('ensureIndexed', function () {
    it('already loaded', function () {
      var getSubState = function getSubState(state) {
        return state.sub;
      };

      var getState = function getState() {
        return {
          app: {
            localConfiguration: {
              apiBackendProtocol: 'http',
              apiBackendHost: 'localhost',
              apiBackendPath: ''
            }
          },
          sub: {
            indexes: [{
              filter: {
                name: 'fil'
              },
              order: 'asc',
              count: 5,
              changedOn: '2020-01-01',
              index: ['k1', 'k2', 'k3', 'k4', 'k5']
            }]
          }
        };
      };

      actions.ensureIndexed(getSubState, 'users', {
        name: 'fil'
      }, 'asc', 0, 5, {}, 'user')(dispatch, getState).then(function () {
        return runFunctionActions({
          dispatch: dispatch,
          getState: getState
        });
      }).then(function () {
        chai.assert.deepStrictEqual(dispatchedActions, []);
      });
    });
    it('missing keys', function () {
      var getSubState = function getSubState(state) {
        return state.sub;
      };

      var getState = function getState() {
        return {
          app: {
            localConfiguration: {
              apiBackendProtocol: 'http',
              apiBackendHost: 'localhost',
              apiBackendPath: ''
            }
          },
          sub: {
            indexes: [{
              filter: {
                name: 'fil'
              },
              order: 'asc',
              count: 5,
              changedOn: '2020-01-01',
              index: [null, 'k1', 'k2', 'k3']
            }]
          }
        };
      };

      var dispatch = function dispatch(action) {
        if (typeof action === 'function') {
          var res = action(dispatch, getState);

          if (res != null) {
            dispatchedActions.push(res);
          }

          return res;
        }

        dispatchedActions.push(action);
      };

      setFetch(function (url, options) {
        chai.assert.strictEqual('http://localhost/backend/rest/user/filtered/users', slash__default['default'](url));
        chai.assert.deepStrictEqual(options, {
          body: JSON.stringify({
            filter: {
              name: 'fil',
              key: {
                notin: ['k1', 'k2', 'k3']
              }
            },
            offset: 0,
            order: 'asc',
            limit: 100
          }),
          credentials: 'include',
          headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json'
          },
          method: 'POST'
        });
        var body = {
          data: {
            users: {
              k3: {},
              k4: {}
            }
          },
          total: 5,
          changes: {
            users: '2020-01-01'
          }
        };
        return Promise.resolve({
          ok: true,
          json: function json() {
            return Promise.resolve(body);
          },
          headers: {
            get: function get(name) {
              return {
                'Content-type': 'application/json'
              }[name];
            }
          },
          data: JSON.stringify(body)
        });
      });
      return actions.ensureIndexed(getSubState, 'users', {
        name: 'fil'
      }, 'asc', 1, 5, {
        INDEX: {
          ADD: 'ADD_INDEX'
        }
      }, 'user')(dispatch, getState).then(function () {
        return runFunctionActions({
          dispatch: dispatch,
          getState: getState
        });
      }).then(function () {
        chai.assert.deepStrictEqual(dispatchedActions, [{
          type: 'ADD_INDEX',
          filter: {
            name: 'fil',
            key: {
              notin: ['k1', 'k2', 'k3']
            }
          },
          order: 'asc',
          start: 1,
          data: {
            k3: {},
            k4: {}
          },
          changedOn: '2020-01-01',
          count: 5
        }]);
      });
    });
    it('nothing loaded', function () {
      var getSubState = function getSubState(state) {
        return state.sub;
      };

      var getState = function getState() {
        return {
          app: {
            localConfiguration: {
              apiBackendProtocol: 'http',
              apiBackendHost: 'localhost',
              apiBackendPath: ''
            }
          },
          sub: {
            indexes: []
          }
        };
      };

      var dispatch = function dispatch(action) {
        if (typeof action === 'function') {
          var res = action(dispatch, getState);

          if (res != null) {
            dispatchedActions.push(res);
          }

          return res;
        }

        dispatchedActions.push(action);
      };

      setFetch(function (url, options) {
        chai.assert.strictEqual('http://localhost/backend/rest/user/filtered/users', slash__default['default'](url));
        chai.assert.deepStrictEqual(options, {
          body: JSON.stringify({
            filter: {
              name: 'fil'
            },
            offset: 0,
            order: 'asc',
            limit: 100
          }),
          credentials: 'include',
          headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json'
          },
          method: 'POST'
        });
        var body = {
          data: {
            users: {
              k1: {},
              k2: {},
              k3: {},
              k4: {}
            }
          },
          total: 5,
          changes: {
            users: '2020-01-01'
          }
        };
        return Promise.resolve({
          ok: true,
          json: function json() {
            return Promise.resolve(body);
          },
          headers: {
            get: function get(name) {
              return {
                'Content-type': 'application/json'
              }[name];
            }
          },
          data: JSON.stringify(body)
        });
      });
      return actions.ensureIndexed(getSubState, 'users', {
        name: 'fil'
      }, 'asc', 1, 5, {
        INDEX: {
          ADD: 'ADD_INDEX'
        }
      }, 'user')(dispatch, getState).then(function () {
        return runFunctionActions({
          dispatch: dispatch,
          getState: getState
        });
      }).then(function () {
        chai.assert.deepStrictEqual(dispatchedActions, [{
          type: 'ADD_INDEX',
          filter: {
            name: 'fil'
          },
          order: 'asc',
          start: 1,
          data: {
            k1: {},
            k2: {},
            k3: {},
            k4: {}
          },
          changedOn: '2020-01-01',
          count: 5
        }]);
      });
    });
  });
  it('ensureIndexesWithFilterByActive', function () {
    var getSubState = function getSubState(state) {
      return state.sub;
    };

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        sub: {
          inUse: {
            indexes: [[{
              filterByActive: {
                name: 'fil'
              },
              filter: {
                name: 'fil'
              },
              order: 'asc',
              start: 1,
              length: 5
            }]]
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/user/filtered/users', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          users: {
            k1: {},
            k2: {},
            k3: {},
            k4: {}
          }
        },
        total: 5,
        changes: {
          users: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions.ensureIndexesWithFilterByActive(getSubState, 'users', {
      INDEX: {
        ADD: 'ADD_INDEX'
      }
    }, 'user')({
      name: 'fil'
    })(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ADD_INDEX',
        filter: {
          name: 'fil'
        },
        order: 'asc',
        start: 1,
        data: {
          k1: {},
          k2: {},
          k3: {},
          k4: {}
        },
        changedOn: '2020-01-01',
        count: 5
      }]);
    });
  });
  it('ensureKeys', function () {
    var getSubState = function getSubState(state) {
      return state.sub;
    };

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        sub: {
          byKey: {
            k1: {}
          }
        }
      };
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/user/filtered/users', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            key: {
              "in": ['k2', 'k3']
            }
          }
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          users: [{
            key: 'k2'
          }]
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions.ensureKeys(getSubState, 'users', {
      ADD_UNRECEIVED: 'ADD_UNRECEIVED',
      ADD: 'ADD'
    }, ['k1', 'k2', 'k3'], 'user')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ADD',
        filter: undefined,
        data: [{
          key: 'k2'
        }]
      }, {
        type: 'ADD_UNRECEIVED',
        keys: ['k3']
      }]);
    });
  });
  it('loadAll', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        }
      };
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/user/filtered/users', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          users: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          users: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions.loadAll('users', {
      ADD: 'ADD'
    }, 'user')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ADD',
        filter: undefined,
        data: [{
          k1: {},
          k2: {}
        }]
      }]);
    });
  });
  it('loadFiltered', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        }
      };
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/user/filtered/users', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          users: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          users: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions.loadFiltered('users', {
      ADD: 'ADD'
    }, {
      name: 'fil'
    }, 'user')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ADD',
        filter: undefined,
        data: [{
          k1: {},
          k2: {}
        }]
      }]);
    });
  });
  it('useIndexedBatch', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        scopes: {
          activeKey: 's1'
        },
        periods: {
          activeKey: 'pe1'
        },
        places: {
          activeKey: 'pl1'
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/user/filtered/users', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          order: 'asc'
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          users: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          users: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions.useIndexedBatch('users', {
      USE: {
        INDEXED_BATCH: {
          REGISTER: 'REGISTER'
        }
      },
      INDEX: {
        ADD_BATCH: 'ADD_BATCH'
      }
    }, 'user')({
      name: 'fil'
    }, {
      name: 'fil'
    }, 'asc', 'cid', 'k1', {})(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'REGISTER',
        componentId: 'cid',
        filterByActive: {
          name: 'fil'
        },
        filter: {
          name: 'fil'
        },
        order: 'asc'
      }, {
        type: 'ADD_BATCH',
        filter: {
          name: 'fil'
        },
        order: 'asc',
        data: {
          k1: {},
          k2: {}
        },
        key: 'k1'
      }]);
    });
  });
  it('loadIndexedPage', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/user/filtered/users', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          users: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          users: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions.loadIndexedPage('users', {
      name: 'fil'
    }, 'asc', 1, '2020-01-01', {
      INDEX: {
        ADD: 'ADD_INDEX'
      }
    }, 'user')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ADD_INDEX',
        filter: {
          name: 'fil'
        },
        order: 'asc',
        count: 2,
        start: 1,
        data: {
          k1: {},
          k2: {}
        },
        changedOn: '2020-01-01'
      }]);
    });
  });
  it('loadKeysPage', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/user/filtered/users', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            key: {
              "in": ['k1', 'k2']
            }
          }
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          users: [{
            key: 'k1'
          }]
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions.loadKeysPage('users', {
      ADD: 'ADD',
      ADD_UNRECEIVED: 'ADD_UNRECEIVED'
    }, ['k1', 'k2'], 'user')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ADD',
        filter: undefined,
        data: [{
          key: 'k1'
        }]
      }, {
        keys: ['k2'],
        type: 'ADD_UNRECEIVED'
      }]);
    });
  });
  it('setActiveKey', function () {
    actions.setActiveKey({
      SET_ACTIVE_KEY: 'SET_ACTIVE_KEY'
    })('k1')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'SET_ACTIVE_KEY',
      key: 'k1'
    }]);
  });
  it('setActiveKeys', function () {
    actions.setActiveKeys({
      SET_ACTIVE_KEYS: 'SET_ACTIVE_KEYS'
    })(['k1', 'k2'])(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'SET_ACTIVE_KEYS',
      keys: ['k1', 'k2']
    }]);
  });
  describe('receiveUpdated', function () {
    it('no updates', function () {
      var getSubState = function getSubState(state) {
        return state.sub;
      };

      var getState = function getState() {
        return {
          sub: {}
        };
      };

      var result = {
        data: {
          users: []
        }
      };
      actions.receiveUpdated(getSubState, {}, result, 'users', 'user')(dispatch, getState);
      chai.assert.deepStrictEqual(dispatchedActions, []);
    });
    it('some updates', function () {
      var getSubState = function getSubState(state) {
        return state.sub;
      };

      var getState = function getState() {
        return {
          sub: {
            editedByKey: {
              k1: {
                key: 'k1',
                data: {
                  propScalarSame: 'propScalarSame',
                  propScalarChanged: 'propScalarChanged',
                  propObjSame: {
                    same: 'same'
                  },
                  propObjChanged: {
                    changed: 'changed'
                  },
                  propArrSame: ['same'],
                  propArrChanged: ['changed']
                }
              }
            }
          }
        };
      };

      var result = {
        data: {
          users: [{
            key: 'k1',
            data: {
              propScalarSame: 'propScalarSame',
              propScalarChanged: 'propScalarChanged2',
              propObjSame: {
                same: 'same'
              },
              propObjChanged: {
                changed: 'changed2'
              },
              propArrSame: ['same'],
              propArrChanged: ['changed2']
            }
          }]
        }
      };
      actions.receiveUpdated(getSubState, {
        ADD: 'ADD',
        EDITED: {
          REMOVE_PROPERTY: 'REMOVE_PROPERTY'
        }
      }, result, 'users', 'user')(dispatch, getState);
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ADD',
        filter: undefined,
        data: [{
          key: 'k1',
          data: {
            propScalarSame: 'propScalarSame',
            propScalarChanged: 'propScalarChanged2',
            propObjSame: {
              same: 'same'
            },
            propObjChanged: {
              changed: 'changed2'
            },
            propArrSame: ['same'],
            propArrChanged: ['changed2']
          }
        }]
      }, {
        key: 'k1',
        property: 'propScalarSame',
        type: 'REMOVE_PROPERTY'
      }, {
        key: 'k1',
        property: 'propObjSame',
        type: 'REMOVE_PROPERTY'
      }, {
        key: 'k1',
        property: 'propArrSame',
        type: 'REMOVE_PROPERTY'
      }]);
    });
  });
  it('receiveIndexed', function () {
    actions.receiveIndexed({
      ADD: 'ADD',
      INDEX: {
        ADD: 'ADD_INDEX'
      }
    }, {
      data: {
        users: [{
          key: 'k1'
        }]
      },
      total: 1,
      changes: {
        users: '2020-01-01'
      }
    }, 'users', 'fil', 'asc', 1)(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'ADD',
      data: [{
        key: 'k1'
      }],
      filter: 'fil'
    }, {
      type: 'ADD_INDEX',
      count: 1,
      changedOn: '2020-01-01',
      filter: 'fil',
      order: 'asc',
      start: 1,
      data: [{
        key: 'k1'
      }]
    }]);
  });
  it('receiveKeys', function () {
    actions.receiveKeys({
      ADD: 'ADD',
      ADD_UNRECEIVED: 'ADD_UNRECEIVED'
    }, {
      data: {
        users: [{
          key: 'k1'
        }]
      }
    }, 'users', ['k1', 'k2'])(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'ADD',
      data: [{
        key: 'k1'
      }],
      filter: undefined
    }, {
      type: 'ADD_UNRECEIVED',
      keys: ['k2']
    }]);
  });
  it('refreshUses', function () {
    var getSubState = function getSubState(state) {
      return state.sub;
    };

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        sub: {
          inUse: {
            keys: ['k1', 'k2'],
            indexes: [[{
              filter: {
                name: 'fil'
              },
              order: 'asc',
              start: 1,
              length: 3
            }]]
          },
          byKey: {
            k1: {
              key: 'k1'
            },
            k2: {
              key: 'k2'
            }
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/user/filtered/users', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          users: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          users: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions.refreshUses(getSubState, 'users', {
      INDEX: {
        CLEAR_ALL: 'CLEAR_ALL',
        ADD: 'ADD'
      }
    }, 'user')()(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'CLEAR_ALL'
      }, {
        filter: {
          name: 'fil'
        },
        order: 'asc',
        count: 2,
        start: 1,
        data: {
          k1: {},
          k2: {}
        },
        changedOn: '2020-01-01',
        type: 'ADD'
      }]);
    });
  });
  it('saveEdited', function () {
    var getSubState = function getSubState(state) {
      return state.sub;
    };

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        sub: {
          byKey: {
            k1: {
              key: 'k1'
            }
          },
          editedByKey: {
            k1: {
              key: 'k1',
              data: {
                prop: 'val'
              }
            }
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/user', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          data: {
            users: [{
              key: 'k1',
              data: {
                prop: 'val'
              }
            }]
          }
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'PUT'
      });
      var body = {
        data: {
          users: [{
            key: 'k1',
            data: {
              prop: 'val'
            }
          }]
        },
        total: 2,
        changes: {
          users: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions.saveEdited(getSubState, 'users', {
      ADD: 'ADD',
      EDITED: {
        REMOVE_PROPERTY: 'REMOVE_PROPERTY'
      }
    }, 'user')('k1')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ADD',
        data: [{
          key: 'k1',
          data: {
            prop: 'val'
          }
        }],
        filter: undefined
      }, {
        type: 'REMOVE_PROPERTY',
        key: 'k1',
        property: 'prop'
      }]);
    });
  });
  describe('updateSubstateFromView', function () {
    it('activeKey', function () {
      actions.updateSubstateFromView({
        SET_ACTIVE_KEY: 'SET_ACTIVE_KEY'
      })({
        activeKey: 'ak'
      })(dispatch);
      chai.assert.deepStrictEqual(dispatchedActions, [{
        key: 'ak',
        type: 'SET_ACTIVE_KEY'
      }]);
    });
    it('activeKeys', function () {
      actions.updateSubstateFromView({
        SET_ACTIVE_KEYS: 'SET_ACTIVE_KEYS'
      })({
        activeKeys: ['k1', 'k2']
      })(dispatch);
      chai.assert.deepStrictEqual(dispatchedActions, [{
        keys: ['k1', 'k2'],
        type: 'SET_ACTIVE_KEYS'
      }]);
    });
  });
  it('updateEdited', function () {
    var getSubState = function getSubState(state) {
      return state.sub;
    };

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        sub: {
          byKey: {
            k1: {
              key: 'k1'
            }
          },
          editedByKey: {
            k1: {
              key: 'k1',
              data: {
                prop: 'val'
              }
            }
          }
        }
      };
    };

    actions.updateEdited(getSubState, {
      EDITED: {
        UPDATE: 'UPDATE'
      }
    })('users', 'k1', {
      key: 'k1',
      data: {
        prop: 'val'
      }
    })(dispatch, getState);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'UPDATE',
      data: [{
        key: 'users',
        data: {
          k1: {
            key: 'k1',
            data: {
              prop: 'val'
            }
          }
        }
      }]
    }]);
  });
  it('useKeys', function () {
    var getSubState = function getSubState(state) {
      return state.sub;
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        sub: {
          byKey: {
            k1: {
              key: 'k1'
            },
            k2: {
              key: 'k2'
            }
          }
        }
      };
    };

    return actions.useKeys(getSubState, 'users', {
      USE: {
        KEYS: {
          REGISTER: 'REGISTER'
        }
      }
    }, 'user')(['k1', 'k2'], 'cid')(dispatch).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        componentId: 'cid',
        keys: ['k1', 'k2'],
        type: 'REGISTER'
      }]);
    });
  });
  it('useKeysClear', function () {
    actions.useKeysClear({
      USE: {
        KEYS: {
          CLEAR: 'CLEAR'
        }
      }
    })('cid')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      componentId: 'cid',
      type: 'CLEAR'
    }]);
  });
  it('useIndexed', function () {
    var getSubState = function getSubState(state) {
      return state.sub;
    };

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributes: {
          activeKey: 'k1'
        },
        scopes: {
          activeKey: 'k1'
        },
        periods: {
          activeKey: 'k1'
        },
        places: {
          activeKey: 'k1'
        },
        sub: {}
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/user/filtered/users', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          users: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          users: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions.useIndexed(getSubState, 'users', {
      USE: {
        INDEXED: {
          REGISTER: 'REGISTER'
        }
      },
      INDEX: {
        ADD: 'ADD'
      }
    }, 'user')({
      name: 'afil'
    }, {
      name: 'fil'
    }, 'asc', 1, 5, 'cid')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        componentId: 'cid',
        filterByActive: {
          name: 'afil'
        },
        filter: {
          name: 'fil'
        },
        order: 'asc',
        start: 1,
        length: 5,
        type: 'REGISTER'
      }, {
        filter: {
          name: 'fil'
        },
        order: 'asc',
        count: 2,
        start: 1,
        data: {
          k1: {},
          k2: {}
        },
        changedOn: '2020-01-01',
        type: 'ADD'
      }]);
    });
  });
  it('clearIndex', function () {
    actions.clearIndex({
      INDEX: {
        CLEAR_INDEX: 'CLEAR_INDEX'
      }
    })('fil', 'asc')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      filter: 'fil',
      order: 'asc',
      type: 'CLEAR_INDEX'
    }]);
  });
  it('useIndexedRegister', function () {
    chai.assert.deepStrictEqual(actions.useIndexedRegister({
      USE: {
        INDEXED: {
          REGISTER: 'REGISTER'
        }
      }
    }, 'cid', {
      name: 'afil'
    }, {
      name: 'fil'
    }, 'asc', 1, 5), {
      type: 'REGISTER',
      componentId: 'cid',
      filterByActive: {
        name: 'afil'
      },
      filter: {
        name: 'fil'
      },
      order: 'asc',
      start: 1,
      length: 5
    });
  });
  it('useIndexedClear', function () {
    actions.useIndexedClear({
      USE: {
        INDEXED: {
          CLEAR: 'CLEAR'
        }
      }
    })('cid')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      componentId: 'cid',
      type: 'CLEAR'
    }]);
  });
  it('useIndexedClearAll', function () {
    actions.useIndexedClearAll({
      USE: {
        INDEXED: {
          CLEAR_ALL: 'CLEAR_ALL'
        }
      }
    })()(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'CLEAR_ALL'
    }]);
  });
  it('setInitial', function () {
    actions.setInitial({
      SET_INITIAL: 'SET_INITIAL'
    })()(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'SET_INITIAL'
    }]);
  });
  it('actionDataSetOutdated', function () {
    chai.assert.deepStrictEqual(actions.actionDataSetOutdated(), {
      type: 'COMMON.DATA.SET_OUTDATED'
    });
  });
  it('actionSetActiveKey', function () {
    actions.setActiveKey({
      SET_ACTIVE_KEY: 'SET_ACTIVE_KEY'
    })('k1')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      key: 'k1',
      type: 'SET_ACTIVE_KEY'
    }]);
  });
});

describe('state/_common/helpers', function () {
  describe('getIndex', function () {
    var tests = [{
      name: 'empty indexes',
      indexes: [],
      filter: 'fil',
      order: 'asc',
      expectedResult: null
    }, {
      name: 'indexes',
      indexes: [{
        filter: 'fil2',
        order: 'desc'
      }, {
        filter: 'fil',
        order: 'desc'
      }, {
        filter: 'fil',
        order: 'asc'
      }, {
        filter: 'fil2',
        order: 'asc'
      }],
      filter: 'fil',
      order: 'asc',
      expectedResult: {
        filter: 'fil',
        order: 'asc'
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonHelpers.getIndex(test.indexes, test.filter, test.order), test.expectedResult);
      });
    });
  });
  describe('getUniqueIndexes', function () {
    var tests = [{
      name: 'empty',
      indexes: [],
      expectedResult: null
    }, {
      name: 'unique indexes',
      indexes: [{
        filter: 'fil2',
        order: 'desc'
      }, {
        filter: 'fil',
        order: 'desc'
      }, {
        filter: 'fil',
        order: 'asc'
      }, {
        filter: 'fil2',
        order: 'asc'
      }],
      expectedResult: [{
        filter: 'fil2',
        order: 'desc'
      }, {
        filter: 'fil',
        order: 'desc'
      }, {
        filter: 'fil',
        order: 'asc'
      }, {
        filter: 'fil2',
        order: 'asc'
      }]
    }, {
      name: 'non unique indexes',
      indexes: [{
        filter: 'fil2',
        order: 'desc'
      }, {
        filter: 'fil',
        order: 'desc'
      }, {
        filter: 'fil',
        order: 'asc'
      }, {
        filter: 'fil2',
        order: 'asc'
      }, // exact duplicities
      {
        filter: 'fil2',
        order: 'desc'
      }, {
        filter: 'fil',
        order: 'desc'
      }, {
        filter: 'fil',
        order: 'asc'
      }, {
        filter: 'fil2',
        order: 'asc'
      }, // duplicities with additional prop
      {
        filter: 'fil2',
        order: 'desc',
        p: true
      }, {
        filter: 'fil',
        order: 'desc',
        p: true
      }, {
        filter: 'fil',
        order: 'asc',
        p: true
      }, {
        filter: 'fil2',
        order: 'asc',
        p: true
      }],
      expectedResult: [{
        filter: 'fil2',
        order: 'desc'
      }, {
        filter: 'fil',
        order: 'desc'
      }, {
        filter: 'fil',
        order: 'asc'
      }, {
        filter: 'fil2',
        order: 'asc'
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonHelpers.getUniqueIndexes(test.indexes), test.expectedResult);
      });
    });
  });
  describe('isCorrespondingIndex', function () {
    var tests = [{
      name: 'corresponding',
      index: {
        filter: 'fil',
        order: 'asc'
      },
      filter: 'fil',
      order: 'asc',
      expectedResult: true
    }, {
      name: 'corresponding with extra key',
      index: {
        filter: 'fil',
        order: 'asc',
        extraKey: 'val'
      },
      filter: 'fil',
      order: 'asc',
      expectedResult: true
    }, {
      name: 'different order',
      index: {
        filter: 'fil',
        order: 'asc'
      },
      filter: 'fil',
      order: 'desc',
      expectedResult: false
    }, {
      name: 'different filter',
      index: {
        filter: 'fil',
        order: 'asc'
      },
      filter: 'fil2',
      order: 'asc',
      expectedResult: false
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.strictEqual(commonHelpers.isCorrespondingIndex(test.index, test.filter, test.order), test.expectedResult);
      });
    });
  });
  describe('itemFitFilter', function () {
    var tests = [{
      name: 'fits null filter',
      filter: null,
      item: {
        data: {
          sameProp: 'John',
          likeProp: 'always matches',
          inProp: 'two',
          notInProp: 'this',
          linkKey: 'val'
        }
      },
      expectedResult: true
    }, {
      name: 'fits all filter types',
      filter: {
        sameProp: 'John',
        likeProp: {
          like: true
        },
        inProp: {
          "in": ['one', 'two', 'three']
        },
        notInProp: {
          notin: ['notThis', 'andThis']
        },
        link: 'val'
      },
      item: {
        data: {
          sameProp: 'John',
          likeProp: 'always matches',
          inProp: 'two',
          notInProp: 'this',
          linkKey: 'val'
        }
      },
      expectedResult: true
    }, {
      name: 'does not fit same prop',
      filter: {
        sameProp: 'John'
      },
      item: {
        data: {
          sameProp: 'Johnny'
        }
      },
      expectedResult: false
    }, {
      name: 'does not fit in prop',
      filter: {
        inProp: {
          "in": ['one', 'two', 'three']
        }
      },
      item: {
        data: {
          inProp: 'four'
        }
      },
      expectedResult: false
    }, {
      name: 'does not fit notin prop',
      filter: {
        notInProp: {
          notin: ['notThis', 'andThis']
        }
      },
      item: {
        data: {
          notInProp: 'notThis'
        }
      },
      expectedResult: false
    }, {
      name: 'does not fit link prop',
      filter: {
        link: 'val'
      },
      item: {
        data: {
          linkKey: 'notval'
        }
      },
      expectedResult: false
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.strictEqual(commonHelpers.itemFitFilter(test.filter, test.item), test.expectedResult);
      });
    });
  });
  describe('removeIndex', function () {
    var indexes = [{
      filter: {},
      order: null
    }, {
      filter: {
        test: 1
      },
      order: []
    }];
    it('return new instance of indexes without filtered index', function () {
      chai.assert.deepStrictEqual(commonHelpers.removeIndex(indexes, {}, null), [{
        filter: {
          test: 1
        },
        order: []
      }]);
    });
    it('return same instance of indexes', function () {
      chai.assert.equal(commonHelpers.removeIndex(indexes, {}, []), indexes);
    });
  });
});

describe('convertModifiersToRequestFriendlyFormat', function () {
  it('should merge keys, defined keys have a priority', function () {
    var modifiers = {
      scopeKey: "A",
      placeKeys: ["B", "C"],
      scenarioKey: "F",
      caseKeys: ["I", "J"]
    };
    var expectedResult = {
      scopeKey: "A",
      placeKey: {
        "in": ["B", "C"]
      },
      scenarioKey: "F",
      caseKey: {
        "in": ["I", "J"]
      }
    };
    var output = commonHelpers.convertModifiersToRequestFriendlyFormat(modifiers);
    chai.assert.deepStrictEqual(output, expectedResult);
  });
  it('should return null if input is null', function () {
    var output = commonHelpers.convertModifiersToRequestFriendlyFormat(null);
    chai.assert.isNull(output);
  });
});

describe('mergeMetadataKeys', function () {
  var defined = {
    scopeKey: "A",
    placeKeys: ["B", "C"]
  };
  var active = {
    placeKeys: ["D", "E"],
    scenarioKey: "F"
  };
  it('should merge keys, defined keys have a priority', function () {
    var expectedResult = {
      scopeKey: "A",
      placeKeys: ["B", "C"],
      scenarioKey: "F"
    };
    var output = commonHelpers.mergeMetadataKeys(defined, active);
    chai.assert.deepStrictEqual(output, expectedResult);
  });
  it('should return defined keys only if active is null and vice versa', function () {
    var output = commonHelpers.mergeMetadataKeys(defined, null);
    chai.assert.deepStrictEqual(output, defined);
    var output2 = commonHelpers.mergeMetadataKeys(null, active);
    chai.assert.deepStrictEqual(output2, active);
  });
  it('should return null if both parameters are null', function () {
    var output = commonHelpers.mergeMetadataKeys(null, null);
    chai.assert.isNull(output);
  });
});

var DEFAULT_INITIAL_STATE = {
  activeKey: null,
  byKey: null,
  count: null,
  editedByKey: null,
  indexes: null,
  inUse: {
    indexes: null,
    keys: null
  },
  lastChangedOn: null,
  loading: false,
  loadingKeys: null
};
var common = {
  add: function add(state, action) {
    var newData = _objectSpread2({}, state.byKey);

    if (action.data && action.data.length) {
      action.data.forEach(function (model) {
        newData[model.key] = _objectSpread2(_objectSpread2({}, newData[model.key]), model);
        delete newData[model.key].outdated;
        delete newData[model.key].unreceived;
      });
    }

    return _objectSpread2(_objectSpread2({}, state), {}, {
      byKey: newData
    });
  },
  addBatch: function addBatch(state, action) {
    var newData = _objectSpread2({}, state.byKey);

    if (action.data && action.data.length) {
      action.data.forEach(function (model) {
        newData[model[action.key]] = _objectSpread2(_objectSpread2({}, newData[model[action.key]]), model);
        delete newData[model[action.key]].outdated;
        delete newData[model[action.key]].unreceived;
      });
    }

    return _objectSpread2(_objectSpread2({}, state), {}, {
      byKey: newData
    });
  },
  addUnreceivedKeys: function addUnreceivedKeys(state, action) {
    var newData = _objectSpread2({}, state.byKey);

    if (action.keys && action.keys.length) {
      action.keys.forEach(function (key) {
        newData[key] = {
          key: key,
          unreceived: true
        };
      });
    }

    return _objectSpread2(_objectSpread2({}, state), {}, {
      byKey: newData
    });
  },
  addIndex: function addIndex(state, action) {
    var indexes = [];
    var selectedIndex = {};

    if (state.indexes) {
      state.indexes.forEach(function (index) {
        if (_isEqual__default['default'](index.filter, action.filter) && _isEqual__default['default'](index.order, action.order)) {
          selectedIndex = index;
        } else {
          indexes.push(index);
        }
      });
    }

    var index;

    if (action.data.length) {
      index = _objectSpread2({}, selectedIndex.index);
      action.data.forEach(function (model, i) {
        index[action.start + i] = model.key;
      });
    }

    selectedIndex = {
      filter: selectedIndex.filter || action.filter,
      order: selectedIndex.order || action.order,
      count: action.count,
      changedOn: action.changedOn,
      index: index || selectedIndex.index
    };
    indexes.push(selectedIndex);
    return _objectSpread2(_objectSpread2({}, state), {}, {
      indexes: indexes
    });
  },
  addBatchIndex: function addBatchIndex(state, action) {
    var indexes = [];
    var selectedIndex = {};

    if (state.indexes) {
      state.indexes.forEach(function (index) {
        if (_isEqual__default['default'](index.filter, action.filter) && _isEqual__default['default'](index.order, action.order)) {
          selectedIndex = index;
        } else {
          indexes.push(index);
        }
      });
    }

    var index;

    if (action.data.length) {
      index = _objectSpread2({}, selectedIndex.index);
      action.data.forEach(function (model, i) {
        index[i] = model[action.key];
      });
    }

    selectedIndex = {
      filter: selectedIndex.filter || action.filter,
      order: selectedIndex.order || action.order,
      index: index || selectedIndex.index
    };
    indexes.push(selectedIndex);
    return _objectSpread2(_objectSpread2({}, state), {}, {
      indexes: indexes
    });
  },
  registerUseIndexed: function registerUseIndexed(state, action) {
    var newUse = {
      filterByActive: action.filterByActive,
      filter: action.filter,
      order: action.order,
      start: action.start,
      length: action.length
    };
    var existingUse = false;

    if (state.inUse.indexes && state.inUse.indexes[action.componentId]) {
      existingUse = _find__default['default'](state.inUse.indexes[action.componentId], newUse);
    } // add use if it doesn't already exist


    if (!existingUse) {
      return _objectSpread2(_objectSpread2({}, state), {}, {
        inUse: _objectSpread2(_objectSpread2({}, state.inUse), {}, {
          indexes: _objectSpread2(_objectSpread2({}, state.inUse.indexes), {}, _defineProperty({}, action.componentId, state.inUse.indexes && state.inUse.indexes[action.componentId] ? [].concat(_toConsumableArray(state.inUse.indexes[action.componentId]), [newUse]) : [newUse]))
        })
      });
    } else {
      return state;
    }
  },
  registerBatchUseIndexed: function registerBatchUseIndexed(state, action) {
    var newUse = {
      filterByActive: action.filterByActive,
      filter: action.filter,
      order: action.order
    };
    var existingUse = false;

    if (state.inUse.indexes && state.inUse.indexes[action.componentId]) {
      existingUse = _find__default['default'](state.inUse.indexes[action.componentId], newUse);
    } // add use if it doesn't already exist


    if (!existingUse) {
      return _objectSpread2(_objectSpread2({}, state), {}, {
        inUse: _objectSpread2(_objectSpread2({}, state.inUse), {}, {
          indexes: _objectSpread2(_objectSpread2({}, state.inUse.indexes), {}, _defineProperty({}, action.componentId, state.inUse.indexes && state.inUse.indexes[action.componentId] ? [].concat(_toConsumableArray(state.inUse.indexes[action.componentId]), [newUse]) : [newUse]))
        })
      });
    } else {
      return state;
    }
  },
  useIndexedClear: function useIndexedClear(state, action) {
    if (state.inUse && state.inUse.indexes && state.inUse.indexes.hasOwnProperty(action.componentId)) {
      var indexes = _objectSpread2({}, state.inUse.indexes);

      delete indexes[action.componentId];
      return _objectSpread2(_objectSpread2({}, state), {}, {
        inUse: _objectSpread2(_objectSpread2({}, state.inUse), {}, {
          indexes: _isEmpty__default['default'](indexes) ? null : indexes
        })
      });
    } else {
      // do not mutate if no index was changed
      return state;
    }
  },
  useIndexedClearAll: function useIndexedClearAll(state, action) {
    if (state.inUse && state.inUse.indexes) {
      return _objectSpread2(_objectSpread2({}, state), {}, {
        inUse: _objectSpread2(_objectSpread2({}, state.inUse), {}, {
          indexes: null
        })
      });
    } else {
      // do not mutate if no index was changed
      return state;
    }
  },
  useKeysRegister: function useKeysRegister(state, action) {
    return _objectSpread2(_objectSpread2({}, state), {}, {
      inUse: _objectSpread2(_objectSpread2({}, state.inUse), {}, {
        keys: _objectSpread2(_objectSpread2({}, state.inUse.keys), {}, _defineProperty({}, action.componentId, state.inUse.keys && state.inUse.keys[action.componentId] ? _union__default['default'](state.inUse.keys[action.componentId], action.keys) : action.keys))
      })
    });
  },
  useKeysClear: function useKeysClear(state, action) {
    var keys = _objectSpread2({}, state.inUse.keys);

    delete keys[action.componentId];
    return _objectSpread2(_objectSpread2({}, state), {}, {
      inUse: _objectSpread2(_objectSpread2({}, state.inUse), {}, {
        keys: _isEmpty__default['default'](keys) ? null : keys
      })
    });
  },
  markDeleted: function markDeleted(state, action) {
    if (state.byKey && state.byKey[action.key]) {
      var byKey = _objectSpread2({}, state.byKey);

      byKey[action.key].removed = true;
      return _objectSpread2(_objectSpread2({}, state), {}, {
        byKey: byKey
      });
    } else {
      return state;
    }
  },
  remove: function remove(state, action) {
    var newData = state.byKey ? _omit__default['default'](state.byKey, action.keys) : null;
    return _objectSpread2(_objectSpread2({}, state), {}, {
      byKey: newData
    });
  },
  removeEdited: function removeEdited(state, action) {
    var newData = state.editedByKey ? _omit__default['default'](state.editedByKey, action.keys) : null;
    return _objectSpread2(_objectSpread2({}, state), {}, {
      editedByKey: newData
    });
  },
  removeEditedActive: function removeEditedActive(state) {
    var newData = state.editedByKey ? _omit__default['default'](state.editedByKey, state.activeKey) : null;
    return _objectSpread2(_objectSpread2({}, state), {}, {
      editedByKey: newData
    });
  },
  removeEditedProperty: function removeEditedProperty(state, action) {
    var newEditedModelData = state.editedByKey && state.editedByKey[action.key] && state.editedByKey[action.key].data ? _omit__default['default'](state.editedByKey[action.key].data, action.property) : null;

    if (newEditedModelData && !_isEmpty__default['default'](newEditedModelData)) {
      return _objectSpread2(_objectSpread2({}, state), {}, {
        editedByKey: _objectSpread2(_objectSpread2({}, state.editedByKey), {}, _defineProperty({}, action.key, _objectSpread2(_objectSpread2({}, state.editedByKey[action.key]), {}, {
          data: newEditedModelData
        })))
      });
    } else if (newEditedModelData && _isEmpty__default['default'](newEditedModelData)) {
      var editedModels = _objectSpread2({}, state.editedByKey);

      delete editedModels[action.key];
      return _objectSpread2(_objectSpread2({}, state), {}, {
        editedByKey: editedModels
      });
    } else {
      return state;
    }
  },
  // todo test
  removeEditedPropertyValues: function removeEditedPropertyValues(state, action) {
    var dataTypeSingular = action.dataType.slice(0, -1);
    var keyProperty = dataTypeSingular + "Key";
    var keysProperty = dataTypeSingular + "Keys";

    var editedData = _objectSpread2({}, state.editedByKey);

    if (!_isEmpty__default['default'](editedData)) {
      var updatedEdited = {};
      var propertyUpdated = false;

      _forIn__default['default'](editedData, function (model, key) {
        if (model.data && model.data[keyProperty]) {
          var keyExists = _includes__default['default'](action.keys, model.data[keyProperty]);

          if (keyExists) {
            updatedEdited[key] = _objectSpread2(_objectSpread2({}, model), {}, {
              data: _objectSpread2(_objectSpread2({}, model.data), {}, _defineProperty({}, keyProperty, null))
            });
            propertyUpdated = true;
          } else {
            updatedEdited[key] = model;
          }
        } else if (model.data && model.data[keysProperty]) {
          var updatedKeys = _difference__default['default'](model.data[keysProperty], action.keys);

          if (updatedKeys.length !== model.data[keysProperty]) {
            updatedEdited[key] = _objectSpread2(_objectSpread2({}, model), {}, {
              data: _objectSpread2(_objectSpread2({}, model.data), {}, _defineProperty({}, keysProperty, updatedKeys))
            });
            propertyUpdated = true;
          } else {
            updatedEdited[key] = model;
          }
        } else {
          updatedEdited[key] = model;
        }
      });

      return propertyUpdated ? _objectSpread2(_objectSpread2({}, state), {}, {
        editedByKey: updatedEdited
      }) : state;
    } else {
      return state;
    }
  },
  setActive: function setActive(state, action) {
    return _objectSpread2(_objectSpread2({}, state), {}, {
      activeKey: action.key,
      activeKeys: null
    });
  },
  setActiveMultiple: function setActiveMultiple(state, action) {
    return _objectSpread2(_objectSpread2({}, state), {}, {
      activeKeys: action.keys,
      activeKey: null
    });
  },
  updateEdited: function updateEdited(state, action) {
    var newEditedData = _objectSpread2({}, state.editedByKey);

    if (action.data && action.data.length) {
      action.data.forEach(function (model) {
        if (newEditedData[model.key]) {
          newEditedData[model.key] = _objectSpread2(_objectSpread2({}, newEditedData[model.key]), {}, {
            data: _objectSpread2(_objectSpread2({}, newEditedData[model.key].data), model.data)
          });
        } else {
          newEditedData[model.key] = model;
        }
      });
    }

    return _objectSpread2(_objectSpread2({}, state), {}, {
      editedByKey: newEditedData
    });
  },
  clearIndexes: function clearIndexes(state, action) {
    var indexes = _map__default['default'](state.indexes, function (index) {
      return _objectSpread2(_objectSpread2({}, index), {}, {
        index: null,
        count: null,
        changedOn: null,
        outdated: index.index,
        outdatedCount: index.count
      });
    });

    return _objectSpread2(_objectSpread2({}, state), {}, {
      indexes: indexes.length ? indexes : null
    });
  },

  /**
   * Useful for invalidate data before refresh indexes
   * action.order
   * action.filter
   * */
  clearIndex: function clearIndex(state, action) {
    var indexes = state.indexes.map(function (index) {
      var correspondIndex = commonHelpers.isCorrespondingIndex(index, action.filter, action.order);

      if (correspondIndex) {
        index.outdated = index.index;
        index.outdatedCount = index.count;
        index.index = null;
        index.count = null;
        index.changedOn = null;
      }

      return index;
    });
    return _objectSpread2(_objectSpread2({}, state), {}, {
      indexes: _toConsumableArray(indexes)
    });
  },
  dataSetOutdated: function dataSetOutdated(state, action) {
    if (state.byKey) {
      var byKey = {};

      _each__default['default'](state.byKey, function (model, key) {
        byKey[key] = _objectSpread2(_objectSpread2({}, model), {}, {
          outdated: true
        });
      });

      return _objectSpread2(_objectSpread2({}, state), {}, {
        byKey: byKey
      });
    } else {
      return state;
    }
  },
  cleanupOnLogout: function cleanupOnLogout(state, action) {
    if (state.byKey) {
      var byKey = {};

      _each__default['default'](state.byKey, function (model, key) {
        if (model.permissions && model.permissions.guest.get) {
          byKey[key] = _objectSpread2(_objectSpread2({}, model), {}, {
            permissions: {
              guest: model.permissions.guest
            }
          });
        }
      });

      return _objectSpread2(_objectSpread2({}, state), {}, {
        byKey: byKey
      });
    } else {
      return state;
    }
  }
};

describe('state/_common/reducers', function () {
  describe('add', function () {
    var tests = [{
      name: 'no data',
      state: {
        byKey: null
      },
      action: {},
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty data',
      state: {
        byKey: null
      },
      action: {
        data: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some data',
      state: {
        byKey: null
      },
      action: {
        data: [{
          key: 'k1',
          name: 'first'
        }, {
          key: 'k2',
          name: 'second',
          outdated: true,
          unreceived: true
        }]
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            name: 'first'
          },
          k2: {
            key: 'k2',
            name: 'second'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.add(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addBatch', function () {
    var tests = [{
      name: 'no data',
      state: {
        byKey: null
      },
      action: {},
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty data',
      state: {
        byKey: null
      },
      action: {
        data: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some data',
      state: {
        byKey: null
      },
      action: {
        key: 'someKey',
        data: [{
          key: 'k1',
          someKey: 'sk1',
          name: 'first'
        }, {
          key: 'k2',
          someKey: 'sk2',
          name: 'second',
          outdated: true,
          unreceived: true
        }]
      },
      expectedResult: {
        byKey: {
          sk1: {
            key: 'k1',
            someKey: 'sk1',
            name: 'first'
          },
          sk2: {
            key: 'k2',
            someKey: 'sk2',
            name: 'second'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.addBatch(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addUnreceivedKeys', function () {
    var tests = [{
      name: 'no keys',
      state: {
        byKey: null
      },
      action: {},
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty keys',
      state: {
        byKey: null
      },
      action: {
        keys: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some keys',
      state: {
        byKey: null
      },
      action: {
        keys: ['k1', 'k2']
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            unreceived: true
          },
          k2: {
            key: 'k2',
            unreceived: true
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.addUnreceivedKeys(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addIndex', function () {
    var tests = [{
      name: 'empty data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: 'idx'
        }]
      },
      action: {
        filter: 'fil',
        order: 'asc',
        changedOn: 'some time',
        count: 2,
        data: []
      },
      expectedResult: {
        indexes: [{
          changedOn: 'some time',
          count: 2,
          filter: 'fil',
          index: 'idx',
          order: 'asc'
        }]
      }
    }, {
      name: 'new data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: [{
            key: 'k'
          }, {
            key: 'k.1'
          }, {
            key: 'k.2'
          }]
        }]
      },
      action: {
        filter: 'fil',
        order: 'asc',
        changedOn: 'some time',
        count: 2,
        start: 1,
        data: [{
          key: 'k2'
        }, {
          key: 'k3'
        }]
      },
      expectedResult: {
        indexes: [{
          changedOn: 'some time',
          count: 2,
          filter: 'fil',
          index: {
            0: {
              key: 'k'
            },
            1: 'k2',
            2: 'k3'
          },
          order: 'asc'
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.addIndex(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addBatchIndex', function () {
    var tests = [{
      name: 'empty data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: 'idx'
        }]
      },
      action: {
        filter: 'fil',
        order: 'asc',
        key: 'someKey',
        data: []
      },
      expectedResult: {
        indexes: [{
          filter: 'fil',
          index: 'idx',
          order: 'asc'
        }]
      }
    }, {
      name: 'new data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: [{
            someKey: 'k'
          }, {
            someKey: 'k.1'
          }, {
            someKey: 'k.2'
          }]
        }]
      },
      action: {
        filter: 'fil',
        order: 'asc',
        key: 'someKey',
        data: [{
          someKey: 'k2'
        }, {
          someKey: 'k3'
        }]
      },
      expectedResult: {
        indexes: [{
          filter: 'fil',
          index: {
            0: 'k2',
            1: 'k3',
            2: {
              someKey: 'k.2'
            }
          },
          order: 'asc'
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.addBatchIndex(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('registerUseIndexed', function () {
    var tests = [{
      name: 'existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      },
      action: {
        componentId: 'compId',
        filterByActive: 'fba',
        filter: 'f',
        order: 'asc',
        start: 4,
        length: 2
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      }
    }, {
      name: 'non existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      },
      action: {
        componentId: 'compId',
        filterByActive: '_fba',
        filter: 'f',
        order: 'asc',
        start: 4,
        length: 2
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }, {
              filterByActive: '_fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.registerUseIndexed(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('registerBatchUseIndexed', function () {
    var tests = [{
      name: 'existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc'
            }]
          }
        }
      },
      action: {
        componentId: 'compId',
        filterByActive: 'fba',
        filter: 'f',
        order: 'asc'
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc'
            }]
          }
        }
      }
    }, {
      name: 'non existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc'
            }]
          }
        }
      },
      action: {
        componentId: 'compId',
        filterByActive: '_fba',
        filter: 'f',
        order: 'asc'
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc'
            }, {
              filterByActive: '_fba',
              filter: 'f',
              order: 'asc'
            }]
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.registerBatchUseIndexed(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('useIndexedClear', function () {
    var tests = [{
      name: 'no index',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {
        componentId: 'some2'
      },
      expectedResult: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      }
    }, {
      name: 'matched index',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {
        componentId: 'some3'
      },
      expectedResult: {
        inUse: {
          indexes: {
            some: 'some'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.useIndexedClear(test.state, test.action), test.expectedResult);
      });
    });
  });
  it('useIndexedClearAll', function () {
    var tests = [{
      name: 'clear all',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {},
      expectedResult: {
        inUse: {
          indexes: null
        }
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(common.useIndexedClearAll(test.state, test.action), test.expectedResult);
    });
  });
  describe('useKeysRegister', function () {
    var tests = [{
      name: 'no initial keys',
      state: {
        inUse: {}
      },
      action: {
        componentId: 'comp',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k2']
          }
        }
      }
    }, {
      name: 'with initial keys',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3']
          }
        }
      },
      action: {
        componentId: 'comp',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.useKeysRegister(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('useKeysClear', function () {
    var tests = [{
      name: 'non existing',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      },
      action: {
        componentId: 'comp2'
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      }
    }, {
      name: 'single',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2'],
            comp2: ['kc']
          }
        }
      },
      action: {
        componentId: 'comp'
      },
      expectedResult: {
        inUse: {
          keys: {
            comp2: ['kc']
          }
        }
      }
    }, {
      name: 'last',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      },
      action: {
        componentId: 'comp'
      },
      expectedResult: {
        inUse: {
          keys: null
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.useKeysClear(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('markDeleted', function () {
    var tests = [{
      name: 'non matching key',
      state: {
        byKey: {
          nk: {
            v: 1
          },
          nk2: {
            v: 2
          }
        }
      },
      action: {
        key: 'sk'
      },
      expectedResult: {
        byKey: {
          nk: {
            v: 1
          },
          nk2: {
            v: 2
          }
        }
      }
    }, {
      name: 'matching key',
      state: {
        byKey: {
          sk: {
            v: 0
          },
          nk: {
            v: 1
          },
          nk2: {
            v: 2
          }
        }
      },
      action: {
        key: 'sk'
      },
      expectedResult: {
        byKey: {
          sk: {
            v: 0,
            removed: true
          },
          nk: {
            v: 1
          },
          nk2: {
            v: 2
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.markDeleted(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('remove', function () {
    var tests = [{
      name: 'some',
      state: {
        byKey: {
          k1: 1,
          k2: 2,
          k3: 3
        }
      },
      action: {
        keys: ['k1', 'k2']
      },
      expectedResult: {
        byKey: {
          k3: 3
        }
      }
    }, {
      name: 'all',
      state: {
        byKey: {
          k1: 1,
          k2: 2,
          k3: 3
        }
      },
      action: {
        keys: ['k1', 'k2', 'k3']
      },
      expectedResult: {
        byKey: {}
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(common.remove(test.state, test.action), test.expectedResult);
    });
  });
  describe('removeEdited', function () {
    var tests = [{
      name: 'some',
      state: {
        editedByKey: {
          k1: 1,
          k2: 2,
          k3: 3
        }
      },
      action: {
        keys: ['k1', 'k2']
      },
      expectedResult: {
        editedByKey: {
          k3: 3
        }
      }
    }, {
      name: 'all',
      state: {
        editedByKey: {
          k1: 1,
          k2: 2,
          k3: 3
        }
      },
      action: {
        keys: ['k1', 'k2', 'k3']
      },
      expectedResult: {
        editedByKey: {}
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.removeEdited(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('removeEditedActive', function () {
    var tests = [{
      name: 'some',
      state: {
        activeKey: 'k1',
        editedByKey: {
          k1: 1,
          k2: 2,
          k3: 3
        }
      },
      action: {},
      expectedResult: {
        activeKey: 'k1',
        editedByKey: {
          k2: 2,
          k3: 3
        }
      }
    }, {
      name: 'all',
      state: {
        activeKey: 'k1',
        editedByKey: {
          k1: 1
        }
      },
      action: {},
      expectedResult: {
        activeKey: 'k1',
        editedByKey: {}
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.removeEditedActive(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('removeEditedProperty', function () {
    var tests = [{
      name: 'empty data',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: null
          }
        }
      },
      action: {
        key: 'k2',
        property: 'p'
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: null
          }
        }
      }
    }, {
      name: 'non existing property',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: {
              p: 2,
              p2: 22
            }
          }
        }
      },
      action: {
        key: 'k2',
        property: 'p3'
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: {
              p: 2,
              p2: 22
            }
          }
        }
      }
    }, {
      name: 'matched property',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: {
              p: 2,
              p2: 22
            }
          }
        }
      },
      action: {
        key: 'k2',
        property: 'p'
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: {
              p2: 22
            }
          }
        }
      }
    }, {
      name: 'matched last property',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: {
              p: 2
            }
          }
        }
      },
      action: {
        key: 'k2',
        property: 'p'
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.removeEditedProperty(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('removeEditedPropertyValues', function () {
    var tests = [{
      name: 'updated',
      state: {
        editedByKey: {
          k1: {
            data: {
              name: 'key prop in keys',
              actionKey: 'ak1'
            }
          },
          k2: {
            data: {
              name: 'key prop not in keys',
              actionKey: 'nak2'
            }
          },
          k3: {
            data: {
              name: 'multi key prop in keys',
              actionKeys: ['ak3.1', 'ak3.2']
            }
          },
          k4: {
            data: {
              name: 'multi key prop not in keys',
              actionKeys: ['ak4.1', 'ak4.2']
            }
          }
        }
      },
      action: {
        dataType: 'actions',
        keys: ['ak1', 'ak3.2']
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              name: 'key prop in keys',
              actionKey: null
            }
          },
          k2: {
            data: {
              name: 'key prop not in keys',
              actionKey: 'nak2'
            }
          },
          k3: {
            data: {
              name: 'multi key prop in keys',
              actionKeys: ['ak3.1']
            }
          },
          k4: {
            data: {
              name: 'multi key prop not in keys',
              actionKeys: ['ak4.1', 'ak4.2']
            }
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.removeEditedPropertyValues(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('setActive', function () {
    var tests = [{
      name: 'test',
      state: {
        activeKey: 'k1',
        activeKeys: ['ks1', 'ks2']
      },
      action: {
        key: 'ak'
      },
      expectedResult: {
        activeKey: 'ak',
        activeKeys: null
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.setActive(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('setActiveMultiple', function () {
    var tests = [{
      name: 'setActiveMultiple',
      state: {
        activeKey: 'k1',
        activeKeys: ['ks1', 'ks2']
      },
      action: {
        keys: ['aks1', 'aks2']
      },
      expectedResult: {
        activeKey: null,
        activeKeys: ['aks1', 'aks2']
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(common.setActiveMultiple(test.state, test.action), test.expectedResult);
    });
  });
  describe('updateEdited', function () {
    var tests = [{
      name: 'empty data',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              ep: 2
            }
          },
          k2: {
            data: {
              p: 2
            }
          }
        }
      },
      action: {
        data: []
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              ep: 2
            }
          },
          k2: {
            data: {
              p: 2
            }
          }
        }
      }
    }, {
      name: 'some data',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              ep: 2
            }
          },
          k2: {
            data: {
              p: 2
            }
          }
        }
      },
      action: {
        data: [{
          key: 'k1',
          data: {
            p: 11
          }
        }, {
          key: 'k3',
          data: {
            p: 33
          }
        }]
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 11,
              ep: 2
            }
          },
          k2: {
            data: {
              p: 2
            }
          },
          k3: {
            key: 'k3',
            data: {
              p: 33
            }
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.updateEdited(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('clearIndexes', function () {
    var tests = [{
      name: 'empty',
      state: {
        indexes: []
      },
      action: {},
      expectedResult: {
        indexes: null
      }
    }, {
      name: 'non empty',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: 5,
          index: ['v1', 'v2'],
          changedOn: 'changed on'
        }]
      },
      action: {},
      expectedResult: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: null,
          index: null,
          changedOn: null,
          outdated: ['v1', 'v2'],
          outdatedCount: 5
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.clearIndexes(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('clearIndex', function () {
    var tests = [{
      name: 'without match',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: 5,
          index: ['v1', 'v2'],
          changedOn: 'changed on'
        }, {
          filter: 'fil',
          order: 'desc',
          count: 7,
          index: ['v2.1', 'v2.2'],
          changedOn: 'changed on2'
        }]
      },
      action: {
        filter: 'fil2',
        order: 'asc'
      },
      expectedResult: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: 5,
          index: ['v1', 'v2'],
          changedOn: 'changed on'
        }, {
          filter: 'fil',
          order: 'desc',
          count: 7,
          index: ['v2.1', 'v2.2'],
          changedOn: 'changed on2'
        }]
      }
    }, {
      name: 'with match',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: 5,
          index: ['v1', 'v2'],
          changedOn: 'changed on'
        }, {
          filter: 'fil',
          order: 'desc',
          count: 7,
          index: ['v2.1', 'v2.2'],
          changedOn: 'changed on2'
        }]
      },
      action: {
        filter: 'fil',
        order: 'asc'
      },
      expectedResult: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: null,
          index: null,
          changedOn: null,
          outdated: ['v1', 'v2'],
          outdatedCount: 5
        }, {
          filter: 'fil',
          order: 'desc',
          count: 7,
          index: ['v2.1', 'v2.2'],
          changedOn: 'changed on2'
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.clearIndex(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('dataSetOutdated', function () {
    var tests = [{
      name: 'empty',
      state: {
        byKey: {}
      },
      action: {},
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'non empty',
      state: {
        byKey: {
          k1: {
            data: {
              p: 1
            }
          },
          k2: {
            data: {
              p: 2
            }
          }
        }
      },
      action: {},
      expectedResult: {
        byKey: {
          k1: {
            data: {
              p: 1
            },
            outdated: true
          },
          k2: {
            data: {
              p: 2
            },
            outdated: true
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.dataSetOutdated(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('cleanupOnLogout', function () {
    var tests = [{
      name: 'test',
      state: {
        byKey: {
          k1: {
            data: {
              p: 1
            },
            permissions: {
              guest: {
                get: true
              }
            }
          },
          k2: {
            data: {
              p: 2
            }
          },
          k3: {
            data: {
              p: 3
            },
            permissions: {
              guest: {
                get: true
              }
            }
          }
        }
      },
      action: {},
      expectedResult: {
        byKey: {
          k1: {
            data: {
              p: 1
            },
            permissions: {
              guest: {
                get: true
              }
            }
          },
          k3: {
            data: {
              p: 3
            },
            permissions: {
              guest: {
                get: true
              }
            }
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(common.cleanupOnLogout(test.state, test.action), test.expectedResult);
      });
    });
  });
});

describe('state/_common/selectors', function () {
  var getSubState = function getSubState(state) {
    return state.sub;
  };

  describe('getActive', function () {
    var createState = function createState(activeKey) {
      return {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          },
          activeKey: activeKey
        }
      };
    };

    it('select active', function () {
      chai.assert.deepStrictEqual(commonSelectors.getActive(getSubState)(createState('k1')), {
        n: 1
      });
    });
    it('select inactive', function () {
      chai.assert.isNull(commonSelectors.getActive(getSubState)(createState('k3')));
    });
  });
  describe('getActiveModels', function () {
    var tests = [{
      name: 'none with null active keys',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          },
          activeKeys: null
        }
      },
      expectedResult: null
    }, {
      name: 'none with empty active keys',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          },
          activeKeys: []
        }
      },
      expectedResult: null
    }, {
      name: 'none with empty models',
      state: {
        sub: {
          byKey: {},
          activeKeys: ['k3']
        }
      },
      expectedResult: null
    }, {
      name: 'none',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          },
          activeKeys: ['k3']
        }
      },
      expectedResult: null
    }, {
      name: 'one',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          },
          activeKeys: ['k1', 'k3']
        }
      },
      expectedResult: [{
        n: 1
      }]
    }, {
      name: 'two',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          },
          activeKeys: ['k1', 'k2', 'k3']
        }
      },
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonSelectors.getActiveModels(getSubState)(test.state), test.expectedResult);
      });
    });
  });
  it('getActiveKey', function () {
    var state = {
      sub: {
        activeKey: 'k'
      }
    };
    chai.assert.strictEqual(commonSelectors.getActiveKey(getSubState)(state), 'k');
  });
  it('getActiveKeys', function () {
    var state = {
      sub: {
        activeKeys: ['k1', 'k2']
      }
    };
    chai.assert.deepStrictEqual(commonSelectors.getActiveKeys(getSubState)(state), ['k1', 'k2']);
  });
  describe('getAll', function () {
    var tests = [{
      name: 'null',
      state: {
        sub: {
          byKey: null
        }
      },
      expectedResult: []
    }, {
      name: 'empty',
      state: {
        sub: {
          byKey: {}
        }
      },
      expectedResult: []
    }, {
      name: 'some',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        }
      },
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonSelectors.getAll(getSubState)(test.state), test.expectedResult);
      });
    });
  });
  describe('getAllActiveKeys', function () {
    var tests = [{
      name: 'none specified',
      state: {},
      expectedResult: {
        activeAreaTreeLevelKey: null,
        activeAttributeKey: null,
        activeAttributeKeys: null,
        activeCaseKey: null,
        activeCaseKeys: null,
        activeLayerTemplateKey: null,
        activePeriodKey: null,
        activePeriodKeys: null,
        activePlaceKey: null,
        activePlaceKeys: null,
        activeScenarioKey: null,
        activeScenarioKeys: null,
        activeScopeKey: null
      }
    }, {
      name: 'all specified',
      state: {
        scopes: {
          activeKey: 'scopesKey'
        },
        cases: {
          activeKey: 'casesKey',
          activeKeys: ['c1', 'c2']
        },
        scenarios: {
          activeKey: 'scenariosKey'
        },
        places: {
          activeKey: 'placesKey',
          activeKeys: ['p1', 'p2']
        },
        periods: {
          activeKey: 'periodsKey',
          activeKeys: ['ps1', 'ps2']
        },
        attributes: {
          activeKey: 'attributesKey',
          activeKeys: ['a1', 'a2']
        },
        layerTemplates: {
          activeKey: 'layerTemplatesKey'
        },
        areaTreeLevelKeys: {
          activeKey: 'areaTreeLevelKey'
        },
        specific: {
          apps: {
            activeKey: 'appsKey'
          }
        },
        app: {
          key: 'appKey'
        }
      },
      expectedResult: {
        activeApplicationKey: 'appsKey',
        activeAreaTreeLevelKey: 'areaTreeLevelKey',
        activeAttributeKey: 'attributesKey',
        activeAttributeKeys: ['a1', 'a2'],
        activeCaseKey: 'casesKey',
        activeCaseKeys: ['c1', 'c2'],
        activeLayerTemplateKey: 'layerTemplatesKey',
        activePeriodKey: 'periodsKey',
        activePeriodKeys: ['ps1', 'ps2'],
        activePlaceKey: 'placesKey',
        activePlaceKeys: ['p1', 'p2'],
        activeScenarioKey: 'scenariosKey',
        activeScenarioKeys: null,
        activeScopeKey: 'scopesKey'
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonSelectors.getAllActiveKeys(test.state), test.expectedResult);
      });
    });
  });
  describe('getAllAsObject', function () {
    var tests = [{
      name: 'null',
      state: {
        sub: {
          byKey: {}
        }
      },
      expectedResult: {}
    }, {
      name: 'empty',
      state: {
        sub: {
          byKey: {}
        }
      },
      expectedResult: {}
    }, {
      name: 'some',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        }
      },
      expectedResult: {
        k1: {
          n: 1
        },
        k2: {
          n: 2
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonSelectors.getAllAsObject(getSubState)(test.state), test.expectedResult);
      });
    });
  });
  describe('getAllForActiveScope', function () {
    var tests = [{
      name: 'empty models',
      state: {
        sub: {},
        scopes: {
          activeKey: 'scopeK'
        }
      },
      expectedResult: null
    }, {
      name: 'empty indexes',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          },
          indexes: []
        },
        scopes: {
          activeKey: 'scopeK'
        }
      },
      expectedResult: null
    }, {
      name: 'no active skope key',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          },
          indexes: [{
            filter: 'fil',
            order: 'desc'
          }, {
            filter: {
              scopeKey: 'scopeK'
            },
            order: 'asc',
            count: 4,
            index: [null, 'k1', 'k2', 'k3']
          }]
        },
        scopes: {}
      },
      expectedResult: null
    }, {
      name: 'some',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          },
          indexes: [{
            filter: 'fil',
            order: 'desc'
          }, {
            filter: {
              scopeKey: 'scopeK'
            },
            order: 'asc',
            count: 4,
            index: [null, 'k1', 'k2', 'k3']
          }]
        },
        scopes: {
          activeKey: 'scopeK'
        }
      },
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }, {
        key: 'k3'
      }, null]
    }];
    var order = 'asc';
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonSelectors.getAllForActiveScope(getSubState)(test.state, order), test.expectedResult);
      });
    });
  });
  describe('getByFilterOrder', function () {
    var tests = [{
      name: 'empty models',
      state: {
        sub: {
          byKey: {},
          indexes: [{
            filter: 'fil',
            order: 'desc'
          }, {
            filter: {
              scopeKey: 'scopeK'
            },
            order: 'asc',
            count: 4,
            index: [null, 'k1', 'k2', 'k3']
          }]
        }
      },
      expectedResult: [{
        key: 'k1'
      }, {
        key: 'k2'
      }, {
        key: 'k3'
      }, null]
    }, {
      name: 'empty indexes',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          },
          indexes: []
        }
      },
      expectedResult: null
    }, {
      name: 'some',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          },
          indexes: [{
            filter: 'fil',
            order: 'desc'
          }, {
            filter: {
              scopeKey: 'scopeK'
            },
            order: 'asc',
            count: 4,
            index: [null, 'k1', 'k2', 'k3']
          }]
        }
      },
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }, {
        key: 'k3'
      }, null]
    }];
    var filter = {
      scopeKey: 'scopeK'
    };
    var order = 'asc';
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonSelectors.getByFilterOrder(getSubState)(test.state, filter, order), test.expectedResult);
      });
    });
  });
  describe('getBatchByFilterOrder', function () {
    var tests = [{
      name: 'empty models',
      state: {
        sub: {
          byKey: {},
          indexes: [{
            filter: 'fil',
            order: 'desc'
          }, {
            filter: {
              scopeKey: 'scopeK'
            },
            order: 'asc',
            count: 4,
            index: [null, 'k1', 'k2', 'k3']
          }]
        }
      },
      expectedResult: [null, null, null, null]
    }, {
      name: 'empty indexes',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          },
          indexes: []
        }
      },
      expectedResult: null
    }, {
      name: 'some',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          },
          indexes: [{
            filter: 'fil',
            order: 'desc'
          }, {
            filter: {
              scopeKey: 'scopeK'
            },
            order: 'asc',
            count: 4,
            index: [null, 'k1', 'k2', 'k3']
          }]
        }
      },
      expectedResult: [null, {
        n: 1
      }, {
        n: 2
      }, null]
    }];
    var filter = {
      scopeKey: 'scopeK'
    };
    var order = 'asc';
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonSelectors.getBatchByFilterOrder(getSubState)(test.state, filter, order), test.expectedResult);
      });
    });
  });
  describe('getByKey', function () {
    var tests = [{
      name: 'none',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: 'k3',
      expectedResult: null
    }, {
      name: 'null key',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: null,
      expectedResult: undefined
    }, {
      name: 'some',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: 'k1',
      expectedResult: {
        n: 1
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonSelectors.getByKey(getSubState)(test.state, test.key), test.expectedResult);
      });
    });
  });
  describe('getByKeysAsObject', function () {
    var tests = [{
      name: 'null keys',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: null,
      expectedResult: null
    }, {
      name: 'none',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: ['k5', 'k6'],
      expectedResult: null
    }, {
      name: 'some',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: ['k1', 'k2'],
      expectedResult: {
        k1: {
          n: 1
        },
        k2: {
          n: 2
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonSelectors.getByKeysAsObject(getSubState)(test.state, test.keys), test.expectedResult);
      });
    });
  });
  describe('getByKeys', function () {
    var tests = [{
      name: 'null keys',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: null,
      expectedResult: null
    }, {
      name: 'empty keys',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: [],
      expectedResult: null
    }, {
      name: 'none',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: ['k5', 'k6'],
      expectedResult: null
    }, {
      name: 'empty',
      state: {
        sub: {}
      },
      keys: ['k1', 'k2'],
      expectedResult: null
    }, {
      name: 'some',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: ['k1', 'k2'],
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonSelectors.getByKeys(getSubState)(test.state, test.keys), test.expectedResult);
      });
    });
  });
  describe('getDataByKey', function () {
    var tests = [{
      name: 'none',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1,
              data: 'data'
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: 'k5',
      expectedResult: null
    }, {
      name: 'some',
      state: {
        sub: {
          byKey: {
            k1: {
              n: 1,
              data: 'data'
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: 'k1',
      expectedResult: 'data'
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.strictEqual(commonSelectors.getDataByKey(getSubState)(test.state, test.key), test.expectedResult);
      });
    });
  });
  describe('getDeletePermissionByKey', function () {
    var tests = [{
      name: 'user with access',
      state: {
        sub: {
          byKey: {
            k1: {
              permissions: {
                activeUser: {
                  "delete": true
                }
              }
            }
          }
        }
      },
      expectedResult: true
    }, {
      name: 'guest with access',
      state: {
        sub: {
          byKey: {
            k1: {
              permissions: {
                guest: {
                  "delete": true
                }
              }
            }
          }
        }
      },
      expectedResult: true
    }, {
      name: 'no access',
      state: {
        sub: {}
      },
      expectedResult: false
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.strictEqual(commonSelectors.getDeletePermissionByKey(getSubState)(test.state, 'k1'), test.expectedResult);
      });
    });
  });
  describe('getUpdatePermissionByKey', function () {
    var tests = [{
      name: 'user with access',
      state: {
        sub: {
          byKey: {
            k1: {
              permissions: {
                activeUser: {
                  update: true
                }
              }
            }
          }
        }
      },
      expectedResult: true
    }, {
      name: 'guest with access',
      state: {
        sub: {
          byKey: {
            k1: {
              permissions: {
                guest: {
                  update: true
                }
              }
            }
          }
        }
      },
      expectedResult: true
    }, {
      name: 'no access',
      state: {
        sub: {}
      },
      expectedResult: false
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.strictEqual(commonSelectors.getUpdatePermissionByKey(getSubState)(test.state, 'k1'), test.expectedResult);
      });
    });
  });
  describe('getEditedActive', function () {
    var tests = [{
      name: 'none',
      state: {
        sub: {
          activeKey: 'k5',
          editedByKey: {
            k1: 'val1',
            k2: 'val2'
          }
        }
      },
      expectedResult: null
    }, {
      name: 'some',
      state: {
        sub: {
          activeKey: 'k1',
          editedByKey: {
            k1: 'val1',
            k2: 'val2'
          }
        }
      },
      expectedResult: 'val1'
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.strictEqual(commonSelectors.getEditedActive(getSubState)(test.state), test.expectedResult);
      });
    });
  });
  describe('getEditedAll', function () {
    var tests = [{
      name: 'null',
      state: {
        sub: {
          editedByKey: null
        }
      },
      expectedResult: null
    }, {
      name: 'empty',
      state: {
        sub: {
          editedByKey: {}
        }
      },
      expectedResult: []
    }, {
      name: 'some',
      state: {
        sub: {
          editedByKey: {
            k1: 'val1',
            k2: 'val2'
          }
        }
      },
      expectedResult: ['val1', 'val2']
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonSelectors.getEditedAll(getSubState)(test.state), test.expectedResult);
      });
    });
  });
  describe('getEditedAllAsObject', function () {
    var tests = [{
      name: 'null',
      state: {
        sub: {
          editedByKey: null
        }
      },
      expectedResult: null
    }, {
      name: 'some',
      state: {
        sub: {
          editedByKey: {
            prop: 'val'
          }
        }
      },
      expectedResult: {
        prop: 'val'
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonSelectors.getEditedAllAsObject(getSubState)(test.state), test.expectedResult);
      });
    });
  });
  describe('getEditedByKey', function () {
    var tests = [{
      name: 'null key',
      state: {
        sub: {
          editedByKey: {
            k1: 'val1',
            k2: 'val2'
          }
        }
      },
      key: null,
      expectedResult: null
    }, {
      name: 'none',
      state: {
        sub: {
          editedByKey: {
            k1: 'val1',
            k2: 'val2'
          }
        }
      },
      key: 'k5',
      expectedResult: null
    }, {
      name: 'some',
      state: {
        sub: {
          editedByKey: {
            k1: 'val1',
            k2: 'val2'
          }
        }
      },
      key: 'k2',
      expectedResult: 'val2'
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.strictEqual(commonSelectors.getEditedByKey(getSubState)(test.state, test.key), test.expectedResult);
      });
    });
  });
  describe('getEditedDataByKey', function () {
    var tests = [{
      name: 'none',
      state: {
        sub: {
          editedByKey: {
            k1: 'val1',
            k2: {
              data: 'datk2'
            }
          }
        }
      },
      key: 'k5',
      expectedResult: null
    }, {
      name: 'no data',
      state: {
        sub: {
          editedByKey: {
            k1: 'val1',
            k2: {
              data: 'datk2'
            }
          }
        }
      },
      key: 'k1',
      expectedResult: null
    }, {
      name: 'some',
      state: {
        sub: {
          editedByKey: {
            k1: 'val1',
            k2: {
              data: 'datk2'
            }
          }
        }
      },
      key: 'k2',
      expectedResult: 'datk2'
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.strictEqual(commonSelectors.getEditedDataByKey(getSubState)(test.state, test.key), test.expectedResult);
      });
    });
  });
  describe('getEditedKeys', function () {
    var tests = [{
      name: 'null',
      state: {
        sub: {
          editedByKey: null
        }
      },
      expectedResult: null
    }, {
      name: 'empty',
      state: {
        sub: {
          editedByKey: {}
        }
      },
      expectedResult: null
    }, {
      name: 'some',
      state: {
        sub: {
          editedByKey: {
            k1: {
              key: 'ke1'
            },
            k2: {
              key: 'ke2'
            }
          }
        }
      },
      expectedResult: ['ke1', 'ke2']
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonSelectors.getEditedKeys(getSubState)(test.state), test.expectedResult);
      });
    });
  });
  describe('getIndex', function () {
    var tests = [{
      name: 'none',
      state: {
        sub: {
          indexes: [{
            filter: 'fil2',
            order: 'desc'
          }, {
            filter: 'fil',
            order: 'desc'
          }, {
            filter: 'fil',
            order: 'asc'
          }, {
            filter: 'fil2',
            order: 'asc'
          }]
        }
      },
      filter: 'fil-not-present',
      order: 'asc',
      expectedResult: null
    }, {
      name: 'some',
      state: {
        sub: {
          indexes: [{
            filter: 'fil2',
            order: 'desc'
          }, {
            filter: 'fil',
            order: 'desc'
          }, {
            filter: 'fil',
            order: 'asc'
          }, {
            filter: 'fil2',
            order: 'asc'
          }]
        }
      },
      filter: 'fil',
      order: 'asc',
      expectedResult: {
        filter: 'fil',
        order: 'asc'
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonSelectors.getIndex(getSubState)(test.state, test.filter, test.order), test.expectedResult);
      });
    });
  });
  it('getIndexed', function () {
    var state = {
      sub: {
        scopes: {
          activeKey: 'scopesKey'
        },
        byKey: {
          k1: {
            n: 1
          },
          k2: {
            n: 2
          },
          k3: {
            n: 3,
            removed: true
          }
        },
        indexes: [{
          filterByActive: {
            scope: true
          },
          filter: {
            scopeKey: 'scopesKey'
          },
          order: 'asc',
          count: 7,
          index: ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh']
        }]
      }
    };
    var filterByActive = {
      scope: true
    };
    var filter = {
      scopeKey: 'scopesKey'
    };
    var order = 'asc';
    var start = 3;
    var length = 2;
    var expectedResult = [{
      key: 'fourth'
    }, {
      key: 'fifth'
    }];
    chai.assert.deepStrictEqual(commonSelectors.getIndexed(getSubState)(state, filterByActive, filter, order, start, length), expectedResult);
  });
  it('getIndexes', function () {
    chai.assert.strictEqual(commonSelectors.getIndexes(function (state) {
      return state.sub;
    })({
      sub: {
        indexes: 'indexes'
      }
    }), 'indexes');
  });
  describe('getIndexChangedOn', function () {
    var indexes = [{
      filter: 'fil2',
      order: 'desc'
    }, {
      filter: 'fil',
      order: 'desc',
      changedOn: '2020-01-01'
    }, {
      filter: 'fil',
      order: 'asc'
    }, {
      filter: 'fil2',
      order: 'asc'
    }];
    var filter = 'fil';
    var state = {
      sub: {
        indexes: indexes
      }
    };
    it('nil changedOn', function () {
      chai.assert.deepStrictEqual(commonSelectors.getIndexChangedOn(getSubState)(state, filter, 'asc'), null);
    });
    it('changedOn', function () {
      chai.assert.deepStrictEqual(commonSelectors.getIndexChangedOn(getSubState)(state, filter, 'desc'), '2020-01-01');
    });
  });
  it('getIndexPage', function () {
    var state = {
      sub: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: 7,
          index: ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh']
        }]
      }
    };
    var filter = 'fil';
    var order = 'asc';
    var start = 3;
    var length = 2;
    var expectedResult = {
      3: 'fourth',
      4: 'fifth'
    };
    chai.assert.deepStrictEqual(commonSelectors.getIndexPage(getSubState)(state, filter, order, start, length), expectedResult);
  }); // getIndexPage selector returns object on which getIndexedPage accesses `length` property?
  // it.skip('getIndexedPage', function () {});

  it('getIndexTotal', function () {
    var state = {
      sub: {
        indexes: [{
          filter: 'fil2',
          order: 'desc'
        }, {
          filter: 'fil',
          order: 'desc'
        }, {
          filter: 'fil',
          order: 'asc',
          count: 5
        }, {
          filter: 'fil2',
          order: 'asc'
        }]
      }
    };
    var filter = 'fil';
    var order = 'asc';
    chai.assert.strictEqual(commonSelectors.getIndexTotal(getSubState)(state, filter, order), 5);
  });
  it('getIndexesByFilteredItem', function () {
    var state = {
      sub: {
        indexes: [{
          filter: 'fil2',
          order: 'desc'
        }, {
          filter: {
            sameProp: 'that'
          },
          order: 'desc'
        }, {
          filter: {
            sameProp: 'notThis'
          },
          order: 'asc',
          count: 5
        }, {
          filter: {
            sameProp: 'that'
          },
          order: 'asc'
        }]
      }
    };
    var item = {
      data: {
        sameProp: 'that'
      }
    };
    var expectedResult = [{
      filter: {
        sameProp: 'that'
      },
      order: 'desc'
    }, {
      filter: {
        sameProp: 'that'
      },
      order: 'asc'
    }];
    chai.assert.deepStrictEqual(commonSelectors.getIndexesByFilteredItem(getSubState)(state, item), expectedResult);
  });
  describe('getKeysToLoad', function () {
    var tests = [{
      name: 'no keys',
      keys: [],
      state: {
        sub: {
          byKey: {
            k1: {
              p: '1'
            },
            k2: {
              p: '2'
            },
            k3: {
              p: '3',
              outdated: true
            }
          }
        }
      },
      expectedResult: null
    }, {
      name: 'null keys',
      keys: null,
      state: {
        sub: {
          byKey: {
            k1: {
              p: '1'
            },
            k2: {
              p: '2'
            },
            k3: {
              p: '3',
              outdated: true
            }
          }
        }
      },
      expectedResult: null
    }, {
      name: 'nothing loaded',
      keys: ['k1', 'k2'],
      state: {
        sub: {
          byKey: null
        }
      },
      expectedResult: ['k1', 'k2']
    }, {
      name: 'all loaded',
      keys: ['k1', 'k2'],
      state: {
        sub: {
          byKey: {
            k1: {
              p: '1'
            },
            k2: {
              p: '2'
            },
            k3: {
              p: '3',
              outdated: true
            }
          }
        }
      },
      expectedResult: null
    }, {
      name: 'outdated k3, missing k5',
      keys: ['k1', 'k3', 'k5'],
      state: {
        sub: {
          byKey: {
            k1: {
              p: '1'
            },
            k2: {
              p: '2'
            },
            k3: {
              p: '3',
              outdated: true
            }
          }
        }
      },
      expectedResult: ['k3', 'k5']
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(commonSelectors.getKeysToLoad(getSubState)(test.state, test.keys), test.expectedResult);
    });
  });
  describe('getStateToSave', function () {
    var tests = [{
      name: 'default state',
      getSubState: function getSubState(state) {
        return state.sub;
      },
      state: {
        sub: {}
      },
      expectedResult: {}
    }, {
      name: 'active key',
      getSubState: function getSubState(state) {
        return state.sub;
      },
      state: {
        sub: {
          activeKey: 'actv'
        }
      },
      expectedResult: {
        activeKey: 'actv'
      }
    }, {
      name: 'active keys',
      getSubState: function getSubState(state) {
        return state.sub;
      },
      state: {
        sub: {
          activeKeys: ['k1', 'k2']
        }
      },
      expectedResult: {
        activeKeys: ['k1', 'k2']
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonSelectors.getStateToSave(test.getSubState)(test.state), test.expectedResult);
      });
    });
  });
  it('getUsesForIndex', function () {
    var state = {
      scopes: {
        activeKey: 'scopesKey'
      },
      sub: {
        inUse: {
          indexes: [[{
            filterByActive: {
              scope: true
            },
            filter: {
              scopeKey: 'filter'
            },
            order: 'asc',
            start: 5,
            length: 3
          }]]
        }
      }
    };
    var filter = {
      scopeKey: 'scopesKey'
    };
    var order = 'asc';
    var expectedResult = {
      filter: {
        scopeKey: 'scopesKey'
      },
      order: 'asc',
      uses: [{
        start: 5,
        length: 3
      }]
    };
    chai.assert.deepStrictEqual(commonSelectors.getUsesForIndex(getSubState)(state, filter, order), expectedResult);
  });
  it('getUsedIndexPages', function () {
    var state = {
      scopes: {
        activeKey: 'scopesKey'
      },
      sub: {
        inUse: {
          indexes: [[{
            filterByActive: {
              scope: true
            },
            filter: {
              scopeKey: 'filter'
            },
            order: 'asc',
            start: 5,
            length: 3
          }]]
        }
      }
    };
    var expectedResult = [{
      filter: {
        scopeKey: 'scopesKey'
      },
      order: 'asc',
      uses: [{
        start: 5,
        length: 3
      }]
    }];
    chai.assert.deepStrictEqual(commonSelectors.getUsedIndexPages(getSubState)(state), expectedResult);
  });
  it('getUsedKeys', function () {
    var state = {
      sub: {
        inUse: {
          keys: ['k1', 'k2', 'k3', ['k1', 'k3', 'k4']]
        }
      }
    };
    var expectedResult = ['k1', 'k2', 'k3', 'k4'];
    chai.assert.deepStrictEqual(commonSelectors.getUsedKeys(getSubState)(state), expectedResult);
  });
  it('getUsesWithActiveDependency', function () {
    var state = {
      scopes: {
        activeKey: 'scopesKey'
      },
      sub: {
        inUse: {
          indexes: [[{
            filterByActive: {
              scopeKey: 'k'
            },
            filter: {
              scopeKey: 'filter'
            },
            order: 'asc',
            start: 5,
            length: 3
          }]]
        }
      }
    };
    var filter = {
      scopeKey: 'scopesKey'
    };
    var order = 'asc';
    var expectedResult = [{
      filter: {
        scopeKey: 'filter'
      },
      order: 'asc',
      uses: [{
        length: 3,
        start: 5
      }]
    }];
    chai.assert.deepStrictEqual(commonSelectors.getUsesWithActiveDependency(getSubState)(state, filter, order), expectedResult);
  });
  describe('_mergeIntervals', function () {
    var tests = [{
      name: 'empty',
      intervals: [],
      expectedResult: null
    }, {
      name: 'single',
      intervals: [{
        start: 5,
        length: 3
      }],
      expectedResult: [{
        start: 5,
        length: 3
      }]
    }, {
      name: 'non overlapping unsorted',
      intervals: [{
        start: 10,
        length: 2
      }, {
        start: 3,
        length: 4
      }, {
        start: 8,
        length: 1
      }],
      expectedResult: [{
        start: 3,
        length: 4
      }, {
        start: 8,
        length: 1
      }, {
        start: 10,
        length: 2
      }]
    }, {
      name: 'overlapping unsorted',
      intervals: [{
        start: 12,
        length: 1
      }, {
        start: 10,
        length: 2
      }, {
        start: 7,
        length: 3
      }],
      expectedResult: [{
        start: 7,
        length: 6
      }]
    }, {
      name: 'mixed',
      intervals: [{
        start: 12,
        length: 1
      }, {
        name: 'invalid interval'
      }, null, {
        start: 10,
        length: 2
      }, {
        start: 20,
        length: 5
      }],
      expectedResult: [{
        start: 10,
        length: 3
      }, {
        start: 20,
        length: 5
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(commonSelectors._mergeIntervals(test.intervals), test.expectedResult);
      });
    });
  });
});

describe('getActiveKeysByFilterByActive', function () {
  var state = {
    app: {
      key: "testing"
    },
    scopes: {
      activeKey: "scopeA"
    },
    places: {
      activeKey: null,
      activeKeys: ["placeA", "placeB"]
    },
    scenarios: {},
    layerTemplates: {
      activeKey: "ltA"
    }
  };
  it('should omit metadata which do not have active key or keys', function () {
    var filterByActive = {
      scope: true,
      place: true,
      scenario: true,
      layerTemplate: true
    };
    var expectedResult = {
      scopeKey: "scopeA",
      placeKeys: ["placeA", "placeB"],
      layerTemplateKey: "ltA"
    };
    var output = commonSelectors.getActiveKeysByFilterByActive(state, filterByActive);
    chai.assert.deepStrictEqual(output, expectedResult);
  });
  it('should omit missing metadata', function () {
    var filterByActive = {
      scope: true,
      areaTreeLevelKey: true
    };
    var expectedResult = {
      scopeKey: "scopeA"
    };
    var output = commonSelectors.getActiveKeysByFilterByActive(state, filterByActive);
    chai.assert.deepStrictEqual(output, expectedResult);
  });
  it('should return null if no metadata match', function () {
    var filterByActive = {
      areaTreeLevelKey: true
    };
    var output = commonSelectors.getActiveKeysByFilterByActive(state, filterByActive);
    chai.assert.isNull(output);
  });
  it('should return null if filter by active is null', function () {
    var filterByActive = null;
    var output = commonSelectors.getActiveKeysByFilterByActive(state, filterByActive);
    chai.assert.isNull(output);
  });
});

describe('state/App/actions', function () {
  var dispatchedActions = [];
  this.afterEach(function () {
    resetFetch();
    dispatchedActions = [];
  });
  it('add', function () {
    chai.assert.deepStrictEqual(actions$8.add({
      p: 'v'
    }), {
      type: 'APP.RECEIVE_CONFIGURATION',
      configuration: {
        p: 'v'
      }
    });
  });
  it('setKey', function () {
    chai.assert.deepStrictEqual(actions$8.setKey('k1'), {
      type: 'APP.SET_KEY',
      key: 'k1'
    });
  });
  it('updateLocalConfiguration', function () {
    chai.assert.deepStrictEqual(actions$8.updateLocalConfiguration('update'), {
      type: 'APP.UPDATE_LOCAL_CONFIGURATION',
      update: 'update'
    });
  });
  it('updateLocalConfiguration', function () {
    chai.assert.deepStrictEqual(actions$8.updateLocalConfiguration('update'), {
      type: 'APP.UPDATE_LOCAL_CONFIGURATION',
      update: 'update'
    });
  });
  it('setBaseUrl', function () {
    chai.assert.deepStrictEqual(actions$8.setBaseUrl('http://localhost'), {
      type: 'APP.SET_BASE_URL',
      url: 'http://localhost'
    });
  });
  it('setLocalConfiguration', function () {
    chai.assert.deepStrictEqual(actions$8.setLocalConfiguration('pth', 'val'), {
      type: 'APP.SET_LOCAL_CONFIGURATION',
      path: 'pth',
      value: 'val'
    });
  });
  it('loadConfiguration', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/applications/filtered/configurations', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {}
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          configurations: [{
            key: 'k1',
            data: {
              data: {
                p1: 'v1'
              }
            }
          }]
        },
        total: 1,
        changes: {
          configurations: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$8.loadConfiguration()(dispatch, getState).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'APP.RECEIVE_CONFIGURATION',
        configuration: {
          p1: 'v1'
        }
      }]);
    });
  });
});

var INITIAL_STATE = {
  key: null
};
/**
 * @param state
 * @param action
 * @param action.key {string}
 * @return {Object}
 */

var setKey = function setKey(state, action) {
  return _objectSpread2(_objectSpread2({}, state), {}, {
    key: action.key
  });
};

var setBaseUrl = function setBaseUrl(state, action) {
  return _objectSpread2(_objectSpread2({}, state), {}, {
    baseUrl: action.url
  });
};

var setLocalConfiguration = function setLocalConfiguration(state, action) {
  var path = action.path.split('.');
  return _objectSpread2(_objectSpread2({}, state), {}, {
    localConfiguration: setHelper(state.localConfiguration, path, action.value)
  });
};

var updateLocalConfiguration = function updateLocalConfiguration(state, action) {
  return _objectSpread2(_objectSpread2({}, state), {}, {
    localConfiguration: state.localConfiguration ? _objectSpread2(_objectSpread2({}, state.localConfiguration), action.update) : action.update
  });
};

function setHelper(state, path, value) {
  var remainingPath = _toConsumableArray(path);

  var currentKey = remainingPath.shift();

  if (remainingPath.length) {
    return _objectSpread2(_objectSpread2({}, state), {}, _defineProperty({}, currentKey, setHelper(state[currentKey], remainingPath, value)));
  } else {
    return _objectSpread2(_objectSpread2({}, state), {}, _defineProperty({}, currentKey, value));
  }
}

var receiveConfiguration = function receiveConfiguration(state, action) {
  return _objectSpread2(_objectSpread2({}, state), {}, {
    configuration: action.configuration
  });
};

var reducer = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case ActionTypes.APP.SET_BASE_URL:
      return setBaseUrl(state, action);

    case ActionTypes.APP.SET_KEY:
      return setKey(state, action);

    case ActionTypes.APP.SET_LOCAL_CONFIGURATION:
      return setLocalConfiguration(state, action);

    case ActionTypes.APP.UPDATE_LOCAL_CONFIGURATION:
      return updateLocalConfiguration(state, action);

    case ActionTypes.APP.RECEIVE_CONFIGURATION:
      return receiveConfiguration(state, action);

    default:
      return state;
  }
});

describe('state/App/reducers', function () {
  it('SET_BASE_URL', function () {
    chai.assert.deepStrictEqual(reducer(null, {
      type: 'APP.SET_BASE_URL',
      url: 'http://localhost'
    }), {
      baseUrl: 'http://localhost'
    });
  });
  it('SET_KEY', function () {
    chai.assert.deepStrictEqual(reducer(null, {
      type: 'APP.SET_KEY',
      key: 'k1'
    }), {
      key: 'k1'
    });
  });
  it('SET_LOCAL_CONFIGURATION', function () {
    chai.assert.deepStrictEqual(reducer({}, {
      type: 'APP.SET_LOCAL_CONFIGURATION',
      path: 'pth',
      value: 'val'
    }), {
      localConfiguration: {
        pth: 'val'
      }
    });
  });
  it('UPDATE_LOCAL_CONFIGURATION', function () {
    chai.assert.deepStrictEqual(reducer({}, {
      type: 'APP.UPDATE_LOCAL_CONFIGURATION',
      update: {
        p: 'v'
      }
    }), {
      localConfiguration: {
        p: 'v'
      }
    });
  });
  it('RECEIVE_CONFIGURATION', function () {
    chai.assert.deepStrictEqual(reducer({}, {
      type: 'APP.RECEIVE_CONFIGURATION',
      configuration: {
        p: 'v'
      }
    }), {
      configuration: {
        p: 'v'
      }
    });
  });
  it('unknown', function () {
    chai.assert.deepStrictEqual(reducer({}, {
      type: 'UNKNOWN_ACTION'
    }), {});
  });
});

describe('state/App/selectors', function () {
  it('getKey', function () {
    chai.assert.strictEqual('kk', selectors$3.getKey({
      app: {
        key: 'kk'
      }
    }));
  });
  it('getConfiguration', function () {
    chai.assert.strictEqual(selectors$3.getConfiguration({
      app: {
        configuration: {
          p: 'v'
        }
      }
    }, 'p'), 'v');
  });
  it('getCompleteConfiguration', function () {
    chai.assert.deepStrictEqual(selectors$3.getCompleteConfiguration({
      app: {
        configuration: {
          p: 'v'
        }
      }
    }), {
      p: 'v'
    });
  });
  it('getLocalConfiguration', function () {
    chai.assert.strictEqual(selectors$3.getLocalConfiguration({
      app: {
        localConfiguration: {
          p: 'v'
        }
      }
    }, 'p'), 'v');
  });
  it('getCompleteLocalConfiguration', function () {
    chai.assert.deepStrictEqual(selectors$3.getCompleteLocalConfiguration({
      app: {
        localConfiguration: {
          p: 'v'
        }
      }
    }), {
      p: 'v'
    });
  });
});

describe('state/Areas/AreaTreeLevels/actions', function () {
  var dispatchedActions = [];

  var dispatch = function dispatch(action) {
    dispatchedActions.push(action);
  };

  this.afterEach(function () {
    resetFetch();
    dispatchedActions = [];
  });

  var runFunctionActions = function runFunctionActions(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return new Promise(function (resolve, reject) {
      var promises = [];

      for (var i = 0; i < dispatchedActions.length; i++) {
        var action = dispatchedActions[i];

        if (typeof action === 'function') {
          promises.push(action(dispatch, getState));
          dispatchedActions[i] = null;
        } else if (action instanceof Promise) {
          promises.push(action);
          dispatchedActions[i] = null;
        }
      }

      dispatchedActions = dispatchedActions.filter(function (a) {
        return a !== null;
      });

      if (promises.length > 0) {
        return Promise.all(promises).then(function () {
          return runFunctionActions({
            dispatch: dispatch,
            getState: getState
          });
        }).then(function () {
          return resolve();
        });
      }

      resolve();
    });
  };

  it('ensureIndexesWithFilterByActive', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        areas: {
          areaTrees: {
            inUse: {
              indexes: [[{
                filterByActive: {
                  name: 'fil'
                },
                filter: {
                  name: 'fil'
                },
                order: 'asc',
                start: 1,
                length: 5
              }]]
            }
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata/filtered/areaTreeLevels', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          areaTreeLevels: {
            k1: {},
            k2: {},
            k3: {},
            k4: {}
          }
        },
        total: 5,
        changes: {
          areaTreeLevels: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$1.ensureIndexesWithFilterByActive({
      name: 'fil'
    })(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'AREAS.AREA_TREE_LEVELS.INDEX.ADD',
        filter: {
          name: 'fil'
        },
        order: 'asc',
        start: 1,
        data: {
          k1: {},
          k2: {},
          k3: {},
          k4: {}
        },
        changedOn: '2020-01-01',
        count: 5
      }]);
    });
  });
  it('refreshUses', function () {

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        areas: {
          areaTreeLevels: {
            inUse: {
              keys: ['k1', 'k2'],
              indexes: [[{
                filter: {
                  name: 'fil'
                },
                order: 'asc',
                start: 1,
                length: 3
              }]]
            },
            byKey: {
              k1: {
                key: 'k1'
              },
              k2: {
                key: 'k2'
              }
            }
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata/filtered/areaTreeLevels', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          areaTreeLevels: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          areaTreeLevels: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$1.refreshUses()(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'AREAS.AREA_TREE_LEVELS.INDEX.CLEAR_ALL'
      }, {
        filter: {
          name: 'fil'
        },
        order: 'asc',
        count: 2,
        start: 1,
        data: {
          k1: {},
          k2: {}
        },
        changedOn: '2020-01-01',
        type: 'AREAS.AREA_TREE_LEVELS.INDEX.ADD'
      }]);
    });
  });
  it('setActiveKey', function () {
    actions$1.setActiveKey('k1')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'AREAS.AREA_TREE_LEVELS.SET_ACTIVE_KEY',
      key: 'k1'
    }]);
  });
  it('useIndexed', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributes: {
          activeKey: 'k1'
        },
        scopes: {
          activeKey: 'k1'
        },
        periods: {
          activeKey: 'k1'
        },
        places: {
          activeKey: 'k1'
        },
        areas: {
          areaTreeLevels: {}
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata/filtered/areaTreeLevels', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          areaTreeLevels: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          areaTreeLevels: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$1.useIndexed({
      name: 'afil'
    }, {
      name: 'fil'
    }, 'asc', 1, 5, 'cid')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        componentId: 'cid',
        filterByActive: {
          name: 'afil'
        },
        filter: {
          name: 'fil'
        },
        order: 'asc',
        start: 1,
        length: 5,
        type: 'AREAS.AREA_TREE_LEVELS.USE.INDEXED.REGISTER'
      }, {
        filter: {
          name: 'fil'
        },
        order: 'asc',
        count: 2,
        start: 1,
        data: {
          k1: {},
          k2: {}
        },
        changedOn: '2020-01-01',
        type: 'AREAS.AREA_TREE_LEVELS.INDEX.ADD'
      }]);
    });
  });
  it('useIndexedClear', function () {
    chai.assert.deepStrictEqual(actions$1.useIndexedClear('cid'), {
      type: 'AREAS.AREA_TREE_LEVELS.USE.INDEXED.CLEAR',
      componentId: 'cid'
    });
  });
  it('useKeys', function () {

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        areas: {
          areaTreeLevels: {
            byKey: {
              k1: {
                key: 'k1'
              },
              k2: {
                key: 'k2'
              }
            }
          }
        }
      };
    };

    return actions$1.useKeys(['k1', 'k2'], 'cid')(dispatch).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        componentId: 'cid',
        keys: ['k1', 'k2'],
        type: 'AREAS.AREA_TREE_LEVELS.USE.KEYS.REGISTER'
      }]);
    });
  });
});

var INITIAL_STATE$1 = _objectSpread2({}, DEFAULT_INITIAL_STATE);

var reducer$1 = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE$1;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case ActionTypes.AREAS.AREA_TREE_LEVELS.ADD:
      return common.add(state, action);

    case ActionTypes.AREAS.AREA_TREE_LEVELS.ADD_UNRECEIVED:
      return common.addUnreceivedKeys(state, action);

    case ActionTypes.AREAS.AREA_TREE_LEVELS.INDEX.ADD:
      return common.addIndex(state, action);

    case ActionTypes.AREAS.AREA_TREE_LEVELS.SET_ACTIVE_KEY:
      return common.setActive(state, action);

    case ActionTypes.AREAS.AREA_TREE_LEVELS.USE.INDEXED.REGISTER:
      return common.registerUseIndexed(state, action);

    case ActionTypes.AREAS.AREA_TREE_LEVELS.USE.INDEXED.CLEAR:
      return common.useIndexedClear(state, action);

    case ActionTypes.AREAS.AREA_TREE_LEVELS.USE.KEYS.REGISTER:
      return common.useKeysRegister(state, action);

    case ActionTypes.AREAS.AREA_TREE_LEVELS.USE.KEYS.CLEAR:
      return common.useKeysClear(state, action);

    case ActionTypes.AREAS.AREA_TREE_LEVELS.INDEX.CLEAR_ALL:
      return common.clearIndexes(state, action);

    case ActionTypes.COMMON.DATA.SET_OUTDATED:
      return common.dataSetOutdated(state, action);

    case ActionTypes.COMMON.DATA.CLEANUP_ON_LOGOUT:
      return common.cleanupOnLogout(state, action);

    default:
      return state;
  }
});

describe('state/Areas/AreaTreeLevels/reducers', function () {
  describe('add', function () {
    var tests = [{
      name: 'no data',
      state: {
        byKey: null
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.ADD'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty data',
      state: {
        byKey: null
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.ADD',
        data: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some data',
      state: {
        byKey: null
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.ADD',
        data: [{
          key: 'k1',
          name: 'first'
        }, {
          key: 'k2',
          name: 'second',
          outdated: true,
          unreceived: true
        }]
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            name: 'first'
          },
          k2: {
            key: 'k2',
            name: 'second'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$1(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addUnreceivedKeys', function () {
    var tests = [{
      name: 'no keys',
      state: {
        byKey: null
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.ADD_UNRECEIVED'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty keys',
      state: {
        byKey: null
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.ADD_UNRECEIVED',
        keys: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some keys',
      state: {
        byKey: null
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.ADD_UNRECEIVED',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            unreceived: true
          },
          k2: {
            key: 'k2',
            unreceived: true
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$1(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addIndex', function () {
    var tests = [{
      name: 'empty data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: 'idx'
        }]
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.INDEX.ADD',
        filter: 'fil',
        order: 'asc',
        changedOn: 'some time',
        count: 2,
        data: []
      },
      expectedResult: {
        indexes: [{
          changedOn: 'some time',
          count: 2,
          filter: 'fil',
          index: 'idx',
          order: 'asc'
        }]
      }
    }, {
      name: 'new data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: [{
            key: 'k'
          }, {
            key: 'k.1'
          }, {
            key: 'k.2'
          }]
        }]
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.INDEX.ADD',
        filter: 'fil',
        order: 'asc',
        changedOn: 'some time',
        count: 2,
        start: 1,
        data: [{
          key: 'k2'
        }, {
          key: 'k3'
        }]
      },
      expectedResult: {
        indexes: [{
          changedOn: 'some time',
          count: 2,
          filter: 'fil',
          index: {
            0: {
              key: 'k'
            },
            1: 'k2',
            2: 'k3'
          },
          order: 'asc'
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$1(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('setActive', function () {
    var tests = [{
      name: 'test',
      state: {
        activeKey: 'k1',
        activeKeys: ['ks1', 'ks2']
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.SET_ACTIVE_KEY',
        key: 'ak'
      },
      expectedResult: {
        activeKey: 'ak',
        activeKeys: null
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$1(test.state, test.action), test.expectedResult);
    });
  });
  describe('registerUseIndexed', function () {
    var tests = [{
      name: 'existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.USE.INDEXED.REGISTER',
        componentId: 'compId',
        filterByActive: 'fba',
        filter: 'f',
        order: 'asc',
        start: 4,
        length: 2
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      }
    }, {
      name: 'non existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.USE.INDEXED.REGISTER',
        componentId: 'compId',
        filterByActive: '_fba',
        filter: 'f',
        order: 'asc',
        start: 4,
        length: 2
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }, {
              filterByActive: '_fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$1(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('useIndexedClear', function () {
    var tests = [{
      name: 'no index',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.USE.INDEXED.CLEAR',
        componentId: 'some2'
      },
      expectedResult: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      }
    }, {
      name: 'matched index',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.USE.INDEXED.CLEAR',
        componentId: 'some3'
      },
      expectedResult: {
        inUse: {
          indexes: {
            some: 'some'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$1(test.state, test.action), test.expectedResult);
    });
  });
  describe('useKeysRegister', function () {
    var tests = [{
      name: 'no initial keys',
      state: {
        inUse: {}
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.USE.KEYS.REGISTER',
        componentId: 'comp',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k2']
          }
        }
      }
    }, {
      name: 'with initial keys',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3']
          }
        }
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.USE.KEYS.REGISTER',
        componentId: 'comp',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$1(test.state, test.action), test.expectedResult);
    });
  });
  describe('useKeysClear', function () {
    var tests = [{
      name: 'non existing',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.USE.KEYS.CLEAR',
        componentId: 'comp2'
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      }
    }, {
      name: 'single',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2'],
            comp2: ['kc']
          }
        }
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.USE.KEYS.CLEAR',
        componentId: 'comp'
      },
      expectedResult: {
        inUse: {
          keys: {
            comp2: ['kc']
          }
        }
      }
    }, {
      name: 'last',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.USE.KEYS.CLEAR',
        componentId: 'comp'
      },
      expectedResult: {
        inUse: {
          keys: null
        }
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$1(test.state, test.action), test.expectedResult);
    });
  });
  describe('clearIndexes', function () {
    var tests = [{
      name: 'empty',
      state: {
        indexes: []
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.INDEX.CLEAR_ALL'
      },
      expectedResult: {
        indexes: null
      }
    }, {
      name: 'non empty',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: 5,
          index: ['v1', 'v2'],
          changedOn: 'changed on'
        }]
      },
      action: {
        type: 'AREAS.AREA_TREE_LEVELS.INDEX.CLEAR_ALL'
      },
      expectedResult: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: null,
          index: null,
          changedOn: null,
          outdated: ['v1', 'v2'],
          outdatedCount: 5
        }]
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$1(test.state, test.action), test.expectedResult);
    });
  });
  describe('dataSetOutdated', function () {
    var tests = [{
      name: 'empty',
      state: {
        byKey: {}
      },
      action: {
        type: 'COMMON.DATA.SET_OUTDATED'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'non empty',
      state: {
        byKey: {
          k1: {
            data: {
              p: 1
            }
          },
          k2: {
            data: {
              p: 2
            }
          }
        }
      },
      action: {
        type: 'COMMON.DATA.SET_OUTDATED'
      },
      expectedResult: {
        byKey: {
          k1: {
            data: {
              p: 1
            },
            outdated: true
          },
          k2: {
            data: {
              p: 2
            },
            outdated: true
          }
        }
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$1(test.state, test.action), test.expectedResult);
    });
  });
  describe('cleanupOnLogout', function () {
    var tests = [{
      name: 'test',
      state: {
        byKey: {
          k1: {
            data: {
              p: 1
            },
            permissions: {
              guest: {
                get: true
              }
            }
          },
          k2: {
            data: {
              p: 2
            }
          },
          k3: {
            data: {
              p: 3
            },
            permissions: {
              guest: {
                get: true
              }
            }
          }
        }
      },
      action: {
        type: 'COMMON.DATA.CLEANUP_ON_LOGOUT'
      },
      expectedResult: {
        byKey: {
          k1: {
            data: {
              p: 1
            },
            permissions: {
              guest: {
                get: true
              }
            }
          },
          k3: {
            data: {
              p: 3
            },
            permissions: {
              guest: {
                get: true
              }
            }
          }
        }
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$1(test.state, test.action), test.expectedResult);
    });
  });
  it('unknown', function () {
    chai.assert.deepStrictEqual(reducer$1({}, {
      type: 'UNKNOWN_ACTION'
    }), {});
  });
});

describe('state/Areas/AreaTreeLevels/selectors', function () {
  describe('getAll', function () {
    var tests = [{
      name: 'null',
      state: {
        areas: {
          areaTreeLevels: {
            byKey: null
          }
        }
      },
      expectedResult: []
    }, {
      name: 'empty',
      state: {
        areas: {
          areaTreeLevels: {
            byKey: {}
          }
        }
      },
      expectedResult: []
    }, {
      name: 'some',
      state: {
        areas: {
          areaTreeLevels: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              },
              k3: {
                n: 3,
                removed: true
              }
            }
          }
        }
      },
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$4.getAll(test.state), test.expectedResult);
      });
    });
  });
  describe('getAllAsObject', function () {
    var tests = [{
      name: 'null',
      state: {
        areas: {
          areaTreeLevels: {
            byKey: {}
          }
        }
      },
      expectedResult: {}
    }, {
      name: 'empty',
      state: {
        areas: {
          areaTreeLevels: {
            byKey: {}
          }
        }
      },
      expectedResult: {}
    }, {
      name: 'some',
      state: {
        areas: {
          areaTreeLevels: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              },
              k3: {
                n: 3,
                removed: true
              }
            }
          }
        }
      },
      expectedResult: {
        k1: {
          n: 1
        },
        k2: {
          n: 2
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$4.getAllAsObject(test.state), test.expectedResult);
      });
    });
  });
  describe('getAllForActiveScope', function () {
    var tests = [{
      name: 'empty models',
      state: {
        areas: {
          areaTreeLevels: {}
        },
        scopes: {
          activeKey: 'scopeK'
        }
      },
      expectedResult: null
    }, {
      name: 'empty indexes',
      state: {
        areas: {
          areaTreeLevels: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              }
            },
            indexes: []
          }
        },
        scopes: {
          activeKey: 'scopeK'
        }
      },
      expectedResult: null
    }, {
      name: 'no active skope key',
      state: {
        areas: {
          areaTreeLevels: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              }
            },
            indexes: [{
              filter: 'fil',
              order: 'desc'
            }, {
              filter: {
                scopeKey: 'scopeK'
              },
              order: 'asc',
              count: 4,
              index: [null, 'k1', 'k2', 'k3']
            }]
          }
        },
        scopes: {}
      },
      expectedResult: null
    }, {
      name: 'some',
      state: {
        areas: {
          areaTreeLevels: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              }
            },
            indexes: [{
              filter: 'fil',
              order: 'desc'
            }, {
              filter: {
                scopeKey: 'scopeK'
              },
              order: 'asc',
              count: 4,
              index: [null, 'k1', 'k2', 'k3']
            }]
          }
        },
        scopes: {
          activeKey: 'scopeK'
        }
      },
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }, {
        key: 'k3'
      }, null]
    }];
    var order = 'asc';
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$4.getAllForActiveScope(test.state, order), test.expectedResult);
      });
    });
  });
  it('getActiveKey', function () {
    var state = {
      areas: {
        areaTreeLevels: {
          activeKey: 'k'
        }
      }
    };
    chai.assert.strictEqual(selectors$4.getActiveKey(state), 'k');
  });
  describe('getActive', function () {
    var createState = function createState(activeKey) {
      return {
        areas: {
          areaTreeLevels: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              },
              k3: {
                n: 3,
                removed: true
              }
            },
            activeKey: activeKey
          }
        }
      };
    };

    it('select active', function () {
      chai.assert.deepStrictEqual(selectors$4.getActive(createState('k1')), {
        n: 1
      });
    });
    it('select inactive', function () {
      chai.assert.isNull(selectors$4.getActive(createState('k3')));
    });
  });
  it('getSubstate', function () {
    chai.assert.strictEqual(selectors$4.getSubstate({
      areas: {
        areaTreeLevels: 'subst'
      }
    }), 'subst');
  });
});

describe('state/Areas/AreaTrees/actions', function () {
  var dispatchedActions = [];

  var dispatch = function dispatch(action) {
    dispatchedActions.push(action);
  };

  this.afterEach(function () {
    resetFetch();
    dispatchedActions = [];
  });

  var runFunctionActions = function runFunctionActions(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return new Promise(function (resolve, reject) {
      var promises = [];

      for (var i = 0; i < dispatchedActions.length; i++) {
        var action = dispatchedActions[i];

        if (typeof action === 'function') {
          promises.push(action(dispatch, getState));
          dispatchedActions[i] = null;
        } else if (action instanceof Promise) {
          promises.push(action);
          dispatchedActions[i] = null;
        }
      }

      dispatchedActions = dispatchedActions.filter(function (a) {
        return a !== null;
      });

      if (promises.length > 0) {
        return Promise.all(promises).then(function () {
          return runFunctionActions({
            dispatch: dispatch,
            getState: getState
          });
        }).then(function () {
          return resolve();
        });
      }

      resolve();
    });
  };

  it('ensureIndexesWithFilterByActive', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        areas: {
          areaTrees: {
            inUse: {
              indexes: [[{
                filterByActive: {
                  name: 'fil'
                },
                filter: {
                  name: 'fil'
                },
                order: 'asc',
                start: 1,
                length: 5
              }]]
            }
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata/filtered/areaTrees', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          areaTrees: {
            k1: {},
            k2: {},
            k3: {},
            k4: {}
          }
        },
        total: 5,
        changes: {
          areaTrees: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$2.ensureIndexesWithFilterByActive({
      name: 'fil'
    })(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'AREAS.AREA_TREES.INDEX.ADD',
        filter: {
          name: 'fil'
        },
        order: 'asc',
        start: 1,
        data: {
          k1: {},
          k2: {},
          k3: {},
          k4: {}
        },
        changedOn: '2020-01-01',
        count: 5
      }]);
    });
  });
  it('refreshUses', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        areas: {
          areaTrees: {
            inUse: {
              keys: ['k1', 'k2'],
              indexes: [[{
                filter: {
                  name: 'fil'
                },
                order: 'asc',
                start: 1,
                length: 3
              }]]
            },
            byKey: {
              k1: {
                key: 'k1'
              },
              k2: {
                key: 'k2'
              }
            }
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata/filtered/areaTrees', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          areaTrees: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          areaTrees: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$2.refreshUses()(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'AREAS.AREA_TREES.INDEX.CLEAR_ALL'
      }, {
        filter: {
          name: 'fil'
        },
        order: 'asc',
        count: 2,
        start: 1,
        data: {
          k1: {},
          k2: {}
        },
        changedOn: '2020-01-01',
        type: 'AREAS.AREA_TREES.INDEX.ADD'
      }]);
    });
  });
  it('setActiveKey', function () {
    actions$2.setActiveKey('k1')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'AREAS.AREA_TREES.SET_ACTIVE_KEY',
      key: 'k1'
    }]);
  });
  it('useIndexed', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributes: {
          activeKey: 'k1'
        },
        scopes: {
          activeKey: 'k1'
        },
        periods: {
          activeKey: 'k1'
        },
        places: {
          activeKey: 'k1'
        },
        areas: {
          areaTrees: {}
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata/filtered/areaTrees', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          areaTrees: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          areaTrees: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$2.useIndexed({
      name: 'afil'
    }, {
      name: 'fil'
    }, 'asc', 1, 5, 'cid')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        componentId: 'cid',
        filterByActive: {
          name: 'afil'
        },
        filter: {
          name: 'fil'
        },
        order: 'asc',
        start: 1,
        length: 5,
        type: 'AREAS.AREA_TREES.USE.INDEXED.REGISTER'
      }, {
        filter: {
          name: 'fil'
        },
        order: 'asc',
        count: 2,
        start: 1,
        data: {
          k1: {},
          k2: {}
        },
        changedOn: '2020-01-01',
        type: 'AREAS.AREA_TREES.INDEX.ADD'
      }]);
    });
  });
  it('useIndexedClear', function () {
    chai.assert.deepStrictEqual(actions$2.useIndexedClear('cid'), {
      type: 'AREAS.AREA_TREES.USE.INDEXED.CLEAR',
      componentId: 'cid'
    });
  });
  it('useKeys', function () {

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        areas: {
          areaTrees: {
            byKey: {
              k1: {
                key: 'k1'
              },
              k2: {
                key: 'k2'
              }
            }
          }
        }
      };
    };

    return actions$2.useKeys(['k1', 'k2'], 'cid')(dispatch).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        componentId: 'cid',
        keys: ['k1', 'k2'],
        type: 'AREAS.AREA_TREES.USE.KEYS.REGISTER'
      }]);
    });
  });
  it('useKeysClear', function () {
    actions$2.useKeysClear('cid')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'AREAS.AREA_TREES.USE.KEYS.CLEAR',
      componentId: 'cid'
    }]);
  });
});

var INITIAL_STATE$2 = _objectSpread2({}, DEFAULT_INITIAL_STATE);

var reducer$2 = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE$2;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case ActionTypes.AREAS.AREA_TREES.ADD:
      return common.add(state, action);

    case ActionTypes.AREAS.AREA_TREES.ADD_UNRECEIVED:
      return common.addUnreceivedKeys(state, action);

    case ActionTypes.AREAS.AREA_TREES.INDEX.ADD:
      return common.addIndex(state, action);

    case ActionTypes.AREAS.AREA_TREES.SET_ACTIVE_KEY:
      return common.setActive(state, action);

    case ActionTypes.AREAS.AREA_TREES.USE.INDEXED.REGISTER:
      return common.registerUseIndexed(state, action);

    case ActionTypes.AREAS.AREA_TREES.USE.INDEXED.CLEAR:
      return common.useIndexedClear(state, action);

    case ActionTypes.AREAS.AREA_TREES.USE.KEYS.REGISTER:
      return common.useKeysRegister(state, action);

    case ActionTypes.AREAS.AREA_TREES.USE.KEYS.CLEAR:
      return common.useKeysClear(state, action);

    case ActionTypes.AREAS.AREA_TREES.INDEX.CLEAR_ALL:
      return common.clearIndexes(state, action);

    case ActionTypes.COMMON.DATA.SET_OUTDATED:
      return common.dataSetOutdated(state, action);

    case ActionTypes.COMMON.DATA.CLEANUP_ON_LOGOUT:
      return common.cleanupOnLogout(state, action);

    default:
      return state;
  }
});

describe('state/Areas/AreaTrees/reducers', function () {
  describe('add', function () {
    var tests = [{
      name: 'no data',
      state: {
        byKey: null
      },
      action: {
        type: 'AREAS.AREA_TREES.ADD'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty data',
      state: {
        byKey: null
      },
      action: {
        type: 'AREAS.AREA_TREES.ADD',
        data: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some data',
      state: {
        byKey: null
      },
      action: {
        type: 'AREAS.AREA_TREES.ADD',
        data: [{
          key: 'k1',
          name: 'first'
        }, {
          key: 'k2',
          name: 'second',
          outdated: true,
          unreceived: true
        }]
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            name: 'first'
          },
          k2: {
            key: 'k2',
            name: 'second'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$2(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addUnreceivedKeys', function () {
    var tests = [{
      name: 'no keys',
      state: {
        byKey: null
      },
      action: {
        type: 'AREAS.AREA_TREES.ADD_UNRECEIVED'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty keys',
      state: {
        byKey: null
      },
      action: {
        type: 'AREAS.AREA_TREES.ADD_UNRECEIVED',
        keys: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some keys',
      state: {
        byKey: null
      },
      action: {
        type: 'AREAS.AREA_TREES.ADD_UNRECEIVED',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            unreceived: true
          },
          k2: {
            key: 'k2',
            unreceived: true
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$2(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addIndex', function () {
    var tests = [{
      name: 'empty data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: 'idx'
        }]
      },
      action: {
        type: 'AREAS.AREA_TREES.INDEX.ADD',
        filter: 'fil',
        order: 'asc',
        changedOn: 'some time',
        count: 2,
        data: []
      },
      expectedResult: {
        indexes: [{
          changedOn: 'some time',
          count: 2,
          filter: 'fil',
          index: 'idx',
          order: 'asc'
        }]
      }
    }, {
      name: 'new data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: [{
            key: 'k'
          }, {
            key: 'k.1'
          }, {
            key: 'k.2'
          }]
        }]
      },
      action: {
        type: 'AREAS.AREA_TREES.INDEX.ADD',
        filter: 'fil',
        order: 'asc',
        changedOn: 'some time',
        count: 2,
        start: 1,
        data: [{
          key: 'k2'
        }, {
          key: 'k3'
        }]
      },
      expectedResult: {
        indexes: [{
          changedOn: 'some time',
          count: 2,
          filter: 'fil',
          index: {
            0: {
              key: 'k'
            },
            1: 'k2',
            2: 'k3'
          },
          order: 'asc'
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$2(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('setActive', function () {
    var tests = [{
      name: 'test',
      state: {
        activeKey: 'k1',
        activeKeys: ['ks1', 'ks2']
      },
      action: {
        type: 'AREAS.AREA_TREES.SET_ACTIVE_KEY',
        key: 'ak'
      },
      expectedResult: {
        activeKey: 'ak',
        activeKeys: null
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$2(test.state, test.action), test.expectedResult);
    });
  });
  describe('registerUseIndexed', function () {
    var tests = [{
      name: 'existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      },
      action: {
        type: 'AREAS.AREA_TREES.USE.INDEXED.REGISTER',
        componentId: 'compId',
        filterByActive: 'fba',
        filter: 'f',
        order: 'asc',
        start: 4,
        length: 2
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      }
    }, {
      name: 'non existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      },
      action: {
        type: 'AREAS.AREA_TREES.USE.INDEXED.REGISTER',
        componentId: 'compId',
        filterByActive: '_fba',
        filter: 'f',
        order: 'asc',
        start: 4,
        length: 2
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }, {
              filterByActive: '_fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$2(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('useIndexedClear', function () {
    var tests = [{
      name: 'no index',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {
        type: 'AREAS.AREA_TREES.USE.INDEXED.CLEAR',
        componentId: 'some2'
      },
      expectedResult: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      }
    }, {
      name: 'matched index',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {
        type: 'AREAS.AREA_TREES.USE.INDEXED.CLEAR',
        componentId: 'some3'
      },
      expectedResult: {
        inUse: {
          indexes: {
            some: 'some'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$2(test.state, test.action), test.expectedResult);
    });
  });
  describe('useKeysRegister', function () {
    var tests = [{
      name: 'no initial keys',
      state: {
        inUse: {}
      },
      action: {
        type: 'AREAS.AREA_TREES.USE.KEYS.REGISTER',
        componentId: 'comp',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k2']
          }
        }
      }
    }, {
      name: 'with initial keys',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3']
          }
        }
      },
      action: {
        type: 'AREAS.AREA_TREES.USE.KEYS.REGISTER',
        componentId: 'comp',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$2(test.state, test.action), test.expectedResult);
    });
  });
  describe('useKeysClear', function () {
    var tests = [{
      name: 'non existing',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      },
      action: {
        type: 'AREAS.AREA_TREES.USE.KEYS.CLEAR',
        componentId: 'comp2'
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      }
    }, {
      name: 'single',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2'],
            comp2: ['kc']
          }
        }
      },
      action: {
        type: 'AREAS.AREA_TREES.USE.KEYS.CLEAR',
        componentId: 'comp'
      },
      expectedResult: {
        inUse: {
          keys: {
            comp2: ['kc']
          }
        }
      }
    }, {
      name: 'last',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      },
      action: {
        type: 'AREAS.AREA_TREES.USE.KEYS.CLEAR',
        componentId: 'comp'
      },
      expectedResult: {
        inUse: {
          keys: null
        }
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$2(test.state, test.action), test.expectedResult);
    });
  });
  describe('clearIndexes', function () {
    var tests = [{
      name: 'empty',
      state: {
        indexes: []
      },
      action: {
        type: 'AREAS.AREA_TREES.INDEX.CLEAR_ALL'
      },
      expectedResult: {
        indexes: null
      }
    }, {
      name: 'non empty',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: 5,
          index: ['v1', 'v2'],
          changedOn: 'changed on'
        }]
      },
      action: {
        type: 'AREAS.AREA_TREES.INDEX.CLEAR_ALL'
      },
      expectedResult: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: null,
          index: null,
          changedOn: null,
          outdated: ['v1', 'v2'],
          outdatedCount: 5
        }]
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$2(test.state, test.action), test.expectedResult);
    });
  });
  describe('dataSetOutdated', function () {
    var tests = [{
      name: 'empty',
      state: {
        byKey: {}
      },
      action: {
        type: 'COMMON.DATA.SET_OUTDATED'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'non empty',
      state: {
        byKey: {
          k1: {
            data: {
              p: 1
            }
          },
          k2: {
            data: {
              p: 2
            }
          }
        }
      },
      action: {
        type: 'COMMON.DATA.SET_OUTDATED'
      },
      expectedResult: {
        byKey: {
          k1: {
            data: {
              p: 1
            },
            outdated: true
          },
          k2: {
            data: {
              p: 2
            },
            outdated: true
          }
        }
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$2(test.state, test.action), test.expectedResult);
    });
  });
  describe('cleanupOnLogout', function () {
    var tests = [{
      name: 'test',
      state: {
        byKey: {
          k1: {
            data: {
              p: 1
            },
            permissions: {
              guest: {
                get: true
              }
            }
          },
          k2: {
            data: {
              p: 2
            }
          },
          k3: {
            data: {
              p: 3
            },
            permissions: {
              guest: {
                get: true
              }
            }
          }
        }
      },
      action: {
        type: 'COMMON.DATA.CLEANUP_ON_LOGOUT'
      },
      expectedResult: {
        byKey: {
          k1: {
            data: {
              p: 1
            },
            permissions: {
              guest: {
                get: true
              }
            }
          },
          k3: {
            data: {
              p: 3
            },
            permissions: {
              guest: {
                get: true
              }
            }
          }
        }
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$2(test.state, test.action), test.expectedResult);
    });
  });
  it('unknown', function () {
    chai.assert.deepStrictEqual(reducer$2({}, {
      type: 'UNKNOWN_ACTION'
    }), {});
  });
});

describe('state/Areas/AreaTrees/selectors', function () {
  describe('getAll', function () {
    var tests = [{
      name: 'null',
      state: {
        areas: {
          areaTrees: {
            byKey: null
          }
        }
      },
      expectedResult: []
    }, {
      name: 'empty',
      state: {
        areas: {
          areaTrees: {
            byKey: {}
          }
        }
      },
      expectedResult: []
    }, {
      name: 'some',
      state: {
        areas: {
          areaTrees: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              },
              k3: {
                n: 3,
                removed: true
              }
            }
          }
        }
      },
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$5.getAll(test.state), test.expectedResult);
      });
    });
  });
  describe('getAllAsObject', function () {
    var tests = [{
      name: 'null',
      state: {
        areas: {
          areaTrees: {
            byKey: {}
          }
        }
      },
      expectedResult: {}
    }, {
      name: 'empty',
      state: {
        areas: {
          areaTrees: {
            byKey: {}
          }
        }
      },
      expectedResult: {}
    }, {
      name: 'some',
      state: {
        areas: {
          areaTrees: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              },
              k3: {
                n: 3,
                removed: true
              }
            }
          }
        }
      },
      expectedResult: {
        k1: {
          n: 1
        },
        k2: {
          n: 2
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$5.getAllAsObject(test.state), test.expectedResult);
      });
    });
  });
  describe('getAllForActiveScope', function () {
    var tests = [{
      name: 'empty models',
      state: {
        areas: {
          areaTrees: {}
        },
        scopes: {
          activeKey: 'scopeK'
        }
      },
      expectedResult: null
    }, {
      name: 'empty indexes',
      state: {
        areas: {
          areaTrees: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              }
            },
            indexes: []
          }
        },
        scopes: {
          activeKey: 'scopeK'
        }
      },
      expectedResult: null
    }, {
      name: 'no active skope key',
      state: {
        areas: {
          areaTrees: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              }
            },
            indexes: [{
              filter: 'fil',
              order: 'desc'
            }, {
              filter: {
                scopeKey: 'scopeK'
              },
              order: 'asc',
              count: 4,
              index: [null, 'k1', 'k2', 'k3']
            }]
          }
        },
        scopes: {}
      },
      expectedResult: null
    }, {
      name: 'some',
      state: {
        areas: {
          areaTrees: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              }
            },
            indexes: [{
              filter: 'fil',
              order: 'desc'
            }, {
              filter: {
                scopeKey: 'scopeK'
              },
              order: 'asc',
              count: 4,
              index: [null, 'k1', 'k2', 'k3']
            }]
          }
        },
        scopes: {
          activeKey: 'scopeK'
        }
      },
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }, {
        key: 'k3'
      }, null]
    }];
    var order = 'asc';
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$5.getAllForActiveScope(test.state, order), test.expectedResult);
      });
    });
  });
  it('getActiveKey', function () {
    var state = {
      areas: {
        areaTrees: {
          activeKey: 'k'
        }
      }
    };
    chai.assert.strictEqual(selectors$5.getActiveKey(state), 'k');
  });
  describe('getActive', function () {
    var createState = function createState(activeKey) {
      return {
        areas: {
          areaTrees: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              },
              k3: {
                n: 3,
                removed: true
              }
            },
            activeKey: activeKey
          }
        }
      };
    };

    it('select active', function () {
      chai.assert.deepStrictEqual(selectors$5.getActive(createState('k1')), {
        n: 1
      });
    });
    it('select inactive', function () {
      chai.assert.isNull(selectors$5.getActive(createState('k3')));
    });
  });
  it('getSubstate', function () {
    chai.assert.strictEqual(selectors$5.getSubstate({
      areas: {
        areaTrees: 'subst'
      }
    }), 'subst');
  });
  describe('getByKeys', function () {
    var tests = [{
      name: 'null keys',
      state: {
        areas: {
          areaTrees: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              },
              k3: {
                n: 3
              }
            }
          }
        }
      },
      keys: null,
      expectedResult: null
    }, {
      name: 'empty keys',
      state: {
        areas: {
          areaTrees: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              },
              k3: {
                n: 3
              }
            }
          }
        }
      },
      keys: [],
      expectedResult: null
    }, {
      name: 'none',
      state: {
        areas: {
          areaTrees: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              },
              k3: {
                n: 3
              }
            }
          }
        }
      },
      keys: ['k5', 'k6'],
      expectedResult: null
    }, {
      name: 'empty',
      state: {
        areas: {
          areaTrees: {}
        }
      },
      keys: ['k1', 'k2'],
      expectedResult: null
    }, {
      name: 'some',
      state: {
        areas: {
          areaTrees: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              },
              k3: {
                n: 3
              }
            }
          }
        }
      },
      keys: ['k1', 'k2'],
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$5.getByKeys(test.state, test.keys), test.expectedResult);
      });
    });
  });
  describe('getByKeysAsObject', function () {
    var tests = [{
      name: 'null keys',
      state: {
        areas: {
          areaTrees: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              },
              k3: {
                n: 3
              }
            }
          }
        }
      },
      keys: null,
      expectedResult: null
    }, {
      name: 'none',
      state: {
        areas: {
          areaTrees: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              },
              k3: {
                n: 3
              }
            }
          }
        }
      },
      keys: ['k5', 'k6'],
      expectedResult: null
    }, {
      name: 'some',
      state: {
        areas: {
          areaTrees: {
            byKey: {
              k1: {
                n: 1
              },
              k2: {
                n: 2
              },
              k3: {
                n: 3
              }
            }
          }
        }
      },
      keys: ['k1', 'k2'],
      expectedResult: {
        k1: {
          n: 1
        },
        k2: {
          n: 2
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$5.getByKeysAsObject(test.state, test.keys), test.expectedResult);
      });
    });
  });
});

describe('state/AttributeData/actions', function () {
  var dispatchedActions = [];

  var dispatch = function dispatch(action) {
    dispatchedActions.push(action);
  };

  this.afterEach(function () {
    resetFetch();
    dispatchedActions = [];
  });

  var runFunctionActions = function runFunctionActions(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return new Promise(function (resolve, reject) {
      var promises = [];

      for (var i = 0; i < dispatchedActions.length; i++) {
        var action = dispatchedActions[i];

        if (typeof action === 'function') {
          promises.push(action(dispatch, getState));
          dispatchedActions[i] = null;
        } else if (action instanceof Promise) {
          promises.push(action);
          dispatchedActions[i] = null;
        }
      }

      dispatchedActions = dispatchedActions.filter(function (a) {
        return a !== null;
      });

      if (promises.length > 0) {
        return Promise.all(promises).then(function () {
          return runFunctionActions({
            dispatch: dispatch,
            getState: getState
          });
        }).then(function () {
          return resolve();
        });
      }

      resolve();
    });
  };

  it('useIndexed', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributes: {
          activeKey: 'k1'
        },
        scopes: {
          activeKey: 'k1'
        },
        periods: {
          activeKey: 'k1'
        },
        places: {
          activeKey: 'k1'
        },
        attributeData: {}
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/data/filtered/attribute', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          attribute: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          attribute: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$4.useIndexed({
      name: 'afil'
    }, {
      name: 'fil'
    }, 'asc', 1, 5, 'cid')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        componentId: 'cid',
        filterByActive: {
          name: 'afil'
        },
        filter: {
          name: 'fil'
        },
        order: 'asc',
        start: 1,
        length: 5,
        type: 'ATTRIBUTE_DATA.USE.INDEXED.REGISTER'
      }, {
        filter: {
          name: 'fil'
        },
        order: 'asc',
        count: 2,
        start: 1,
        data: {
          k1: {},
          k2: {}
        },
        changedOn: '2020-01-01',
        type: 'ATTRIBUTE_DATA.INDEX.ADD'
      }]);
    });
  });
  it('useIndexedClear', function () {
    actions$4.useIndexedClear('cid')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'ATTRIBUTE_DATA.USE.INDEXED.CLEAR',
      componentId: 'cid'
    }]);
  });
});

var INITIAL_STATE$3 = _objectSpread2({}, DEFAULT_INITIAL_STATE); // Add should be actually update, because dataSourceKey is used as key


var update$1 = function update(state, action) {
  var newData = _objectSpread2({}, state.byKey);

  if (action.data && action.data.length) {
    action.data.forEach(function (model) {
      var previousData = newData[model.attributeDataSourceKey];

      if (previousData) {
        var fidColumnName = action.filter.fidColumnName;
        var previousFeatures = previousData.attributeData.features;
        var nextFeatures = model.attributeData.features;
        var newFeaturesAsObject = {};

        _forEach__default['default'](previousFeatures, function (feature) {
          newFeaturesAsObject[feature.properties[fidColumnName]] = feature;
        });

        _forEach__default['default'](nextFeatures, function (feature) {
          var key = feature.properties[fidColumnName];
          newFeaturesAsObject[key] = feature;
        });

        newData[model.attributeDataSourceKey] = _objectSpread2(_objectSpread2({}, newData[model.attributeDataSourceKey]), {}, {
          attributeData: _objectSpread2(_objectSpread2({}, newData[model.attributeDataSourceKey].attributeData), {}, {
            features: Object.values(newFeaturesAsObject)
          })
        });
      } else {
        newData[model.attributeDataSourceKey] = model;
      }
    });
  }

  return _objectSpread2(_objectSpread2({}, state), {}, {
    byKey: newData
  });
};

var reducer$3 = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE$3;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case ActionTypes.ATTRIBUTE_DATA.ADD:
      return update$1(state, action);

    case ActionTypes.ATTRIBUTE_DATA.ADD_BATCH:
      return common.addBatch(state, action);

    case ActionTypes.ATTRIBUTE_DATA.ADD_UNRECEIVED:
      return common.addUnreceivedKeys(state, action);

    case ActionTypes.ATTRIBUTE_DATA.INDEX.ADD:
      return common.addIndex(state, action);

    case ActionTypes.ATTRIBUTE_DATA.INDEX.ADD_BATCH:
      return common.addBatchIndex(state, action);

    case ActionTypes.ATTRIBUTE_DATA.USE.INDEXED.REGISTER:
      return common.registerUseIndexed(state, action);

    case ActionTypes.ATTRIBUTE_DATA.USE.INDEXED_BATCH.REGISTER:
      return common.registerBatchUseIndexed(state, action);

    case ActionTypes.ATTRIBUTE_DATA.USE.INDEXED.CLEAR:
      return common.useIndexedClear(state, action);

    default:
      return state;
  }
});

describe('state/AttributeData/reducers', function () {
  describe('addUnreceivedKeys', function () {
    var tests = [{
      name: 'no keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_DATA.ADD_UNRECEIVED'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_DATA.ADD_UNRECEIVED',
        keys: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_DATA.ADD_UNRECEIVED',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            unreceived: true
          },
          k2: {
            key: 'k2',
            unreceived: true
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$3(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addIndex', function () {
    var tests = [{
      name: 'empty data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: 'idx'
        }]
      },
      action: {
        type: 'ATTRIBUTE_DATA.INDEX.ADD',
        filter: 'fil',
        order: 'asc',
        changedOn: 'some time',
        count: 2,
        data: []
      },
      expectedResult: {
        indexes: [{
          changedOn: 'some time',
          count: 2,
          filter: 'fil',
          index: 'idx',
          order: 'asc'
        }]
      }
    }, {
      name: 'new data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: [{
            key: 'k'
          }, {
            key: 'k.1'
          }, {
            key: 'k.2'
          }]
        }]
      },
      action: {
        type: 'ATTRIBUTE_DATA.INDEX.ADD',
        filter: 'fil',
        order: 'asc',
        changedOn: 'some time',
        count: 2,
        start: 1,
        data: [{
          key: 'k2'
        }, {
          key: 'k3'
        }]
      },
      expectedResult: {
        indexes: [{
          changedOn: 'some time',
          count: 2,
          filter: 'fil',
          index: {
            0: {
              key: 'k'
            },
            1: 'k2',
            2: 'k3'
          },
          order: 'asc'
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$3(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('registerUseIndexed', function () {
    var tests = [{
      name: 'existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_DATA.USE.INDEXED.REGISTER',
        componentId: 'compId',
        filterByActive: 'fba',
        filter: 'f',
        order: 'asc',
        start: 4,
        length: 2
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      }
    }, {
      name: 'non existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_DATA.USE.INDEXED.REGISTER',
        componentId: 'compId',
        filterByActive: '_fba',
        filter: 'f',
        order: 'asc',
        start: 4,
        length: 2
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }, {
              filterByActive: '_fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$3(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('useIndexedClear', function () {
    var tests = [{
      name: 'no index',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_DATA.USE.INDEXED.CLEAR',
        componentId: 'some2'
      },
      expectedResult: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      }
    }, {
      name: 'matched index',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_DATA.USE.INDEXED.CLEAR',
        componentId: 'some3'
      },
      expectedResult: {
        inUse: {
          indexes: {
            some: 'some'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$3(test.state, test.action), test.expectedResult);
    });
  });
  it('unknown', function () {
    chai.assert.deepStrictEqual(reducer$3({}, {
      type: 'UNKNOWN_ACTION'
    }), {});
  });
  describe('addBatch', function () {
    var tests = [{
      name: 'no data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_DATA.ADD_BATCH'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_DATA.ADD_BATCH',
        data: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_DATA.ADD_BATCH',
        key: 'someKey',
        data: [{
          key: 'k1',
          someKey: 'sk1',
          name: 'first'
        }, {
          key: 'k2',
          someKey: 'sk2',
          name: 'second',
          outdated: true,
          unreceived: true
        }]
      },
      expectedResult: {
        byKey: {
          sk1: {
            key: 'k1',
            someKey: 'sk1',
            name: 'first'
          },
          sk2: {
            key: 'k2',
            someKey: 'sk2',
            name: 'second'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$3(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addBatchIndex', function () {
    var tests = [{
      name: 'empty data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: 'idx'
        }]
      },
      action: {
        type: 'ATTRIBUTE_DATA.INDEX.ADD_BATCH',
        filter: 'fil',
        order: 'asc',
        key: 'someKey',
        data: []
      },
      expectedResult: {
        indexes: [{
          filter: 'fil',
          index: 'idx',
          order: 'asc'
        }]
      }
    }, {
      name: 'new data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: [{
            someKey: 'k'
          }, {
            someKey: 'k.1'
          }, {
            someKey: 'k.2'
          }]
        }]
      },
      action: {
        type: 'ATTRIBUTE_DATA.INDEX.ADD_BATCH',
        filter: 'fil',
        order: 'asc',
        key: 'someKey',
        data: [{
          someKey: 'k2'
        }, {
          someKey: 'k3'
        }]
      },
      expectedResult: {
        indexes: [{
          filter: 'fil',
          index: {
            0: 'k2',
            1: 'k3',
            2: {
              someKey: 'k.2'
            }
          },
          order: 'asc'
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$3(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('registerBatchUseIndexed', function () {
    var tests = [{
      name: 'existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc'
            }]
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_DATA.USE.INDEXED_BATCH.REGISTER',
        componentId: 'compId',
        filterByActive: 'fba',
        filter: 'f',
        order: 'asc'
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc'
            }]
          }
        }
      }
    }, {
      name: 'non existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc'
            }]
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_DATA.USE.INDEXED_BATCH.REGISTER',
        componentId: 'compId',
        filterByActive: '_fba',
        filter: 'f',
        order: 'asc'
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc'
            }, {
              filterByActive: '_fba',
              filter: 'f',
              order: 'asc'
            }]
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$3(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('update', function () {
    var tests = [{
      name: 'merge',
      state: {
        byKey: {
          k1: {
            key: 'k1'
          },
          k3: {
            key: 'k3',
            attributeData: {
              features: [{
                properties: {
                  fid: 'f1'
                },
                cv: '1'
              }]
            }
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_DATA.ADD',
        data: [{
          attributeDataSourceKey: 'k2'
        }, {
          attributeDataSourceKey: 'k3',
          attributeData: {
            features: [{
              properties: {
                fid: 'f2'
              },
              cv: '2'
            }]
          }
        }],
        filter: {
          fidColumnName: 'fid'
        }
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1'
          },
          k2: {
            attributeDataSourceKey: 'k2'
          },
          k3: {
            attributeData: {
              features: [{
                cv: '1',
                properties: {
                  fid: 'f1'
                }
              }, {
                cv: '2',
                properties: {
                  fid: 'f2'
                }
              }]
            },
            key: 'k3'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$3(test.state, test.action), test.expectedResult);
      });
    });
  });
});

describe('state/AttributeData/selectors', function () {
  describe('getAllAsObject', function () {
    var tests = [{
      name: 'null',
      state: {
        attributeData: {
          byKey: {}
        }
      },
      expectedResult: {}
    }, {
      name: 'empty',
      state: {
        attributeData: {
          byKey: {}
        }
      },
      expectedResult: {}
    }, {
      name: 'some',
      state: {
        attributeData: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        }
      },
      expectedResult: {
        k1: {
          n: 1
        },
        k2: {
          n: 2
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$1.getAllAsObject(test.state), test.expectedResult);
      });
    });
  });
  it('getSubstate', function () {
    chai.assert.strictEqual(selectors$1.getSubstate({
      attributeData: 'subst'
    }), 'subst');
  });
  describe('getByKey', function () {
    var tests = [{
      name: 'none',
      state: {
        attributeData: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: 'k3',
      expectedResult: null
    }, {
      name: 'null key',
      state: {
        attributeData: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: null,
      expectedResult: undefined
    }, {
      name: 'some',
      state: {
        attributeData: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: 'k1',
      expectedResult: {
        n: 1
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$1.getByKey(test.state, test.key), test.expectedResult);
      });
    });
  });
  describe('getBatchByFilterOrder', function () {
    var tests = [{
      name: 'empty models',
      state: {
        attributeData: {
          byKey: {},
          indexes: [{
            filter: 'fil',
            order: 'desc'
          }, {
            filter: {
              scopeKey: 'scopeK'
            },
            order: 'asc',
            count: 4,
            index: [null, 'k1', 'k2', 'k3']
          }]
        }
      },
      expectedResult: [null, null, null, null]
    }, {
      name: 'empty indexes',
      state: {
        attributeData: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          },
          indexes: []
        }
      },
      expectedResult: null
    }, {
      name: 'some',
      state: {
        attributeData: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          },
          indexes: [{
            filter: 'fil',
            order: 'desc'
          }, {
            filter: {
              scopeKey: 'scopeK'
            },
            order: 'asc',
            count: 4,
            index: [null, 'k1', 'k2', 'k3']
          }]
        }
      },
      expectedResult: [null, {
        n: 1
      }, {
        n: 2
      }, null]
    }];
    var filter = {
      scopeKey: 'scopeK'
    };
    var order = 'asc';
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$1.getBatchByFilterOrder(test.state, filter, order), test.expectedResult);
      });
    });
  });
  describe('getFiltered', function () {
    var tests = [{
      name: 'null',
      state: {
        attributeData: {
          byKey: {}
        },
        attributeRelations: {
          byKey: {}
        }
      },
      expectedResult: null
    }, {
      name: 'some',
      state: {
        attributeData: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        },
        attributeRelations: {
          byKey: {
            r1: {
              data: {
                v: 1,
                dataSourceKey: 'k1'
              }
            },
            r2: {
              data: {
                v: 2
              }
            }
          }
        }
      },
      expectedResult: {
        n: 1
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$1.getFiltered(test.state, ['v', 1]), test.expectedResult);
      });
    });
  });
  describe('getFilteredGroupedByLayerKey', function () {
    var tests = [{
      name: 'some',
      state: {
        attributeData: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        },
        attributeRelations: {
          byKey: {
            r1: {
              data: {
                v: 1,
                attributeDataSourceKey: 'k1'
              }
            },
            r2: {
              data: {
                v: 2
              }
            }
          }
        }
      },
      expectedResult: {
        l1: [{
          attributeRelationData: {
            attributeDataSourceKey: 'k1',
            v: 1
          },
          n: 1
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$1.getFilteredGroupedByLayerKey(test.state, [{
          data: {
            key: 'l1'
          },
          filter: ['v', 1]
        }]), test.expectedResult);
      });
    });
  });
  describe('getFilteredGroupedByFid', function () {
    var tests = [{
      name: 'some',
      state: {
        attributeData: {
          byKey: {
            k1: {
              n: 1,
              attributeData: {
                features: [{
                  properties: {
                    fid: 1
                  }
                }]
              }
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        },
        attributeRelations: {
          byKey: {
            r1: {
              data: {
                v: 1,
                attributeDataSourceKey: 'k1',
                fidColumnName: 'fid'
              }
            },
            r2: {
              data: {
                v: 2
              }
            }
          }
        }
      },
      expectedResult: [{
        key: 1,
        data: {
          name: 1,
          values: []
        }
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$1.getFilteredGroupedByFid(test.state, [{
          data: {
            key: 'l1'
          },
          filter: ['v', 1]
        }]), test.expectedResult);
      });
    });
  });
  describe('getNamesByFid', function () {
    var tests = [{
      name: 'some',
      state: {
        attributeData: {
          byKey: {
            k1: {
              n: 1,
              attributeData: {
                features: [{
                  properties: {
                    fid: 1,
                    p: 'v'
                  }
                }]
              }
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        },
        attributeRelations: {
          byKey: {
            r1: {
              data: {
                v: 1,
                attributeDataSourceKey: 'k1',
                fidColumnName: 'fid'
              }
            }
          }
        }
      },
      expectedResult: [{
        data: {
          name: 'v'
        },
        key: 1
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$1.getNamesByFid(test.state, [{
          data: {
            key: 'l1'
          },
          filter: ['v', 1]
        }]), test.expectedResult);
      });
    });
  });
});

describe('state/AttributeDataSources/actions', function () {
  var dispatchedActions = [];

  var dispatch = function dispatch(action) {
    dispatchedActions.push(action);
  };

  this.afterEach(function () {
    dispatchedActions = [];
  });

  var runFunctionActions = function runFunctionActions(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return new Promise(function (resolve, reject) {
      var promises = [];

      for (var i = 0; i < dispatchedActions.length; i++) {
        var action = dispatchedActions[i];

        if (typeof action === 'function') {
          promises.push(action(dispatch, getState));
          dispatchedActions[i] = null;
        } else if (action instanceof Promise) {
          promises.push(action);
          dispatchedActions[i] = null;
        }
      }

      dispatchedActions = dispatchedActions.filter(function (a) {
        return a !== null;
      });

      if (promises.length > 0) {
        return Promise.all(promises).then(function () {
          return runFunctionActions({
            dispatch: dispatch,
            getState: getState
          });
        }).then(function () {
          return resolve();
        });
      }

      resolve();
    });
  };

  it('useKeys', function () {
    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributeDataSources: {
          byKey: {
            k1: {
              key: 'k1'
            },
            k2: {
              key: 'k2'
            }
          }
        }
      };
    };

    return actions$6.useKeys(['k1', 'k2'], 'cid')(dispatch).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        componentId: 'cid',
        keys: ['k1', 'k2'],
        type: 'ATTRIBUTE_DATA_SOURCES.USE.KEYS.REGISTER'
      }]);
    });
  });
  it('useKeysClear', function () {
    actions$6.useKeysClear('cid')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'ATTRIBUTE_DATA_SOURCES.USE.KEYS.CLEAR',
      componentId: 'cid'
    }]);
  });
});

var INITIAL_STATE$4 = _objectSpread2({}, DEFAULT_INITIAL_STATE);

var reducer$4 = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE$4;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case ActionTypes.ATTRIBUTE_DATA_SOURCES.ADD:
      return common.add(state, action);

    case ActionTypes.ATTRIBUTE_DATA_SOURCES.ADD_UNRECEIVED:
      return common.addUnreceivedKeys(state, action);

    case ActionTypes.ATTRIBUTE_DATA_SOURCES.USE.KEYS.REGISTER:
      return common.useKeysRegister(state, action);

    case ActionTypes.ATTRIBUTE_DATA_SOURCES.USE.KEYS.CLEAR:
      return common.useKeysClear(state, action);

    default:
      return state;
  }
});

describe('state/AttributeDataSources/reducers', function () {
  describe('add', function () {
    var tests = [{
      name: 'no data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_DATA_SOURCES.ADD'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_DATA_SOURCES.ADD',
        data: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_DATA_SOURCES.ADD',
        data: [{
          key: 'k1',
          name: 'first'
        }, {
          key: 'k2',
          name: 'second',
          outdated: true,
          unreceived: true
        }]
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            name: 'first'
          },
          k2: {
            key: 'k2',
            name: 'second'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$4(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addUnreceivedKeys', function () {
    var tests = [{
      name: 'no keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_DATA_SOURCES.ADD_UNRECEIVED'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_DATA_SOURCES.ADD_UNRECEIVED',
        keys: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_DATA_SOURCES.ADD_UNRECEIVED',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            unreceived: true
          },
          k2: {
            key: 'k2',
            unreceived: true
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$4(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('useKeysRegister', function () {
    var tests = [{
      name: 'no initial keys',
      state: {
        inUse: {}
      },
      action: {
        type: 'ATTRIBUTE_DATA_SOURCES.USE.KEYS.REGISTER',
        componentId: 'comp',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k2']
          }
        }
      }
    }, {
      name: 'with initial keys',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3']
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_DATA_SOURCES.USE.KEYS.REGISTER',
        componentId: 'comp',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$4(test.state, test.action), test.expectedResult);
    });
  });
  describe('useKeysClear', function () {
    var tests = [{
      name: 'non existing',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_DATA_SOURCES.USE.KEYS.CLEAR',
        componentId: 'comp2'
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      }
    }, {
      name: 'single',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2'],
            comp2: ['kc']
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_DATA_SOURCES.USE.KEYS.CLEAR',
        componentId: 'comp'
      },
      expectedResult: {
        inUse: {
          keys: {
            comp2: ['kc']
          }
        }
      }
    }, {
      name: 'last',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_DATA_SOURCES.USE.KEYS.CLEAR',
        componentId: 'comp'
      },
      expectedResult: {
        inUse: {
          keys: null
        }
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$4(test.state, test.action), test.expectedResult);
    });
  });
  it('unknown', function () {
    chai.assert.deepStrictEqual(reducer$4({}, {
      type: 'UNKNOWN_ACTION'
    }), {});
  });
});

describe('state/AttributeDataSources/selectors', function () {
  it('getSubstate', function () {
    chai.assert.strictEqual(selectors$2.getSubstate({
      attributeDataSources: 'subst'
    }), 'subst');
  });
  describe('getByKey', function () {
    var tests = [{
      name: 'none',
      state: {
        attributeDataSources: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: 'k3',
      expectedResult: null
    }, {
      name: 'null key',
      state: {
        attributeDataSources: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: null,
      expectedResult: undefined
    }, {
      name: 'some',
      state: {
        attributeDataSources: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: 'k1',
      expectedResult: {
        n: 1
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$2.getByKey(test.state, test.key), test.expectedResult);
      });
    });
  });
  describe('getByKeys', function () {
    var tests = [{
      name: 'null keys',
      state: {
        attributeDataSources: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: null,
      expectedResult: null
    }, {
      name: 'empty keys',
      state: {
        attributeDataSources: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: [],
      expectedResult: null
    }, {
      name: 'none',
      state: {
        attributeDataSources: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: ['k5', 'k6'],
      expectedResult: null
    }, {
      name: 'empty',
      state: {
        attributeDataSources: {}
      },
      keys: ['k1', 'k2'],
      expectedResult: null
    }, {
      name: 'some',
      state: {
        attributeDataSources: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: ['k1', 'k2'],
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$2.getByKeys(test.state, test.keys), test.expectedResult);
      });
    });
  });
  describe('getFiltered', function () {
    var tests = [{
      name: 'null',
      state: {
        attributeDataSources: {
          byKey: {}
        },
        attributeRelations: {
          byKey: {}
        }
      },
      expectedResult: null
    }, {
      name: 'some',
      state: {
        attributeDataSources: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        },
        attributeRelations: {
          byKey: {
            r1: {
              data: {
                v: 1,
                dataSourceKey: 'k1'
              }
            },
            r2: {
              data: {
                v: 2
              }
            }
          }
        }
      },
      expectedResult: {
        n: 1
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$2.getFiltered(test.state, ['v', 1]), test.expectedResult);
      });
    });
  });
  describe('getFilteredGroupedByLayerKey', function () {
    var tests = [{
      name: 'some',
      state: {
        attributeDataSources: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        },
        attributeRelations: {
          byKey: {
            r1: {
              data: {
                v: 1,
                attributeDataSourceKey: 'k1'
              }
            },
            r2: {
              data: {
                v: 2
              }
            }
          }
        }
      },
      expectedResult: {
        l1: [{
          attributeRelationData: {
            attributeDataSourceKey: 'k1',
            v: 1
          },
          n: 1
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$2.getFilteredGroupedByLayerKey(test.state, [{
          data: {
            key: 'l1'
          },
          filter: ['v', 1]
        }]), test.expectedResult);
      });
    });
  });
  describe('getBatchByFilterOrder', function () {
    var tests = [{
      name: 'empty models',
      state: {
        attributeDataSources: {
          byKey: {},
          indexes: [{
            filter: 'fil',
            order: 'desc'
          }, {
            filter: {
              scopeKey: 'scopeK'
            },
            order: 'asc',
            count: 4,
            index: [null, 'k1', 'k2', 'k3']
          }]
        }
      },
      expectedResult: [null, null, null, null]
    }, {
      name: 'empty indexes',
      state: {
        attributeDataSources: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          },
          indexes: []
        }
      },
      expectedResult: null
    }, {
      name: 'some',
      state: {
        attributeDataSources: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          },
          indexes: [{
            filter: 'fil',
            order: 'desc'
          }, {
            filter: {
              scopeKey: 'scopeK'
            },
            order: 'asc',
            count: 4,
            index: [null, 'k1', 'k2', 'k3']
          }]
        }
      },
      expectedResult: [null, {
        n: 1
      }, {
        n: 2
      }, null]
    }];
    var filter = {
      scopeKey: 'scopeK'
    };
    var order = 'asc';
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$2.getBatchByFilterOrder(test.state, filter, order), test.expectedResult);
      });
    });
  });
  describe('getFilteredDataSources', function () {
    var tests = [{
      name: 'some',
      state: {
        attributeDataSources: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        },
        attributeData: {
          byKey: {
            ad1: {
              n: 1
            },
            ad2: {
              n: 2
            },
            ad33: {
              n: 3,
              removed: true
            }
          }
        },
        attributeRelations: {
          byKey: {
            r1: {
              data: {
                v: 1,
                attributeDataSourceKey: 'k1',
                attributeKey: 'ad1',
                fidColumnName: 'fid'
              }
            }
          }
        }
      },
      filter: {
        attributeKey: {
          "in": ['ad1']
        }
      },
      expectedResult: [{
        attributeKey: 'ad1',
        dataSource: {
          n: 1
        },
        fidColumnName: 'fid',
        periodKey: undefined
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$2.getFilteredDataSources(test.state, test.filter), test.expectedResult);
      });
    });
  });
  describe('getFilteredDataSourcesGroupedByLayerKey', function () {
    var tests = [{
      name: 'some',
      state: {
        attributeDataSources: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        },
        attributeData: {
          byKey: {
            ad1: {
              n: 1
            },
            ad2: {
              n: 2
            },
            ad33: {
              n: 3,
              removed: true
            }
          }
        },
        attributeRelations: {
          byKey: {
            r1: {
              data: {
                v: 1,
                attributeDataSourceKey: 'k1',
                attributeKey: 'ad1',
                fidColumnName: 'fid'
              }
            }
          }
        }
      },
      layersWithFilter: [{
        key: 'l1',
        attributeFilter: {
          v: 1,
          attributeDataSourceKey: 'k1',
          attributeKey: 'ad1',
          fidColumnName: 'fid'
        }
      }],
      layersState: [{
        key: 'l1',
        attributeKeys: ['ad1']
      }],
      expectedResult: {
        l1: [{
          attributeKey: 'ad1',
          dataSource: {
            n: 1
          },
          fidColumnName: 'fid'
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$2.getFilteredDataSourcesGroupedByLayerKey(test.state, test.layersWithFilter, test.layersState, 3), test.expectedResult);
      });
    });
  });
});

describe('state/AttributeRelations/actions', function () {
  var dispatchedActions = [];

  var dispatch = function dispatch(action) {
    dispatchedActions.push(action);
  };

  this.afterEach(function () {
    resetFetch();
    dispatchedActions = [];
  });

  var runFunctionActions = function runFunctionActions(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return new Promise(function (resolve, reject) {
      var promises = [];

      for (var i = 0; i < dispatchedActions.length; i++) {
        var action = dispatchedActions[i];

        if (typeof action === 'function') {
          promises.push(action(dispatch, getState));
          dispatchedActions[i] = null;
        } else if (action instanceof Promise) {
          promises.push(action);
          dispatchedActions[i] = null;
        }
      }

      dispatchedActions = dispatchedActions.filter(function (a) {
        return a !== null;
      });

      if (promises.length > 0) {
        return Promise.all(promises).then(function () {
          return runFunctionActions({
            dispatch: dispatch,
            getState: getState
          });
        }).then(function () {
          return resolve();
        });
      }

      resolve();
    });
  };

  it('useIndexed', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributes: {
          activeKey: 'k1'
        },
        scopes: {
          activeKey: 'k1'
        },
        periods: {
          activeKey: 'k1'
        },
        places: {
          activeKey: 'k1'
        },
        attributeRelations: {}
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/relations/filtered/attribute', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          attribute: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          attribute: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$7.useIndexed({
      name: 'afil'
    }, {
      name: 'fil'
    }, 'asc', 1, 5, 'cid')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        componentId: 'cid',
        filterByActive: {
          name: 'afil'
        },
        filter: {
          name: 'fil'
        },
        order: 'asc',
        start: 1,
        length: 5,
        type: 'ATTRIBUTE_RELATIONS.USE.INDEXED.REGISTER'
      }, {
        filter: {
          name: 'fil'
        },
        order: 'asc',
        count: 2,
        start: 1,
        data: {
          k1: {},
          k2: {}
        },
        changedOn: '2020-01-01',
        type: 'ATTRIBUTE_RELATIONS.INDEX.ADD'
      }]);
    });
  });
  it('useIndexedClearAll', function () {
    actions$7.useIndexedClearAll()(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'ATTRIBUTE_RELATIONS.USE.INDEXED.CLEAR_ALL'
    }]);
  });
  it('useIndexedRegister', function () {
    chai.assert.deepStrictEqual(actions$7.useIndexedRegister('cid', {
      name: 'afil'
    }, {
      name: 'fil'
    }, 'asc', 1, 5), {
      type: 'ATTRIBUTE_RELATIONS.USE.INDEXED.REGISTER',
      componentId: 'cid',
      filterByActive: {
        name: 'afil'
      },
      filter: {
        name: 'fil'
      },
      order: 'asc',
      start: 1,
      length: 5
    });
  });
  describe('ensureIndexed', function () {
    it('already loaded', function () {
      var getState = function getState() {
        return {
          app: {
            localConfiguration: {
              apiBackendProtocol: 'http',
              apiBackendHost: 'localhost',
              apiBackendPath: ''
            }
          },
          attributeRelations: {
            indexes: [{
              filter: {
                name: 'fil'
              },
              order: 'asc',
              count: 5,
              changedOn: '2020-01-01',
              index: ['k1', 'k2', 'k3', 'k4', 'k5']
            }]
          }
        };
      };

      actions$7.ensureIndexed({
        name: 'fil'
      }, 'asc', 0, 5)(dispatch, getState).then(function () {
        return runFunctionActions({
          dispatch: dispatch,
          getState: getState
        });
      }).then(function () {
        chai.assert.deepStrictEqual(dispatchedActions, []);
      });
    });
    it('missing keys', function () {
      var getState = function getState() {
        return {
          app: {
            localConfiguration: {
              apiBackendProtocol: 'http',
              apiBackendHost: 'localhost',
              apiBackendPath: ''
            }
          },
          attributeRelations: {
            indexes: [{
              filter: {
                name: 'fil'
              },
              order: 'asc',
              count: 5,
              changedOn: '2020-01-01',
              index: [null, 'k1', 'k2', 'k3']
            }]
          }
        };
      };

      var dispatch = function dispatch(action) {
        if (typeof action === 'function') {
          var res = action(dispatch, getState);

          if (res != null) {
            dispatchedActions.push(res);
          }

          return res;
        }

        dispatchedActions.push(action);
      };

      setFetch(function (url, options) {
        chai.assert.strictEqual('http://localhost/backend/rest/relations/filtered/attribute', slash__default['default'](url));
        chai.assert.deepStrictEqual(options, {
          body: JSON.stringify({
            filter: {
              name: 'fil',
              key: {
                notin: ['k1', 'k2', 'k3']
              }
            },
            offset: 0,
            order: 'asc',
            limit: 100
          }),
          credentials: 'include',
          headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json'
          },
          method: 'POST'
        });
        var body = {
          data: {
            attribute: {
              k3: {},
              k4: {}
            }
          },
          total: 5,
          changes: {
            attribute: '2020-01-01'
          }
        };
        return Promise.resolve({
          ok: true,
          json: function json() {
            return Promise.resolve(body);
          },
          headers: {
            get: function get(name) {
              return {
                'Content-type': 'application/json'
              }[name];
            }
          },
          data: JSON.stringify(body)
        });
      });
      return actions$7.ensureIndexed({
        name: 'fil'
      }, 'asc', 1, 5)(dispatch, getState).then(function () {
        return runFunctionActions({
          dispatch: dispatch,
          getState: getState
        });
      }).then(function () {
        chai.assert.deepStrictEqual(dispatchedActions, [{
          type: 'ATTRIBUTE_RELATIONS.INDEX.ADD',
          filter: {
            name: 'fil',
            key: {
              notin: ['k1', 'k2', 'k3']
            }
          },
          order: 'asc',
          start: 1,
          data: {
            k3: {},
            k4: {}
          },
          changedOn: '2020-01-01',
          count: 5
        }]);
      });
    });
    it('nothing loaded', function () {
      var getState = function getState() {
        return {
          app: {
            localConfiguration: {
              apiBackendProtocol: 'http',
              apiBackendHost: 'localhost',
              apiBackendPath: ''
            }
          },
          attributeRelations: {
            indexes: []
          }
        };
      };

      var dispatch = function dispatch(action) {
        if (typeof action === 'function') {
          var res = action(dispatch, getState);

          if (res != null) {
            dispatchedActions.push(res);
          }

          return res;
        }

        dispatchedActions.push(action);
      };

      setFetch(function (url, options) {
        chai.assert.strictEqual('http://localhost/backend/rest/relations/filtered/attribute', slash__default['default'](url));
        chai.assert.deepStrictEqual(options, {
          body: JSON.stringify({
            filter: {
              name: 'fil'
            },
            offset: 0,
            order: 'asc',
            limit: 100
          }),
          credentials: 'include',
          headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json'
          },
          method: 'POST'
        });
        var body = {
          data: {
            attribute: {
              k1: {},
              k2: {},
              k3: {},
              k4: {}
            }
          },
          total: 5,
          changes: {
            attribute: '2020-01-01'
          }
        };
        return Promise.resolve({
          ok: true,
          json: function json() {
            return Promise.resolve(body);
          },
          headers: {
            get: function get(name) {
              return {
                'Content-type': 'application/json'
              }[name];
            }
          },
          data: JSON.stringify(body)
        });
      });
      return actions$7.ensureIndexed({
        name: 'fil'
      }, 'asc', 1, 5)(dispatch, getState).then(function () {
        return runFunctionActions({
          dispatch: dispatch,
          getState: getState
        });
      }).then(function () {
        chai.assert.deepStrictEqual(dispatchedActions, [{
          type: 'ATTRIBUTE_RELATIONS.INDEX.ADD',
          filter: {
            name: 'fil'
          },
          order: 'asc',
          start: 1,
          data: {
            k1: {},
            k2: {},
            k3: {},
            k4: {}
          },
          changedOn: '2020-01-01',
          count: 5
        }]);
      });
    });
  });
  it('ensureIndexesWithFilterByActive', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributeRelations: {
          inUse: {
            indexes: [[{
              filterByActive: {
                name: 'fil'
              },
              filter: {
                name: 'fil'
              },
              order: 'asc',
              start: 1,
              length: 5
            }]]
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/relations/filtered/attribute', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          attribute: {
            k1: {},
            k2: {},
            k3: {},
            k4: {}
          }
        },
        total: 5,
        changes: {
          attribute: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    actions$7.ensureIndexesWithFilterByActive({
      name: 'fil'
    })(dispatch, getState);
    return runFunctionActions({
      dispatch: dispatch,
      getState: getState
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ATTRIBUTE_RELATIONS.INDEX.ADD',
        filter: {
          name: 'fil'
        },
        order: 'asc',
        start: 1,
        data: {
          k1: {},
          k2: {},
          k3: {},
          k4: {}
        },
        changedOn: '2020-01-01',
        count: 5
      }]);
    });
  });
  it('ensureIndexedSpecific', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributeRelations: {
          indexes: []
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/relations/filtered/attribute', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          attribute: {
            k1: {},
            k2: {},
            k3: {},
            k4: {}
          }
        },
        total: 5,
        changes: {
          attribute: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    actions$7.ensureIndexedSpecific({
      name: 'fil'
    }, 'asc', 1, 5, 'cid', true)(dispatch, getState);
    return runFunctionActions({
      dispatch: dispatch,
      getState: getState
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ATTRIBUTE_RELATIONS.INDEX.ADD',
        filter: {
          name: 'fil'
        },
        order: 'asc',
        start: 1,
        data: {
          k1: {},
          k2: {},
          k3: {},
          k4: {}
        },
        changedOn: '2020-01-01',
        count: 5
      }]);
    });
  });
});

var INITIAL_STATE$5 = _objectSpread2({}, DEFAULT_INITIAL_STATE);

var reducer$5 = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE$5;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case ActionTypes.ATTRIBUTE_RELATIONS.ADD:
      return common.add(state, action);

    case ActionTypes.ATTRIBUTE_RELATIONS.ADD_UNRECEIVED:
      return common.addUnreceivedKeys(state, action);

    case ActionTypes.ATTRIBUTE_RELATIONS.INDEX.ADD:
      return common.addIndex(state, action);

    case ActionTypes.ATTRIBUTE_RELATIONS.USE.INDEXED.REGISTER:
      return common.registerUseIndexed(state, action);

    case ActionTypes.ATTRIBUTE_RELATIONS.USE.INDEXED.CLEAR:
      return common.useIndexedClear(state, action);

    case ActionTypes.ATTRIBUTE_RELATIONS.USE.INDEXED.CLEAR_ALL:
      return common.useIndexedClearAll(state, action);

    default:
      return state;
  }
});

describe('state/AttributeRelations/reducers', function () {
  describe('add', function () {
    var tests = [{
      name: 'no data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_RELATIONS.ADD'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_RELATIONS.ADD',
        data: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_RELATIONS.ADD',
        data: [{
          key: 'k1',
          name: 'first'
        }, {
          key: 'k2',
          name: 'second',
          outdated: true,
          unreceived: true
        }]
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            name: 'first'
          },
          k2: {
            key: 'k2',
            name: 'second'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$5(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addUnreceivedKeys', function () {
    var tests = [{
      name: 'no keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_RELATIONS.ADD_UNRECEIVED'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_RELATIONS.ADD_UNRECEIVED',
        keys: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_RELATIONS.ADD_UNRECEIVED',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            unreceived: true
          },
          k2: {
            key: 'k2',
            unreceived: true
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$5(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addIndex', function () {
    var tests = [{
      name: 'empty data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: 'idx'
        }]
      },
      action: {
        type: 'ATTRIBUTE_RELATIONS.INDEX.ADD',
        filter: 'fil',
        order: 'asc',
        changedOn: 'some time',
        count: 2,
        data: []
      },
      expectedResult: {
        indexes: [{
          changedOn: 'some time',
          count: 2,
          filter: 'fil',
          index: 'idx',
          order: 'asc'
        }]
      }
    }, {
      name: 'new data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: [{
            key: 'k'
          }, {
            key: 'k.1'
          }, {
            key: 'k.2'
          }]
        }]
      },
      action: {
        type: 'ATTRIBUTE_RELATIONS.INDEX.ADD',
        filter: 'fil',
        order: 'asc',
        changedOn: 'some time',
        count: 2,
        start: 1,
        data: [{
          key: 'k2'
        }, {
          key: 'k3'
        }]
      },
      expectedResult: {
        indexes: [{
          changedOn: 'some time',
          count: 2,
          filter: 'fil',
          index: {
            0: {
              key: 'k'
            },
            1: 'k2',
            2: 'k3'
          },
          order: 'asc'
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$5(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('registerUseIndexed', function () {
    var tests = [{
      name: 'existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_RELATIONS.USE.INDEXED.REGISTER',
        componentId: 'compId',
        filterByActive: 'fba',
        filter: 'f',
        order: 'asc',
        start: 4,
        length: 2
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      }
    }, {
      name: 'non existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_RELATIONS.USE.INDEXED.REGISTER',
        componentId: 'compId',
        filterByActive: '_fba',
        filter: 'f',
        order: 'asc',
        start: 4,
        length: 2
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }, {
              filterByActive: '_fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$5(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('useIndexedClear', function () {
    var tests = [{
      name: 'no index',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_RELATIONS.USE.INDEXED.CLEAR',
        componentId: 'some2'
      },
      expectedResult: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      }
    }, {
      name: 'matched index',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_RELATIONS.USE.INDEXED.CLEAR',
        componentId: 'some3'
      },
      expectedResult: {
        inUse: {
          indexes: {
            some: 'some'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$5(test.state, test.action), test.expectedResult);
    });
  });
  it('useIndexedClearAll', function () {
    var tests = [{
      name: 'clear all',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_RELATIONS.USE.INDEXED.CLEAR_ALL'
      },
      expectedResult: {
        inUse: {
          indexes: null
        }
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$5(test.state, test.action), test.expectedResult);
    });
  });
  it('unknown', function () {
    chai.assert.deepStrictEqual(reducer$5({}, {
      type: 'UNKNOWN_ACTION'
    }), {});
  });
});

describe('state/AttributeRelations/selectors', function () {
  it('getIndexed', function () {
    var state = {
      attributeRelations: {
        scopes: {
          activeKey: 'scopesKey'
        },
        byKey: {
          k1: {
            n: 1
          },
          k2: {
            n: 2
          },
          k3: {
            n: 3,
            removed: true
          }
        },
        indexes: [{
          filterByActive: {
            scope: true
          },
          filter: {
            scopeKey: 'scopesKey'
          },
          order: 'asc',
          count: 7,
          index: ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh']
        }]
      }
    };
    var filterByActive = {
      scope: true
    };
    var filter = {
      scopeKey: 'scopesKey'
    };
    var order = 'asc';
    var start = 3;
    var length = 2;
    var expectedResult = [{
      key: 'fourth'
    }, {
      key: 'fifth'
    }];
    chai.assert.deepStrictEqual(selectors.getIndexed(state, filterByActive, filter, order, start, length), expectedResult);
  });
  describe('getAllData', function () {
    var tests = [{
      name: 'null',
      state: {
        attributeRelations: {
          byKey: null
        }
      },
      expectedResult: []
    }, {
      name: 'empty',
      state: {
        attributeRelations: {
          byKey: {}
        }
      },
      expectedResult: []
    }, {
      name: 'some',
      state: {
        attributeRelations: {
          byKey: {
            k1: {
              data: {
                n: 1
              }
            },
            k2: {
              data: {
                n: 2
              }
            }
          }
        }
      },
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors.getAllData(test.state), test.expectedResult);
      });
    });
  });
  it('getSubstate', function () {
    chai.assert.strictEqual(selectors.getSubstate({
      attributeRelations: 'subst'
    }), 'subst');
  });
  it('getFiltered', function () {
    var state = {
      attributeRelations: {
        byKey: {
          k1: {
            data: {
              v: 1,
              active: true
            }
          },
          k2: {
            data: {
              v: 2,
              active: true
            }
          },
          k3: {
            data: {
              v: 3,
              active: false
            }
          }
        }
      }
    };
    var filter = 'active';
    var expectedResult = [{
      v: 1,
      active: true
    }, {
      v: 2,
      active: true
    }];
    chai.assert.deepStrictEqual(selectors.getFiltered(state, filter), expectedResult);
  });
  it('getFilteredRelations', function () {
    var state = {
      attributeRelations: {
        byKey: {
          k1: {
            data: {
              v: 1,
              active: true
            }
          },
          k2: {
            data: {
              v: 2,
              active: true
            }
          },
          k3: {
            data: {
              v: 3,
              active: false
            }
          }
        }
      }
    };
    var filter = {
      active: true
    };
    var expectedResult = [{
      v: 1,
      active: true
    }, {
      v: 2,
      active: true
    }];
    chai.assert.deepStrictEqual(selectors.getFilteredRelations(state, filter), expectedResult);
  });
  it('getFilteredDataGroupedByLayerKey', function () {
    var state = {
      attributeRelations: {
        byKey: {
          k1: {
            data: {
              v: 1,
              active: true
            }
          },
          k2: {
            data: {
              v: 2,
              active: true
            }
          },
          k3: {
            data: {
              v: 3,
              active: false
            }
          }
        }
      }
    };
    var layers = [{
      data: {
        key: 'l1',
        filter: ['v', 1]
      }
    }];
    var expectedResult = {
      l1: [{
        active: true,
        v: 1
      }, {
        active: true,
        v: 2
      }, {
        active: false,
        v: 3
      }]
    };
    chai.assert.deepStrictEqual(selectors.getFilteredDataGroupedByLayerKey(state, layers), expectedResult);
  });
  it('getDataSourceRelationsGroupedByLayerKey', function () {
    var state = {
      attributeRelations: {
        byKey: {
          k1: {
            data: {
              v: 1,
              active: true
            }
          },
          k2: {
            data: {
              v: 2,
              active: true
            }
          },
          k3: {
            data: {
              v: 3,
              active: false
            }
          }
        }
      }
    };
    var layers = [{
      data: {
        key: 'l1',
        filter: ['v', 1]
      }
    }];
    var expectedResult = {
      l1: [{
        active: true,
        v: 1
      }, {
        active: true,
        v: 2
      }, {
        active: false,
        v: 3
      }]
    };
    chai.assert.deepStrictEqual(selectors.getDataSourceRelationsGroupedByLayerKey(state, layers), expectedResult);
  });
  it('getDataSourceKeysGroupedByLayerKey', function () {
    var state = {
      attributeRelations: {
        byKey: {
          k1: {
            data: {
              v: 1,
              active: true,
              attributeDataSourceKey: 'ad1'
            }
          },
          k2: {
            data: {
              v: 2,
              active: true,
              attributeDataSourceKey: 'ad2'
            }
          },
          k3: {
            data: {
              v: 3,
              active: false,
              attributeDataSourceKey: 'ad3'
            }
          }
        }
      }
    };
    var layers = [{
      data: {
        key: 'l1',
        filter: ['v', 1]
      }
    }];
    var expectedResult = {
      l1: ['ad1', 'ad2', 'ad3']
    };
    chai.assert.deepStrictEqual(selectors.getDataSourceKeysGroupedByLayerKey(state, layers), expectedResult);
  });
  it('getDataSourcesFromFilteredRelations', function () {
    var state = {
      attributeRelations: {
        byKey: {
          k1: {
            data: {
              v: 1,
              active: true,
              attributeDataSourceKey: 'ad1',
              fidColumnName: 'fid'
            }
          },
          k2: {
            data: {
              v: 2,
              active: true,
              attributeDataSourceKey: 'ad2',
              fidColumnName: 'fid'
            }
          },
          k3: {
            data: {
              v: 3,
              active: false
            }
          }
        }
      }
    };
    var filter = {
      active: true
    };
    var expectedResult = [{
      attributeDataSourceKey: 'ad1',
      fidColumnName: 'fid'
    }, {
      attributeDataSourceKey: 'ad2',
      fidColumnName: 'fid'
    }];
    chai.assert.deepStrictEqual(selectors.getDataSourcesFromFilteredRelations(state, filter), expectedResult);
  });
  it('getDataSourceKeyFiltered', function () {
    var state = {
      attributeRelations: {
        byKey: {
          k1: {
            data: {
              v: 1,
              active: true,
              dataSourceKey: 'dk'
            }
          },
          k3: {
            data: {
              v: 3,
              active: false
            }
          }
        }
      }
    };
    var filter = 'active';
    var expectedResult = 'dk';
    chai.assert.deepStrictEqual(selectors.getDataSourceKeyFiltered(state, filter), expectedResult);
  });
  it('getFilteredDataSourceKeysWithFidColumn', function () {
    var state = {
      attributeRelations: {
        byKey: {
          k1: {
            data: {
              v: 1,
              active: true,
              attributeDataSourceKey: 'ad1',
              attributeKey: 'ak1',
              periodKey: 'pk1',
              fidColumnName: 'fid'
            }
          }
        }
      }
    };
    var filter = {
      attributeKey: {
        "in": ['ak1']
      }
    };
    var expectedResult = [{
      attributeDataSourceKey: 'ad1',
      attributeKey: 'ak1',
      fidColumnName: 'fid',
      periodKey: 'pk1'
    }];
    chai.assert.deepStrictEqual(selectors.getFilteredDataSourceKeysWithFidColumn(state, filter), expectedResult);
  }); // getFilteredDataSourceKeysWithFidColumnGroupedByLayerKey,
});

describe('state/Attributes/actions', function () {
  var dispatchedActions = [];

  var dispatch = function dispatch(action) {
    dispatchedActions.push(action);
  };

  this.afterEach(function () {
    resetFetch();
    dispatchedActions = [];
  });

  var runFunctionActions = function runFunctionActions(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return new Promise(function (resolve, reject) {
      var promises = [];

      for (var i = 0; i < dispatchedActions.length; i++) {
        var action = dispatchedActions[i];

        if (typeof action === 'function') {
          promises.push(action(dispatch, getState));
          dispatchedActions[i] = null;
        } else if (action instanceof Promise) {
          promises.push(action);
          dispatchedActions[i] = null;
        }
      }

      dispatchedActions = dispatchedActions.filter(function (a) {
        return a !== null;
      });

      if (promises.length > 0) {
        return Promise.all(promises).then(function () {
          return runFunctionActions({
            dispatch: dispatch,
            getState: getState
          });
        }).then(function () {
          return resolve();
        });
      }

      resolve();
    });
  };

  it('create', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributes: {
          indexes: [{
            filter: {
              applicationKey: 'ak'
            }
          }]
        }
      };
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          data: {
            attributes: [{
              key: 'k1',
              data: {
                applicationKey: 'ak'
              }
            }]
          }
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(JSON.parse(options.body));
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: options.body
      });
    });
    return actions$3.create('k1', 'ak')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ATTRIBUTES.ADD',
        filter: undefined,
        data: [{
          key: 'k1',
          data: {
            applicationKey: 'ak'
          }
        }]
      }, {
        type: 'ATTRIBUTES.INDEX.CLEAR_INDEX',
        filter: {
          applicationKey: 'ak'
        },
        order: undefined
      }]);
    });
  });
  it('delete', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributes: {}
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);
        dispatchedActions.push(res);
        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          data: {
            attributes: [{
              key: 'k1'
            }]
          }
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'DELETE'
      });
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(JSON.parse(options.body));
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: options.body
      });
    });
    return actions$3["delete"]({
      key: 'k1'
    })(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      delete dispatchedActions[0]['date'];
      chai.assert.deepStrictEqual(dispatchedActions, [{
        key: 'k1',
        type: 'ATTRIBUTES.MARK_DELETED'
      }, {
        type: 'COMMON.EDITED.REMOVE_PROPERTY_VALUES',
        dataType: 'attributes',
        keys: ['k1']
      }]);
    });
  });
  it('ensureIndexesWithFilterByActive', function () {

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributes: {
          inUse: {
            indexes: [[{
              filterByActive: {
                name: 'fil'
              },
              filter: {
                name: 'fil'
              },
              order: 'asc',
              start: 1,
              length: 5
            }]]
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata/filtered/attributes', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          attributes: {
            k1: {},
            k2: {},
            k3: {},
            k4: {}
          }
        },
        total: 5,
        changes: {
          attributes: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$3.ensureIndexesWithFilterByActive({
      name: 'fil'
    })(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ATTRIBUTES.INDEX.ADD',
        filter: {
          name: 'fil'
        },
        order: 'asc',
        start: 1,
        data: {
          k1: {},
          k2: {},
          k3: {},
          k4: {}
        },
        changedOn: '2020-01-01',
        count: 5
      }]);
    });
  });
  describe('updateStateFromView', function () {
    it('activeKey', function () {
      actions$3.updateStateFromView({
        activeKey: 'ak'
      })(dispatch);
      chai.assert.deepStrictEqual(dispatchedActions, [{
        key: 'ak',
        type: 'ATTRIBUTES.SET_ACTIVE_KEY'
      }]);
    });
    it('activeKeys', function () {
      actions$3.updateStateFromView({
        activeKeys: ['k1', 'k2']
      })(dispatch);
      chai.assert.deepStrictEqual(dispatchedActions, [{
        keys: ['k1', 'k2'],
        type: 'ATTRIBUTES.SET_ACTIVE_KEYS'
      }]);
    });
  });
  it('refreshUses', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributes: {
          inUse: {
            keys: ['k1', 'k2'],
            indexes: [[{
              filter: {
                name: 'fil'
              },
              order: 'asc',
              start: 1,
              length: 3
            }]]
          },
          byKey: {
            k1: {
              key: 'k1'
            },
            k2: {
              key: 'k2'
            }
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata/filtered/attributes', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          attributes: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          attributes: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$3.refreshUses()(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ATTRIBUTES.INDEX.CLEAR_ALL'
      }, {
        filter: {
          name: 'fil'
        },
        order: 'asc',
        count: 2,
        start: 1,
        data: {
          k1: {},
          k2: {}
        },
        changedOn: '2020-01-01',
        type: 'ATTRIBUTES.INDEX.ADD'
      }]);
    });
  });
  it('saveEdited', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributes: {
          byKey: {
            k1: {
              key: 'k1'
            }
          },
          editedByKey: {
            k1: {
              key: 'k1',
              data: {
                prop: 'val'
              }
            }
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          data: {
            attributes: [{
              key: 'k1',
              data: {
                prop: 'val'
              }
            }]
          }
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'PUT'
      });
      var body = {
        data: {
          attributes: [{
            key: 'k1',
            data: {
              prop: 'val'
            }
          }]
        },
        total: 2,
        changes: {
          users: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$3.saveEdited('k1')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ATTRIBUTES.ADD',
        data: [{
          key: 'k1',
          data: {
            prop: 'val'
          }
        }],
        filter: undefined
      }, {
        type: 'ATTRIBUTES.EDITED.REMOVE_PROPERTY',
        key: 'k1',
        property: 'prop'
      }]);
    });
  });
  it('setActiveKey', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributes: {}
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    actions$3.setActiveKey('k1')(dispatch);
    return runFunctionActions({
      dispatch: dispatch,
      getState: getState
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ATTRIBUTES.SET_ACTIVE_KEY',
        key: 'k1'
      }]);
    });
  });
  it('updateEdited', function () {

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributes: {
          byKey: {
            k1: {
              key: 'k1'
            }
          },
          editedByKey: {
            k1: {
              key: 'k1',
              data: {
                prop: 'val'
              }
            }
          }
        }
      };
    };

    actions$3.updateEdited('attributes', 'k1', {
      key: 'k1',
      data: {
        prop: 'val'
      }
    })(dispatch, getState);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'ATTRIBUTES.EDITED.UPDATE',
      data: [{
        key: 'attributes',
        data: {
          k1: {
            key: 'k1',
            data: {
              prop: 'val'
            }
          }
        }
      }]
    }]);
  });
  it('useIndexed', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributes: {
          activeKey: 'k1'
        },
        scopes: {
          activeKey: 'k1'
        },
        periods: {
          activeKey: 'k1'
        },
        places: {
          activeKey: 'k1'
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata/filtered/attributes', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          attributes: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          attributes: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$3.useIndexed({
      name: 'afil'
    }, {
      name: 'fil'
    }, 'asc', 1, 5, 'cid')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        componentId: 'cid',
        filterByActive: {
          name: 'afil'
        },
        filter: {
          name: 'fil'
        },
        order: 'asc',
        start: 1,
        length: 5,
        type: 'ATTRIBUTES.USE.INDEXED.REGISTER'
      }, {
        filter: {
          name: 'fil'
        },
        order: 'asc',
        count: 2,
        start: 1,
        data: {
          k1: {},
          k2: {}
        },
        changedOn: '2020-01-01',
        type: 'ATTRIBUTES.INDEX.ADD'
      }]);
    });
  });
  it('useIndexedClear', function () {
    actions$3.useIndexedClear('cid')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      componentId: 'cid',
      type: 'ATTRIBUTES.USE.INDEXED.CLEAR'
    }]);
  });
  it('useKeys', function () {
    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributes: {
          byKey: {
            k1: {
              key: 'k1'
            },
            k2: {
              key: 'k2'
            }
          }
        }
      };
    };

    return actions$3.useKeys(['k1', 'k2'], 'cid')(dispatch).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        componentId: 'cid',
        keys: ['k1', 'k2'],
        type: 'ATTRIBUTES.USE.KEYS.REGISTER'
      }]);
    });
  });
  it('useKeysClear', function () {
    actions$3.useKeysClear('cid')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      componentId: 'cid',
      type: 'ATTRIBUTES.USE.KEYS.CLEAR'
    }]);
  });
  it('useIndexedBatch', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        scopes: {
          activeKey: 's1'
        },
        periods: {
          activeKey: 'pe1'
        },
        places: {
          activeKey: 'pl1'
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/data/filtered/attributes', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          order: 'asc'
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          attributes: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          attributes: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$3.useIndexedBatch({
      name: 'fil'
    }, {
      name: 'fil'
    }, 'asc', 'cid', 'k1', {})(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ATTRIBUTES.USE.INDEXED_BATCH.REGISTER',
        componentId: 'cid',
        filterByActive: {
          name: 'fil'
        },
        filter: {
          name: 'fil'
        },
        order: 'asc'
      }, {
        type: 'ATTRIBUTES.INDEX.ADD_BATCH',
        filter: {
          name: 'fil'
        },
        order: 'asc',
        data: {
          k1: {},
          k2: {}
        },
        key: 'k1'
      }]);
    });
  });
  it('loadAttributeData', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        scopes: {
          activeKey: 's1'
        },
        periods: {
          activeKey: 'pe1'
        },
        places: {
          activeKey: 'pl1'
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/data/filtered/attributes', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          order: null
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          attributes: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          attributes: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$3.loadAttributeData({
      name: 'fil'
    }, 'cid')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ATTRIBUTES.USE.INDEXED_BATCH.REGISTER',
        componentId: 'cid',
        filter: {
          name: 'fil'
        },
        filterByActive: null,
        order: null
      }, {
        type: 'ATTRIBUTES.INDEX.ADD_BATCH',
        filter: {
          name: 'fil'
        },
        order: null,
        data: {
          k1: {},
          k2: {}
        },
        key: 'attributeDataSourceKey'
      }]);
    });
  });
});

var INITIAL_STATE$6 = _objectSpread2({}, DEFAULT_INITIAL_STATE);

var DEFAULT_ATTRIBUTE_COLLOR = '#008000';

var addAttribute = function addAttribute(state, action) {
  if (action && action.data && action.data.length) {
    action.data.forEach(function (model) {
      //check attribute color
      //if no color, then use default
      if (!model.data.color) {
        model.data.color = DEFAULT_ATTRIBUTE_COLLOR;
      }
    });
  }

  return common.add(state, action);
};

var reducer$6 = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE$6;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case ActionTypes.ATTRIBUTES.ADD:
      return addAttribute(state, action);

    case ActionTypes.ATTRIBUTES.ADD_UNRECEIVED:
      return common.addUnreceivedKeys(state, action);

    case ActionTypes.ATTRIBUTES.DELETE:
      return common.remove(state, action);

    case ActionTypes.ATTRIBUTES.EDITED.REMOVE:
      return common.removeEdited(state, action);

    case ActionTypes.ATTRIBUTES.EDITED.REMOVE_PROPERTY:
      return common.removeEditedProperty(state, action);

    case ActionTypes.ATTRIBUTES.EDITED.UPDATE:
      return common.updateEdited(state, action);

    case ActionTypes.ATTRIBUTES.INDEX.ADD:
      return common.addIndex(state, action);

    case ActionTypes.ATTRIBUTES.INDEX.CLEAR_ALL:
      return common.clearIndexes(state, action);

    case ActionTypes.ATTRIBUTES.INDEX.CLEAR_INDEX:
      return common.clearIndex(state, action);

    case ActionTypes.ATTRIBUTES.MARK_DELETED:
      return common.markDeleted(state, action);

    case ActionTypes.ATTRIBUTES.SET_ACTIVE_KEY:
      return common.setActive(state, action);

    case ActionTypes.ATTRIBUTES.USE.INDEXED.CLEAR:
      return common.useIndexedClear(state, action);

    case ActionTypes.ATTRIBUTES.USE.INDEXED.REGISTER:
      return common.registerUseIndexed(state, action);

    case ActionTypes.ATTRIBUTES.USE.KEYS.REGISTER:
      return common.useKeysRegister(state, action);

    case ActionTypes.ATTRIBUTES.USE.KEYS.CLEAR:
      return common.useKeysClear(state, action);

    case ActionTypes.COMMON.DATA.SET_OUTDATED:
      return common.dataSetOutdated(state, action);

    case ActionTypes.COMMON.DATA.CLEANUP_ON_LOGOUT:
      return common.cleanupOnLogout(state, action);

    case ActionTypes.COMMON.EDITED.REMOVE_PROPERTY_VALUES:
      return common.removeEditedPropertyValues(state, action);

    default:
      return state;
  }
});

describe('state/Attributes/reducers', function () {
  describe('addAttribute', function () {
    var tests = [{
      name: 'no data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTES.ADD'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTES.ADD',
        data: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTES.ADD',
        data: [{
          key: 'k1',
          data: {
            name: 'first'
          }
        }, {
          key: 'k2',
          data: {
            name: 'second',
            color: 'green'
          }
        }]
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            data: {
              name: 'first',
              color: '#008000'
            }
          },
          k2: {
            key: 'k2',
            data: {
              name: 'second',
              color: 'green'
            }
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addUnreceivedKeys', function () {
    var tests = [{
      name: 'no keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTES.ADD_UNRECEIVED'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTES.ADD_UNRECEIVED',
        keys: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTES.ADD_UNRECEIVED',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            unreceived: true
          },
          k2: {
            key: 'k2',
            unreceived: true
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('remove', function () {
    var tests = [{
      name: 'some',
      state: {
        byKey: {
          k1: 1,
          k2: 2,
          k3: 3
        }
      },
      action: {
        type: 'ATTRIBUTES.DELETE',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        byKey: {
          k3: 3
        }
      }
    }, {
      name: 'all',
      state: {
        byKey: {
          k1: 1,
          k2: 2,
          k3: 3
        }
      },
      action: {
        type: 'ATTRIBUTES.DELETE',
        keys: ['k1', 'k2', 'k3']
      },
      expectedResult: {
        byKey: {}
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('removeEdited', function () {
    var tests = [{
      name: 'some',
      state: {
        editedByKey: {
          k1: 1,
          k2: 2,
          k3: 3
        }
      },
      action: {
        type: 'ATTRIBUTES.EDITED.REMOVE',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        editedByKey: {
          k3: 3
        }
      }
    }, {
      name: 'all',
      state: {
        editedByKey: {
          k1: 1,
          k2: 2,
          k3: 3
        }
      },
      action: {
        type: 'ATTRIBUTES.EDITED.REMOVE',
        keys: ['k1', 'k2', 'k3']
      },
      expectedResult: {
        editedByKey: {}
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('removeEditedProperty', function () {
    var tests = [{
      name: 'empty data',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: null
          }
        }
      },
      action: {
        type: 'ATTRIBUTES.EDITED.REMOVE_PROPERTY',
        key: 'k2',
        property: 'p'
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: null
          }
        }
      }
    }, {
      name: 'non existing property',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: {
              p: 2,
              p2: 22
            }
          }
        }
      },
      action: {
        type: 'ATTRIBUTES.EDITED.REMOVE_PROPERTY',
        key: 'k2',
        property: 'p3'
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: {
              p: 2,
              p2: 22
            }
          }
        }
      }
    }, {
      name: 'matched property',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: {
              p: 2,
              p2: 22
            }
          }
        }
      },
      action: {
        type: 'ATTRIBUTES.EDITED.REMOVE_PROPERTY',
        key: 'k2',
        property: 'p'
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: {
              p2: 22
            }
          }
        }
      }
    }, {
      name: 'matched last property',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: {
              p: 2
            }
          }
        }
      },
      action: {
        type: 'ATTRIBUTES.EDITED.REMOVE_PROPERTY',
        key: 'k2',
        property: 'p'
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('updateEdited', function () {
    var tests = [{
      name: 'empty data',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              ep: 2
            }
          },
          k2: {
            data: {
              p: 2
            }
          }
        }
      },
      action: {
        type: 'ATTRIBUTES.EDITED.UPDATE',
        data: []
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              ep: 2
            }
          },
          k2: {
            data: {
              p: 2
            }
          }
        }
      }
    }, {
      name: 'some data',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              ep: 2
            }
          },
          k2: {
            data: {
              p: 2
            }
          }
        }
      },
      action: {
        type: 'ATTRIBUTES.EDITED.UPDATE',
        data: [{
          key: 'k1',
          data: {
            p: 11
          }
        }, {
          key: 'k3',
          data: {
            p: 33
          }
        }]
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 11,
              ep: 2
            }
          },
          k2: {
            data: {
              p: 2
            }
          },
          k3: {
            key: 'k3',
            data: {
              p: 33
            }
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addIndex', function () {
    var tests = [{
      name: 'empty data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: 'idx'
        }]
      },
      action: {
        type: 'ATTRIBUTES.INDEX.ADD',
        filter: 'fil',
        order: 'asc',
        changedOn: 'some time',
        count: 2,
        data: []
      },
      expectedResult: {
        indexes: [{
          changedOn: 'some time',
          count: 2,
          filter: 'fil',
          index: 'idx',
          order: 'asc'
        }]
      }
    }, {
      name: 'new data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: [{
            key: 'k'
          }, {
            key: 'k.1'
          }, {
            key: 'k.2'
          }]
        }]
      },
      action: {
        type: 'ATTRIBUTES.INDEX.ADD',
        filter: 'fil',
        order: 'asc',
        changedOn: 'some time',
        count: 2,
        start: 1,
        data: [{
          key: 'k2'
        }, {
          key: 'k3'
        }]
      },
      expectedResult: {
        indexes: [{
          changedOn: 'some time',
          count: 2,
          filter: 'fil',
          index: {
            0: {
              key: 'k'
            },
            1: 'k2',
            2: 'k3'
          },
          order: 'asc'
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('clearIndexes', function () {
    var tests = [{
      name: 'empty',
      state: {
        indexes: []
      },
      action: {
        type: 'ATTRIBUTES.INDEX.CLEAR_ALL'
      },
      expectedResult: {
        indexes: null
      }
    }, {
      name: 'non empty',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: 5,
          index: ['v1', 'v2'],
          changedOn: 'changed on'
        }]
      },
      action: {
        type: 'ATTRIBUTES.INDEX.CLEAR_ALL'
      },
      expectedResult: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: null,
          index: null,
          changedOn: null,
          outdated: ['v1', 'v2'],
          outdatedCount: 5
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('clearIndex', function () {
    var tests = [{
      name: 'without match',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: 5,
          index: ['v1', 'v2'],
          changedOn: 'changed on'
        }, {
          filter: 'fil',
          order: 'desc',
          count: 7,
          index: ['v2.1', 'v2.2'],
          changedOn: 'changed on2'
        }]
      },
      action: {
        type: 'ATTRIBUTES.INDEX.CLEAR_INDEX',
        filter: 'fil2',
        order: 'asc'
      },
      expectedResult: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: 5,
          index: ['v1', 'v2'],
          changedOn: 'changed on'
        }, {
          filter: 'fil',
          order: 'desc',
          count: 7,
          index: ['v2.1', 'v2.2'],
          changedOn: 'changed on2'
        }]
      }
    }, {
      name: 'with match',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: 5,
          index: ['v1', 'v2'],
          changedOn: 'changed on'
        }, {
          filter: 'fil',
          order: 'desc',
          count: 7,
          index: ['v2.1', 'v2.2'],
          changedOn: 'changed on2'
        }]
      },
      action: {
        type: 'ATTRIBUTES.INDEX.CLEAR_INDEX',
        filter: 'fil',
        order: 'asc'
      },
      expectedResult: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: null,
          index: null,
          changedOn: null,
          outdated: ['v1', 'v2'],
          outdatedCount: 5
        }, {
          filter: 'fil',
          order: 'desc',
          count: 7,
          index: ['v2.1', 'v2.2'],
          changedOn: 'changed on2'
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('markDeleted', function () {
    var tests = [{
      name: 'non matching key',
      state: {
        byKey: {
          nk: {
            v: 1
          },
          nk2: {
            v: 2
          }
        }
      },
      action: {
        type: 'ATTRIBUTES.MARK_DELETED',
        key: 'sk'
      },
      expectedResult: {
        byKey: {
          nk: {
            v: 1
          },
          nk2: {
            v: 2
          }
        }
      }
    }, {
      name: 'matching key',
      state: {
        byKey: {
          sk: {
            v: 0
          },
          nk: {
            v: 1
          },
          nk2: {
            v: 2
          }
        }
      },
      action: {
        type: 'ATTRIBUTES.MARK_DELETED',
        key: 'sk'
      },
      expectedResult: {
        byKey: {
          sk: {
            v: 0,
            removed: true
          },
          nk: {
            v: 1
          },
          nk2: {
            v: 2
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('setActive', function () {
    var tests = [{
      name: 'test',
      state: {
        activeKey: 'k1',
        activeKeys: ['ks1', 'ks2']
      },
      action: {
        type: 'ATTRIBUTES.SET_ACTIVE_KEY',
        key: 'ak'
      },
      expectedResult: {
        activeKey: 'ak',
        activeKeys: null
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('useIndexedClear', function () {
    var tests = [{
      name: 'no index',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {
        type: 'ATTRIBUTES.USE.INDEXED.CLEAR',
        componentId: 'some2'
      },
      expectedResult: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      }
    }, {
      name: 'matched index',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {
        type: 'ATTRIBUTES.USE.INDEXED.CLEAR',
        componentId: 'some3'
      },
      expectedResult: {
        inUse: {
          indexes: {
            some: 'some'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('registerUseIndexed', function () {
    var tests = [{
      name: 'existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      },
      action: {
        type: 'ATTRIBUTES.USE.INDEXED.REGISTER',
        componentId: 'compId',
        filterByActive: 'fba',
        filter: 'f',
        order: 'asc',
        start: 4,
        length: 2
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      }
    }, {
      name: 'non existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      },
      action: {
        type: 'ATTRIBUTES.USE.INDEXED.REGISTER',
        componentId: 'compId',
        filterByActive: '_fba',
        filter: 'f',
        order: 'asc',
        start: 4,
        length: 2
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }, {
              filterByActive: '_fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('useKeysRegister', function () {
    var tests = [{
      name: 'no initial keys',
      state: {
        inUse: {}
      },
      action: {
        type: 'ATTRIBUTES.USE.KEYS.REGISTER',
        componentId: 'comp',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k2']
          }
        }
      }
    }, {
      name: 'with initial keys',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3']
          }
        }
      },
      action: {
        type: 'ATTRIBUTES.USE.KEYS.REGISTER',
        componentId: 'comp',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('useKeysClear', function () {
    var tests = [{
      name: 'non existing',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      },
      action: {
        type: 'ATTRIBUTES.USE.KEYS.CLEAR',
        componentId: 'comp2'
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      }
    }, {
      name: 'single',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2'],
            comp2: ['kc']
          }
        }
      },
      action: {
        type: 'ATTRIBUTES.USE.KEYS.CLEAR',
        componentId: 'comp'
      },
      expectedResult: {
        inUse: {
          keys: {
            comp2: ['kc']
          }
        }
      }
    }, {
      name: 'last',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      },
      action: {
        type: 'ATTRIBUTES.USE.KEYS.CLEAR',
        componentId: 'comp'
      },
      expectedResult: {
        inUse: {
          keys: null
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('dataSetOutdated', function () {
    var tests = [{
      name: 'empty',
      state: {
        byKey: {}
      },
      action: {
        type: 'COMMON.DATA.SET_OUTDATED'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'non empty',
      state: {
        byKey: {
          k1: {
            data: {
              p: 1
            }
          },
          k2: {
            data: {
              p: 2
            }
          }
        }
      },
      action: {
        type: 'COMMON.DATA.SET_OUTDATED'
      },
      expectedResult: {
        byKey: {
          k1: {
            data: {
              p: 1
            },
            outdated: true
          },
          k2: {
            data: {
              p: 2
            },
            outdated: true
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('cleanupOnLogout', function () {
    var tests = [{
      name: 'test',
      state: {
        byKey: {
          k1: {
            data: {
              p: 1
            },
            permissions: {
              guest: {
                get: true
              }
            }
          },
          k2: {
            data: {
              p: 2
            }
          },
          k3: {
            data: {
              p: 3
            },
            permissions: {
              guest: {
                get: true
              }
            }
          }
        }
      },
      action: {
        type: 'COMMON.DATA.CLEANUP_ON_LOGOUT'
      },
      expectedResult: {
        byKey: {
          k1: {
            data: {
              p: 1
            },
            permissions: {
              guest: {
                get: true
              }
            }
          },
          k3: {
            data: {
              p: 3
            },
            permissions: {
              guest: {
                get: true
              }
            }
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('removeEditedPropertyValues', function () {
    var tests = [{
      name: 'updated',
      state: {
        editedByKey: {
          k1: {
            data: {
              name: 'key prop in keys',
              actionKey: 'ak1'
            }
          },
          k2: {
            data: {
              name: 'key prop not in keys',
              actionKey: 'nak2'
            }
          },
          k3: {
            data: {
              name: 'multi key prop in keys',
              actionKeys: ['ak3.1', 'ak3.2']
            }
          },
          k4: {
            data: {
              name: 'multi key prop not in keys',
              actionKeys: ['ak4.1', 'ak4.2']
            }
          }
        }
      },
      action: {
        type: 'COMMON.EDITED.REMOVE_PROPERTY_VALUES',
        dataType: 'actions',
        keys: ['ak1', 'ak3.2']
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              name: 'key prop in keys',
              actionKey: null
            }
          },
          k2: {
            data: {
              name: 'key prop not in keys',
              actionKey: 'nak2'
            }
          },
          k3: {
            data: {
              name: 'multi key prop in keys',
              actionKeys: ['ak3.1']
            }
          },
          k4: {
            data: {
              name: 'multi key prop not in keys',
              actionKeys: ['ak4.1', 'ak4.2']
            }
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$6(test.state, test.action), test.expectedResult);
      });
    });
  });
  it('unknown', function () {
    chai.assert.deepStrictEqual(reducer$6({}, {
      type: 'UNKNOWN_ACTION'
    }), {});
  });
});

describe('state/Attributes/selectors', function () {
  describe('getAttributes', function () {
    var tests = [{
      name: 'null',
      state: {
        attributes: {
          byKey: null
        }
      },
      expectedResult: []
    }, {
      name: 'empty',
      state: {
        attributes: {
          byKey: {}
        }
      },
      expectedResult: []
    }, {
      name: 'some',
      state: {
        attributes: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        }
      },
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$6.getAttributes(test.state), test.expectedResult);
      });
    });
  });
  describe('getActive', function () {
    var createState = function createState(activeKey) {
      return {
        attributes: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          },
          activeKey: activeKey
        }
      };
    };

    it('select active', function () {
      chai.assert.deepStrictEqual(selectors$6.getActive(createState('k1')), {
        n: 1
      });
    });
    it('select inactive', function () {
      chai.assert.isNull(selectors$6.getActive(createState('k3')));
    });
  });
  it('getActiveKey', function () {
    var state = {
      attributes: {
        activeKey: 'k'
      }
    };
    chai.assert.strictEqual(selectors$6.getActiveKey(state), 'k');
  });
  describe('getAllAsObject', function () {
    var tests = [{
      name: 'null',
      state: {
        attributes: {
          byKey: {}
        }
      },
      expectedResult: {}
    }, {
      name: 'empty',
      state: {
        attributes: {
          byKey: {}
        }
      },
      expectedResult: {}
    }, {
      name: 'some',
      state: {
        attributes: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        }
      },
      expectedResult: {
        k1: {
          n: 1
        },
        k2: {
          n: 2
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$6.getAllAsObject(test.state), test.expectedResult);
      });
    });
  });
  describe('getByKey', function () {
    var tests = [{
      name: 'none',
      state: {
        attributes: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: 'k3',
      expectedResult: null
    }, {
      name: 'null key',
      state: {
        attributes: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: null,
      expectedResult: undefined
    }, {
      name: 'some',
      state: {
        attributes: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: 'k1',
      expectedResult: {
        n: 1
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$6.getByKey(test.state, test.key), test.expectedResult);
      });
    });
  });
  describe('getByKeys', function () {
    var tests = [{
      name: 'null keys',
      state: {
        attributes: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: null,
      expectedResult: null
    }, {
      name: 'empty keys',
      state: {
        attributes: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: [],
      expectedResult: null
    }, {
      name: 'none',
      state: {
        attributes: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: ['k5', 'k6'],
      expectedResult: null
    }, {
      name: 'empty',
      state: {
        attributes: {}
      },
      keys: ['k1', 'k2'],
      expectedResult: null
    }, {
      name: 'some',
      state: {
        attributes: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: ['k1', 'k2'],
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$6.getByKeys(test.state, test.keys), test.expectedResult);
      });
    });
  });
  describe('getDataByKey', function () {
    var tests = [{
      name: 'none',
      state: {
        attributes: {
          byKey: {
            k1: {
              n: 1,
              data: 'data'
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: 'k5',
      expectedResult: null
    }, {
      name: 'some',
      state: {
        attributes: {
          byKey: {
            k1: {
              n: 1,
              data: 'data'
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: 'k1',
      expectedResult: 'data'
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.strictEqual(selectors$6.getDataByKey(test.state, test.key), test.expectedResult);
      });
    });
  });
  describe('getDeletePermissionByKey', function () {
    var tests = [{
      name: 'user with access',
      state: {
        attributes: {
          byKey: {
            k1: {
              permissions: {
                activeUser: {
                  "delete": true
                }
              }
            }
          }
        }
      },
      expectedResult: true
    }, {
      name: 'guest with access',
      state: {
        attributes: {
          byKey: {
            k1: {
              permissions: {
                guest: {
                  "delete": true
                }
              }
            }
          }
        }
      },
      expectedResult: true
    }, {
      name: 'no access',
      state: {
        attributes: {}
      },
      expectedResult: false
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.strictEqual(selectors$6.getDeletePermissionByKey(test.state, 'k1'), test.expectedResult);
      });
    });
  });
  describe('getEditedDataByKey', function () {
    var tests = [{
      name: 'none',
      state: {
        attributes: {
          editedByKey: {
            k1: 'val1',
            k2: {
              data: 'datk2'
            }
          }
        }
      },
      key: 'k5',
      expectedResult: null
    }, {
      name: 'no data',
      state: {
        attributes: {
          editedByKey: {
            k1: 'val1',
            k2: {
              data: 'datk2'
            }
          }
        }
      },
      key: 'k1',
      expectedResult: null
    }, {
      name: 'some',
      state: {
        attributes: {
          editedByKey: {
            k1: 'val1',
            k2: {
              data: 'datk2'
            }
          }
        }
      },
      key: 'k2',
      expectedResult: 'datk2'
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.strictEqual(selectors$6.getEditedDataByKey(test.state, test.key), test.expectedResult);
      });
    });
  });
  describe('getUpdatePermissionByKey', function () {
    var tests = [{
      name: 'user with access',
      state: {
        attributes: {
          byKey: {
            k1: {
              permissions: {
                activeUser: {
                  update: true
                }
              }
            }
          }
        }
      },
      expectedResult: true
    }, {
      name: 'guest with access',
      state: {
        attributes: {
          byKey: {
            k1: {
              permissions: {
                guest: {
                  update: true
                }
              }
            }
          }
        }
      },
      expectedResult: true
    }, {
      name: 'no access',
      state: {
        attributes: {}
      },
      expectedResult: false
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.strictEqual(selectors$6.getUpdatePermissionByKey(test.state, 'k1'), test.expectedResult);
      });
    });
  });
  describe('getStateToSave', function () {
    var tests = [{
      name: 'default state',
      state: {
        attributes: {}
      },
      expectedResult: {}
    }, {
      name: 'active key',
      state: {
        attributes: {
          activeKey: 'actv'
        }
      },
      expectedResult: {
        activeKey: 'actv'
      }
    }, {
      name: 'active keys',
      state: {
        attributes: {
          activeKeys: ['k1', 'k2']
        }
      },
      expectedResult: {
        activeKeys: ['k1', 'k2']
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$6.getStateToSave(test.state), test.expectedResult);
      });
    });
  });
  it('getSubstate', function () {
    chai.assert.strictEqual(selectors$6.getSubstate({
      attributes: 'subst'
    }), 'subst');
  });
});

describe('state/AttributeSets/actions', function () {
  var dispatchedActions = [];

  var dispatch = function dispatch(action) {
    dispatchedActions.push(action);
  };

  var clearDispatchedActions = function clearDispatchedActions() {
    dispatchedActions = [];
  };

  afterEach(function () {
    clearDispatchedActions();
  });
  it('setActiveKeys', function () {
    actions$9.setActiveKeys(['k1', 'k2'])(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'ATTRIBUTE_SETS.SET_ACTIVE_KEYS',
      keys: ['k1', 'k2']
    }]);
  });
});

var INITIAL_STATE$7 = _objectSpread2(_objectSpread2({}, DEFAULT_INITIAL_STATE), {}, {
  activeKeys: null
});

var reducer$7 = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE$7;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case ActionTypes.ATTRIBUTE_SETS.ADD:
      return common.add(state, action);

    case ActionTypes.ATTRIBUTE_SETS.ADD_UNRECEIVED:
      return common.addUnreceivedKeys(state, action);

    case ActionTypes.ATTRIBUTE_SETS.SET_ACTIVE_KEYS:
      return common.setActiveMultiple(state, action);

    default:
      return state;
  }
});

describe('state/AttributeSets/reducers', function () {
  describe('add', function () {
    var tests = [{
      name: 'no data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_SETS.ADD'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_SETS.ADD',
        data: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_SETS.ADD',
        data: [{
          key: 'k1',
          name: 'first'
        }, {
          key: 'k2',
          name: 'second',
          outdated: true,
          unreceived: true
        }]
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            name: 'first'
          },
          k2: {
            key: 'k2',
            name: 'second'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$7(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addUnreceivedKeys', function () {
    var tests = [{
      name: 'no keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_SETS.ADD_UNRECEIVED'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_SETS.ADD_UNRECEIVED',
        keys: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_SETS.ADD_UNRECEIVED',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            unreceived: true
          },
          k2: {
            key: 'k2',
            unreceived: true
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$7(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('setActiveMultiple', function () {
    var tests = [{
      name: 'setActiveMultiple',
      state: {
        activeKey: 'k1',
        activeKeys: ['ks1', 'ks2']
      },
      action: {
        type: 'ATTRIBUTE_SETS.SET_ACTIVE_KEYS',
        keys: ['aks1', 'aks2']
      },
      expectedResult: {
        activeKey: null,
        activeKeys: ['aks1', 'aks2']
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$7(test.state, test.action), test.expectedResult);
    });
  });
  it('unknown', function () {
    chai.assert.deepStrictEqual(reducer$7({}, {
      type: 'UNKNOWN_ACTION'
    }), {});
  });
});

describe('state/AttributeSets/selectors', function () {
  describe('getActive', function () {
    var createState = function createState(activeKey) {
      return {
        attributeSets: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          },
          activeKey: activeKey
        }
      };
    };

    it('select active', function () {
      chai.assert.deepStrictEqual(selectors$7.getActive(createState('k1')), {
        n: 1
      });
    });
    it('select inactive', function () {
      chai.assert.isNull(selectors$7.getActive(createState('k3')));
    });
  });
  it('getActiveKeys', function () {
    var state = {
      attributeSets: {
        activeKeys: ['k1', 'k2']
      }
    };
    chai.assert.deepStrictEqual(selectors$7.getActiveKeys(state), ['k1', 'k2']);
  });
  describe('getAttributeSets', function () {
    var tests = [{
      name: 'null',
      state: {
        attributeSets: {
          byKey: null
        }
      },
      expectedResult: []
    }, {
      name: 'empty',
      state: {
        attributeSets: {
          byKey: {}
        }
      },
      expectedResult: []
    }, {
      name: 'some',
      state: {
        attributeSets: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        }
      },
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$7.getAttributeSets(test.state), test.expectedResult);
      });
    });
  });
  describe('getByTopics', function () {
    var tests = [{
      name: 't0',
      state: {
        attributeSets: {
          byKey: {
            k1: {
              n: 1,
              data: {
                topic: 't1'
              }
            },
            k2: {
              n: 2,
              data: {
                topic: 't1'
              }
            },
            k3: {
              n: 3,
              data: {
                topic: 't2'
              }
            }
          }
        }
      },
      topics: ['t0'],
      expectedResult: null
    }, {
      name: 't1',
      state: {
        attributeSets: {
          byKey: {
            k1: {
              n: 1,
              data: {
                topic: 't1'
              }
            },
            k2: {
              n: 2,
              data: {
                topic: 't1'
              }
            },
            k3: {
              n: 3,
              data: {
                topic: 't2'
              }
            }
          }
        }
      },
      topics: ['t1'],
      expectedResult: [{
        n: 1,
        data: {
          topic: 't1'
        }
      }, {
        n: 2,
        data: {
          topic: 't1'
        }
      }]
    }, {
      name: 't2',
      state: {
        attributeSets: {
          byKey: {
            k1: {
              n: 1,
              data: {
                topic: 't1'
              }
            },
            k2: {
              n: 2,
              data: {
                topic: 't1'
              }
            },
            k3: {
              n: 3,
              data: {
                topic: 't2'
              }
            }
          }
        }
      },
      topics: ['t2'],
      expectedResult: [{
        n: 3,
        data: {
          topic: 't2'
        }
      }]
    }, {
      name: 't1, t2',
      state: {
        attributeSets: {
          byKey: {
            k1: {
              n: 1,
              data: {
                topic: 't1'
              }
            },
            k2: {
              n: 2,
              data: {
                topic: 't1'
              }
            },
            k3: {
              n: 3,
              data: {
                topic: 't2'
              }
            }
          }
        }
      },
      topics: ['t1', 't2'],
      expectedResult: [{
        n: 1,
        data: {
          topic: 't1'
        }
      }, {
        n: 2,
        data: {
          topic: 't1'
        }
      }, {
        n: 3,
        data: {
          topic: 't2'
        }
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$7.getByTopics(test.state, test.topics), test.expectedResult);
      });
    });
  });
  describe('getStateToSave', function () {
    var tests = [{
      name: 'default state',
      state: {
        attributeSets: {}
      },
      expectedResult: {}
    }, {
      name: 'active key',
      state: {
        attributeSets: {
          activeKey: 'actv'
        }
      },
      expectedResult: {
        activeKey: 'actv'
      }
    }, {
      name: 'active keys',
      state: {
        attributeSets: {
          activeKeys: ['k1', 'k2']
        }
      },
      expectedResult: {
        activeKeys: ['k1', 'k2']
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$7.getStateToSave(test.state), test.expectedResult);
      });
    });
  });
  describe('getUniqueAttributeKeysForTopics', function () {
    var tests = [{
      name: 'some',
      state: {
        attributeSets: {
          byKey: {
            k1: {
              n: 1,
              data: {
                topic: 't1',
                attributes: ['at1', 'at2']
              }
            },
            k2: {
              n: 2,
              data: {
                topic: 't1',
                attributes: ['at1', 'at3']
              }
            },
            k3: {
              n: 3,
              data: {
                topic: 't2',
                attributes: []
              }
            }
          }
        }
      },
      topics: ['t1', 't2'],
      expectedResult: ['at1', 'at2', 'at3']
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$7.getUniqueAttributeKeysForTopics(test.state, test.topics), test.expectedResult);
      });
    });
  });
});

describe('state/AttributeStatistics/actions', function () {
  var dispatchedActions = [];
  this.afterEach(function () {
    resetFetch();
    dispatchedActions = [];
  });

  var runFunctionActions = function runFunctionActions(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return new Promise(function (resolve, reject) {
      var promises = [];

      for (var i = 0; i < dispatchedActions.length; i++) {
        var action = dispatchedActions[i];

        if (typeof action === 'function') {
          promises.push(action(dispatch, getState));
          dispatchedActions[i] = null;
        } else if (action instanceof Promise) {
          promises.push(action);
          dispatchedActions[i] = null;
        }
      }

      dispatchedActions = dispatchedActions.filter(function (a) {
        return a !== null;
      });

      if (promises.length > 0) {
        return Promise.all(promises).then(function () {
          return runFunctionActions({
            dispatch: dispatch,
            getState: getState
          });
        }).then(function () {
          return resolve();
        });
      }

      resolve();
    });
  };

  it('loadFilteredData', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        scopes: {
          activeKey: 's1'
        },
        periods: {
          activeKey: 'pe1'
        },
        places: {
          activeKey: 'pl1'
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/statistic/filtered/attribute', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          order: null
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          attribute: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          attribute: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$5.loadFilteredData({
      name: 'fil'
    }, 'cid')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'ATTRIBUTE_STATISTICS.USE.INDEXED_BATCH.REGISTER',
        componentId: 'cid',
        filter: {
          name: 'fil'
        },
        filterByActive: null,
        order: null
      }, {
        type: 'ATTRIBUTE_STATISTICS.INDEX.ADD_BATCH',
        filter: {
          name: 'fil'
        },
        order: null,
        data: {
          k1: {},
          k2: {}
        },
        key: 'attributeDataSourceKey'
      }]);
    });
  });
});

var INITIAL_STATE$8 = _objectSpread2({}, DEFAULT_INITIAL_STATE);

var reducer$8 = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE$8;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case ActionTypes.ATTRIBUTE_STATISTICS.ADD:
      return common.add(state, action);

    case ActionTypes.ATTRIBUTE_STATISTICS.ADD_BATCH:
      return common.addBatch(state, action);

    case ActionTypes.ATTRIBUTE_STATISTICS.ADD_UNRECEIVED:
      return common.addUnreceivedKeys(state, action);

    case ActionTypes.ATTRIBUTE_STATISTICS.INDEX.ADD:
      return common.addIndex(state, action);

    case ActionTypes.ATTRIBUTE_STATISTICS.INDEX.ADD_BATCH:
      return common.addBatchIndex(state, action);

    case ActionTypes.ATTRIBUTE_STATISTICS.USE.INDEXED.REGISTER:
      return common.registerUseIndexed(state, action);

    case ActionTypes.ATTRIBUTE_STATISTICS.USE.INDEXED_BATCH.REGISTER:
      return common.registerBatchUseIndexed(state, action);

    case ActionTypes.ATTRIBUTE_DATA_SOURCES.USE.INDEXED.CLEAR:
      return common.useIndexedClear(state, action);

    default:
      return state;
  }
});

describe('state/AttributeStatistics/reducers', function () {
  describe('add', function () {
    var tests = [{
      name: 'no data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_STATISTICS.ADD'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_STATISTICS.ADD',
        data: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_STATISTICS.ADD',
        data: [{
          key: 'k1',
          name: 'first'
        }, {
          key: 'k2',
          name: 'second',
          outdated: true,
          unreceived: true
        }]
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            name: 'first'
          },
          k2: {
            key: 'k2',
            name: 'second'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$8(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addBatch', function () {
    var tests = [{
      name: 'no data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_STATISTICS.ADD_BATCH'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_STATISTICS.ADD_BATCH',
        data: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some data',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_STATISTICS.ADD_BATCH',
        key: 'someKey',
        data: [{
          key: 'k1',
          someKey: 'sk1',
          name: 'first'
        }, {
          key: 'k2',
          someKey: 'sk2',
          name: 'second',
          outdated: true,
          unreceived: true
        }]
      },
      expectedResult: {
        byKey: {
          sk1: {
            key: 'k1',
            someKey: 'sk1',
            name: 'first'
          },
          sk2: {
            key: 'k2',
            someKey: 'sk2',
            name: 'second'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$8(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addUnreceivedKeys', function () {
    var tests = [{
      name: 'no keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_STATISTICS.ADD_UNRECEIVED'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_STATISTICS.ADD_UNRECEIVED',
        keys: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some keys',
      state: {
        byKey: null
      },
      action: {
        type: 'ATTRIBUTE_STATISTICS.ADD_UNRECEIVED',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            unreceived: true
          },
          k2: {
            key: 'k2',
            unreceived: true
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$8(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addIndex', function () {
    var tests = [{
      name: 'empty data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: 'idx'
        }]
      },
      action: {
        type: 'ATTRIBUTE_STATISTICS.INDEX.ADD',
        filter: 'fil',
        order: 'asc',
        changedOn: 'some time',
        count: 2,
        data: []
      },
      expectedResult: {
        indexes: [{
          changedOn: 'some time',
          count: 2,
          filter: 'fil',
          index: 'idx',
          order: 'asc'
        }]
      }
    }, {
      name: 'new data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: [{
            key: 'k'
          }, {
            key: 'k.1'
          }, {
            key: 'k.2'
          }]
        }]
      },
      action: {
        type: 'ATTRIBUTE_STATISTICS.INDEX.ADD',
        filter: 'fil',
        order: 'asc',
        changedOn: 'some time',
        count: 2,
        start: 1,
        data: [{
          key: 'k2'
        }, {
          key: 'k3'
        }]
      },
      expectedResult: {
        indexes: [{
          changedOn: 'some time',
          count: 2,
          filter: 'fil',
          index: {
            0: {
              key: 'k'
            },
            1: 'k2',
            2: 'k3'
          },
          order: 'asc'
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$8(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addBatchIndex', function () {
    var tests = [{
      name: 'empty data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: 'idx'
        }]
      },
      action: {
        type: 'ATTRIBUTE_STATISTICS.INDEX.ADD_BATCH',
        filter: 'fil',
        order: 'asc',
        key: 'someKey',
        data: []
      },
      expectedResult: {
        indexes: [{
          filter: 'fil',
          index: 'idx',
          order: 'asc'
        }]
      }
    }, {
      name: 'new data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: [{
            someKey: 'k'
          }, {
            someKey: 'k.1'
          }, {
            someKey: 'k.2'
          }]
        }]
      },
      action: {
        type: 'ATTRIBUTE_STATISTICS.INDEX.ADD_BATCH',
        filter: 'fil',
        order: 'asc',
        key: 'someKey',
        data: [{
          someKey: 'k2'
        }, {
          someKey: 'k3'
        }]
      },
      expectedResult: {
        indexes: [{
          filter: 'fil',
          index: {
            0: 'k2',
            1: 'k3',
            2: {
              someKey: 'k.2'
            }
          },
          order: 'asc'
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$8(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('registerUseIndexed', function () {
    var tests = [{
      name: 'existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_STATISTICS.USE.INDEXED.REGISTER',
        componentId: 'compId',
        filterByActive: 'fba',
        filter: 'f',
        order: 'asc',
        start: 4,
        length: 2
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      }
    }, {
      name: 'non existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_STATISTICS.USE.INDEXED.REGISTER',
        componentId: 'compId',
        filterByActive: '_fba',
        filter: 'f',
        order: 'asc',
        start: 4,
        length: 2
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }, {
              filterByActive: '_fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$8(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('registerBatchUseIndexed', function () {
    var tests = [{
      name: 'existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc'
            }]
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_STATISTICS.USE.INDEXED_BATCH.REGISTER',
        componentId: 'compId',
        filterByActive: 'fba',
        filter: 'f',
        order: 'asc'
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc'
            }]
          }
        }
      }
    }, {
      name: 'non existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc'
            }]
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_STATISTICS.USE.INDEXED_BATCH.REGISTER',
        componentId: 'compId',
        filterByActive: '_fba',
        filter: 'f',
        order: 'asc'
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc'
            }, {
              filterByActive: '_fba',
              filter: 'f',
              order: 'asc'
            }]
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$8(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('useIndexedClear', function () {
    var tests = [{
      name: 'no index',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_DATA_SOURCES.USE.INDEXED.CLEAR',
        componentId: 'some2'
      },
      expectedResult: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      }
    }, {
      name: 'matched index',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {
        type: 'ATTRIBUTE_DATA_SOURCES.USE.INDEXED.CLEAR',
        componentId: 'some3'
      },
      expectedResult: {
        inUse: {
          indexes: {
            some: 'some'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$8(test.state, test.action), test.expectedResult);
      });
    });
  });
  it('unknown', function () {
    chai.assert.deepStrictEqual(reducer$8({}, {
      type: 'UNKNOWN_ACTION'
    }), {});
  });
});

describe('state/AttributeStatistics/selectors', function () {
  describe('getByKey', function () {
    var tests = [{
      name: 'none',
      state: {
        attributeStatistics: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: 'k3',
      expectedResult: null
    }, {
      name: 'null key',
      state: {
        attributeStatistics: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: null,
      expectedResult: undefined
    }, {
      name: 'some',
      state: {
        attributeStatistics: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: 'k1',
      expectedResult: {
        n: 1
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$8.getByKey(test.state, test.key), test.expectedResult);
      });
    });
  });
  describe('getAllAsObject', function () {
    var tests = [{
      name: 'null',
      state: {
        attributeStatistics: {
          byKey: {}
        }
      },
      expectedResult: {}
    }, {
      name: 'empty',
      state: {
        attributeStatistics: {
          byKey: {}
        }
      },
      expectedResult: {}
    }, {
      name: 'some',
      state: {
        attributeStatistics: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        }
      },
      expectedResult: {
        k1: {
          n: 1
        },
        k2: {
          n: 2
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$8.getAllAsObject(test.state), test.expectedResult);
      });
    });
  });
  describe('getBatchByFilterOrder', function () {
    var tests = [{
      name: 'empty models',
      state: {
        attributeStatistics: {
          byKey: {},
          indexes: [{
            filter: 'fil',
            order: 'desc'
          }, {
            filter: {
              scopeKey: 'scopeK'
            },
            order: 'asc',
            count: 4,
            index: [null, 'k1', 'k2', 'k3']
          }]
        }
      },
      expectedResult: [null, null, null, null]
    }, {
      name: 'empty indexes',
      state: {
        attributeStatistics: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          },
          indexes: []
        }
      },
      expectedResult: null
    }, {
      name: 'some',
      state: {
        attributeStatistics: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          },
          indexes: [{
            filter: 'fil',
            order: 'desc'
          }, {
            filter: {
              scopeKey: 'scopeK'
            },
            order: 'asc',
            count: 4,
            index: [null, 'k1', 'k2', 'k3']
          }]
        }
      },
      expectedResult: [null, {
        n: 1
      }, {
        n: 2
      }, null]
    }];
    var filter = {
      scopeKey: 'scopeK'
    };
    var order = 'asc';
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$8.getBatchByFilterOrder(test.state, filter, order), test.expectedResult);
      });
    });
  });
  it('getSubstate', function () {
    chai.assert.strictEqual(selectors$8.getSubstate({
      attributeStatistics: 'subst'
    }), 'subst');
  });
});

describe('state/Cases/actions', function () {
  var dispatchedActions = [];

  var dispatch = function dispatch(action) {
    dispatchedActions.push(action);
  };

  var clearDispatchedActions = function clearDispatchedActions() {
    dispatchedActions = [];
  };

  var runFunctionActions = function runFunctionActions(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return new Promise(function (resolve, reject) {
      var promises = [];

      for (var i = 0; i < dispatchedActions.length; i++) {
        var action = dispatchedActions[i];

        if (typeof action === 'function') {
          promises.push(action(dispatch, getState));
          dispatchedActions[i] = null;
        } else if (action instanceof Promise) {
          promises.push(action);
          dispatchedActions[i] = null;
        }
      }

      dispatchedActions = dispatchedActions.filter(function (a) {
        return a !== null;
      });

      if (promises.length > 0) {
        return Promise.all(promises).then(function () {
          return runFunctionActions({
            dispatch: dispatch,
            getState: getState
          });
        }).then(function () {
          return resolve();
        });
      }

      resolve();
    });
  };

  afterEach(function () {
    resetFetch();
    clearDispatchedActions();
  });
  it('add', function () {
    actions$a.add('data', 'filter')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'CASES.ADD',
      data: ['data'],
      filter: 'filter'
    }]);
  });
  it('create', function () {

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        cases: {
          indexes: [{
            filter: {
              applicationKey: 'ak'
            }
          }]
        }
      };
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          data: {
            cases: [{
              key: 'k1',
              data: {
                applicationKey: 'ak'
              }
            }]
          }
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(JSON.parse(options.body));
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: options.body
      });
    });
    return actions$a.create('k1', 'ak')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'CASES.ADD',
        filter: undefined,
        data: [{
          key: 'k1',
          data: {
            applicationKey: 'ak'
          }
        }]
      }, {
        type: 'CASES.INDEX.CLEAR_INDEX',
        filter: {
          applicationKey: 'ak'
        },
        order: undefined
      }]);
    });
  });
  it('delete', function () {

    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        cases: {}
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);
        dispatchedActions.push(res);
        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          data: {
            cases: [{
              key: 'k1'
            }]
          }
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'DELETE'
      });
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(JSON.parse(options.body));
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: options.body
      });
    });
    return actions$a["delete"]({
      key: 'k1'
    })(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      delete dispatchedActions[0]['date'];
      chai.assert.deepStrictEqual(dispatchedActions, [{
        key: 'k1',
        type: 'CASES.MARK_DELETED'
      }, {
        type: 'COMMON.EDITED.REMOVE_PROPERTY_VALUES',
        dataType: 'cases',
        keys: ['k1']
      }]);
    });
  });
  it('ensureIndexesWithFilterByActive', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        cases: {
          inUse: {
            indexes: [[{
              filterByActive: {
                name: 'fil'
              },
              filter: {
                name: 'fil'
              },
              order: 'asc',
              start: 1,
              length: 5
            }]]
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata/filtered/cases', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          cases: {
            k1: {},
            k2: {},
            k3: {},
            k4: {}
          }
        },
        total: 5,
        changes: {
          cases: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$a.ensureIndexesWithFilterByActive({
      name: 'fil'
    })(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'CASES.INDEX.ADD',
        filter: {
          name: 'fil'
        },
        order: 'asc',
        start: 1,
        data: {
          k1: {},
          k2: {},
          k3: {},
          k4: {}
        },
        changedOn: '2020-01-01',
        count: 5
      }]);
    });
  });
  it('refreshUses', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        cases: {
          inUse: {
            keys: ['k1', 'k2'],
            indexes: [[{
              filter: {
                name: 'fil'
              },
              order: 'asc',
              start: 1,
              length: 3
            }]]
          },
          byKey: {
            k1: {
              key: 'k1'
            },
            k2: {
              key: 'k2'
            }
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata/filtered/cases', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          cases: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          cases: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$a.refreshUses()(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'CASES.INDEX.CLEAR_ALL'
      }, {
        filter: {
          name: 'fil'
        },
        order: 'asc',
        count: 2,
        start: 1,
        data: {
          k1: {},
          k2: {}
        },
        changedOn: '2020-01-01',
        type: 'CASES.INDEX.ADD'
      }]);
    });
  });
  it('saveEdited', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        cases: {
          byKey: {
            k1: {
              key: 'k1'
            }
          },
          editedByKey: {
            k1: {
              key: 'k1',
              data: {
                prop: 'val'
              }
            }
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          data: {
            cases: [{
              key: 'k1',
              data: {
                prop: 'val'
              }
            }]
          }
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'PUT'
      });
      var body = {
        data: {
          cases: [{
            key: 'k1',
            data: {
              prop: 'val'
            }
          }]
        },
        total: 2,
        changes: {
          cases: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$a.saveEdited('k1')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'CASES.ADD',
        data: [{
          key: 'k1',
          data: {
            prop: 'val'
          }
        }],
        filter: undefined
      }, {
        type: 'CASES.EDITED.REMOVE_PROPERTY',
        key: 'k1',
        property: 'prop'
      }]);
    });
  });
  it('updateEdited', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        cases: {
          byKey: {
            k1: {
              key: 'k1'
            }
          },
          editedByKey: {
            k1: {
              key: 'k1',
              data: {
                prop: 'val'
              }
            }
          }
        }
      };
    };

    actions$a.updateEdited('users', 'k1', {
      key: 'k1',
      data: {
        prop: 'val'
      }
    })(dispatch, getState);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'CASES.EDITED.UPDATE',
      data: [{
        key: 'users',
        data: {
          k1: {
            key: 'k1',
            data: {
              prop: 'val'
            }
          }
        }
      }]
    }]);
  });
  describe('updateStateFromView', function () {
    it('activeKey', function () {
      actions$a.updateStateFromView({
        activeKey: 'ak'
      })(dispatch);
      chai.assert.deepStrictEqual(dispatchedActions, [{
        key: 'ak',
        type: 'CASES.SET_ACTIVE_KEY'
      }]);
    });
    it('activeKeys', function () {
      actions$a.updateStateFromView({
        activeKeys: ['k1', 'k2']
      })(dispatch);
      chai.assert.deepStrictEqual(dispatchedActions, [{
        keys: ['k1', 'k2'],
        type: 'CASES.SET_ACTIVE_KEYS'
      }]);
    });
  });
  it('useIndexed', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        attributes: {
          activeKey: 'k1'
        },
        scopes: {
          activeKey: 'k1'
        },
        periods: {
          activeKey: 'k1'
        },
        places: {
          activeKey: 'k1'
        },
        cases: {}
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/metadata/filtered/cases', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            name: 'fil'
          },
          offset: 0,
          order: 'asc',
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          cases: {
            k1: {},
            k2: {}
          }
        },
        total: 2,
        changes: {
          cases: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    return actions$a.useIndexed({
      name: 'afil'
    }, {
      name: 'fil'
    }, 'asc', 1, 5, 'cid')(dispatch, getState).then(function () {
      return runFunctionActions({
        dispatch: dispatch,
        getState: getState
      });
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        componentId: 'cid',
        filterByActive: {
          name: 'afil'
        },
        filter: {
          name: 'fil'
        },
        order: 'asc',
        start: 1,
        length: 5,
        type: 'CASES.USE.INDEXED.REGISTER'
      }, {
        filter: {
          name: 'fil'
        },
        order: 'asc',
        count: 2,
        start: 1,
        data: {
          k1: {},
          k2: {}
        },
        changedOn: '2020-01-01',
        type: 'CASES.INDEX.ADD'
      }]);
    });
  });
  it('useIndexedClear', function () {
    actions$a.useIndexedClear('cid')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      componentId: 'cid',
      type: 'CASES.USE.INDEXED.CLEAR'
    }]);
  });
  it('useKeysClear', function () {
    actions$a.useKeysClear('cid')(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      componentId: 'cid',
      type: 'CASES.USE.KEYS.CLEAR'
    }]);
  });
  it('setActiveKey', function () {
    var getState = function getState() {
      return {
        cases: {}
      };
    };

    actions$a.setActiveKey('k1', {
      name: 'fil'
    })(dispatch, getState);
    return runFunctionActions({
      dispatch: dispatch,
      getState: getState
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        key: 'k1',
        type: 'CASES.SET_ACTIVE_KEY'
      }]);
    });
  });
  it('setActiveKeys', function () {
    var getState = function getState() {
      return {
        cases: {}
      };
    };

    actions$a.setActiveKeys(['k1', 'k2'], {
      name: 'fil'
    })(dispatch, getState);
    return runFunctionActions({
      dispatch: dispatch,
      getState: getState
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        keys: ['k1', 'k2'],
        type: 'CASES.SET_ACTIVE_KEYS'
      }]);
    });
  });
});

var INITIAL_STATE$9 = _objectSpread2({}, DEFAULT_INITIAL_STATE);

var reducer$9 = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE$9;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case ActionTypes.CASES.ADD:
      return common.add(state, action);

    case ActionTypes.CASES.ADD_UNRECEIVED:
      return common.addUnreceivedKeys(state, action);

    case ActionTypes.CASES.DELETE:
      return common.remove(state, action);

    case ActionTypes.CASES.EDITED.REMOVE:
      return common.removeEdited(state, action);

    case ActionTypes.CASES.EDITED.REMOVE_PROPERTY:
      return common.removeEditedProperty(state, action);

    case ActionTypes.CASES.EDITED.UPDATE:
      return common.updateEdited(state, action);

    case ActionTypes.CASES.INDEX.ADD:
      return common.addIndex(state, action);

    case ActionTypes.CASES.INDEX.CLEAR_ALL:
      return common.clearIndexes(state, action);

    case ActionTypes.CASES.INDEX.CLEAR_INDEX:
      return common.clearIndex(state, action);

    case ActionTypes.CASES.MARK_DELETED:
      return common.markDeleted(state, action);

    case ActionTypes.CASES.SET_ACTIVE_KEY:
      return common.setActive(state, action);

    case ActionTypes.CASES.SET_ACTIVE_KEYS:
      return common.setActiveMultiple(state, action);

    case ActionTypes.CASES.USE.INDEXED.CLEAR:
      return common.useIndexedClear(state, action);

    case ActionTypes.CASES.USE.INDEXED.REGISTER:
      return common.registerUseIndexed(state, action);

    case ActionTypes.CASES.USE.KEYS.REGISTER:
      return common.useKeysRegister(state, action);

    case ActionTypes.CASES.USE.KEYS.CLEAR:
      return common.useKeysClear(state, action);

    case ActionTypes.COMMON.DATA.SET_OUTDATED:
      return common.dataSetOutdated(state, action);

    case ActionTypes.COMMON.DATA.CLEANUP_ON_LOGOUT:
      return common.cleanupOnLogout(state, action);

    default:
      return state;
  }
});

describe('state/Cases/reducers', function () {
  describe('add', function () {
    var tests = [{
      name: 'no data',
      state: {
        byKey: null
      },
      action: {
        type: 'CASES.ADD'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty data',
      state: {
        byKey: null
      },
      action: {
        type: 'CASES.ADD',
        data: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some data',
      state: {
        byKey: null
      },
      action: {
        type: 'CASES.ADD',
        data: [{
          key: 'k1',
          name: 'first'
        }, {
          key: 'k2',
          name: 'second',
          outdated: true,
          unreceived: true
        }]
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            name: 'first'
          },
          k2: {
            key: 'k2',
            name: 'second'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addUnreceivedKeys', function () {
    var tests = [{
      name: 'no keys',
      state: {
        byKey: null
      },
      action: {
        type: 'CASES.ADD_UNRECEIVED'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'empty keys',
      state: {
        byKey: null
      },
      action: {
        type: 'CASES.ADD_UNRECEIVED',
        keys: []
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'some keys',
      state: {
        byKey: null
      },
      action: {
        type: 'CASES.ADD_UNRECEIVED',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        byKey: {
          k1: {
            key: 'k1',
            unreceived: true
          },
          k2: {
            key: 'k2',
            unreceived: true
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('remove', function () {
    var tests = [{
      name: 'some',
      state: {
        byKey: {
          k1: 1,
          k2: 2,
          k3: 3
        }
      },
      action: {
        type: 'CASES.DELETE',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        byKey: {
          k3: 3
        }
      }
    }, {
      name: 'all',
      state: {
        byKey: {
          k1: 1,
          k2: 2,
          k3: 3
        }
      },
      action: {
        type: 'CASES.DELETE',
        keys: ['k1', 'k2', 'k3']
      },
      expectedResult: {
        byKey: {}
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
    });
  });
  describe('removeEdited', function () {
    var tests = [{
      name: 'some',
      state: {
        editedByKey: {
          k1: 1,
          k2: 2,
          k3: 3
        }
      },
      action: {
        type: 'CASES.EDITED.REMOVE',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        editedByKey: {
          k3: 3
        }
      }
    }, {
      name: 'all',
      state: {
        editedByKey: {
          k1: 1,
          k2: 2,
          k3: 3
        }
      },
      action: {
        type: 'CASES.EDITED.REMOVE',
        keys: ['k1', 'k2', 'k3']
      },
      expectedResult: {
        editedByKey: {}
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('removeEditedProperty', function () {
    var tests = [{
      name: 'empty data',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: null
          }
        }
      },
      action: {
        type: 'CASES.EDITED.REMOVE_PROPERTY',
        key: 'k2',
        property: 'p'
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: null
          }
        }
      }
    }, {
      name: 'non existing property',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: {
              p: 2,
              p2: 22
            }
          }
        }
      },
      action: {
        type: 'CASES.EDITED.REMOVE_PROPERTY',
        key: 'k2',
        property: 'p3'
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: {
              p: 2,
              p2: 22
            }
          }
        }
      }
    }, {
      name: 'matched property',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: {
              p: 2,
              p2: 22
            }
          }
        }
      },
      action: {
        type: 'CASES.EDITED.REMOVE_PROPERTY',
        key: 'k2',
        property: 'p'
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: {
              p2: 22
            }
          }
        }
      }
    }, {
      name: 'matched last property',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          },
          k2: {
            data: {
              p: 2
            }
          }
        }
      },
      action: {
        type: 'CASES.EDITED.REMOVE_PROPERTY',
        key: 'k2',
        property: 'p'
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              p2: 12
            }
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('updateEdited', function () {
    var tests = [{
      name: 'empty data',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              ep: 2
            }
          },
          k2: {
            data: {
              p: 2
            }
          }
        }
      },
      action: {
        type: 'CASES.EDITED.UPDATE',
        data: []
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              ep: 2
            }
          },
          k2: {
            data: {
              p: 2
            }
          }
        }
      }
    }, {
      name: 'some data',
      state: {
        editedByKey: {
          k1: {
            data: {
              p: 1,
              ep: 2
            }
          },
          k2: {
            data: {
              p: 2
            }
          }
        }
      },
      action: {
        type: 'CASES.EDITED.UPDATE',
        data: [{
          key: 'k1',
          data: {
            p: 11
          }
        }, {
          key: 'k3',
          data: {
            p: 33
          }
        }]
      },
      expectedResult: {
        editedByKey: {
          k1: {
            data: {
              p: 11,
              ep: 2
            }
          },
          k2: {
            data: {
              p: 2
            }
          },
          k3: {
            key: 'k3',
            data: {
              p: 33
            }
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('addIndex', function () {
    var tests = [{
      name: 'empty data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: 'idx'
        }]
      },
      action: {
        type: 'CASES.INDEX.ADD',
        filter: 'fil',
        order: 'asc',
        changedOn: 'some time',
        count: 2,
        data: []
      },
      expectedResult: {
        indexes: [{
          changedOn: 'some time',
          count: 2,
          filter: 'fil',
          index: 'idx',
          order: 'asc'
        }]
      }
    }, {
      name: 'new data',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          index: [{
            key: 'k'
          }, {
            key: 'k.1'
          }, {
            key: 'k.2'
          }]
        }]
      },
      action: {
        type: 'CASES.INDEX.ADD',
        filter: 'fil',
        order: 'asc',
        changedOn: 'some time',
        count: 2,
        start: 1,
        data: [{
          key: 'k2'
        }, {
          key: 'k3'
        }]
      },
      expectedResult: {
        indexes: [{
          changedOn: 'some time',
          count: 2,
          filter: 'fil',
          index: {
            0: {
              key: 'k'
            },
            1: 'k2',
            2: 'k3'
          },
          order: 'asc'
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('clearIndexes', function () {
    var tests = [{
      name: 'empty',
      state: {
        indexes: []
      },
      action: {
        type: 'CASES.INDEX.CLEAR_ALL'
      },
      expectedResult: {
        indexes: null
      }
    }, {
      name: 'non empty',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: 5,
          index: ['v1', 'v2'],
          changedOn: 'changed on'
        }]
      },
      action: {
        type: 'CASES.INDEX.CLEAR_ALL'
      },
      expectedResult: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: null,
          index: null,
          changedOn: null,
          outdated: ['v1', 'v2'],
          outdatedCount: 5
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('clearIndex', function () {
    var tests = [{
      name: 'without match',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: 5,
          index: ['v1', 'v2'],
          changedOn: 'changed on'
        }, {
          filter: 'fil',
          order: 'desc',
          count: 7,
          index: ['v2.1', 'v2.2'],
          changedOn: 'changed on2'
        }]
      },
      action: {
        type: 'CASES.INDEX.CLEAR_INDEX',
        filter: 'fil2',
        order: 'asc'
      },
      expectedResult: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: 5,
          index: ['v1', 'v2'],
          changedOn: 'changed on'
        }, {
          filter: 'fil',
          order: 'desc',
          count: 7,
          index: ['v2.1', 'v2.2'],
          changedOn: 'changed on2'
        }]
      }
    }, {
      name: 'with match',
      state: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: 5,
          index: ['v1', 'v2'],
          changedOn: 'changed on'
        }, {
          filter: 'fil',
          order: 'desc',
          count: 7,
          index: ['v2.1', 'v2.2'],
          changedOn: 'changed on2'
        }]
      },
      action: {
        type: 'CASES.INDEX.CLEAR_INDEX',
        filter: 'fil',
        order: 'asc'
      },
      expectedResult: {
        indexes: [{
          filter: 'fil',
          order: 'asc',
          count: null,
          index: null,
          changedOn: null,
          outdated: ['v1', 'v2'],
          outdatedCount: 5
        }, {
          filter: 'fil',
          order: 'desc',
          count: 7,
          index: ['v2.1', 'v2.2'],
          changedOn: 'changed on2'
        }]
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('markDeleted', function () {
    var tests = [{
      name: 'non matching key',
      state: {
        byKey: {
          nk: {
            v: 1
          },
          nk2: {
            v: 2
          }
        }
      },
      action: {
        type: 'CASES.MARK_DELETED',
        key: 'sk'
      },
      expectedResult: {
        byKey: {
          nk: {
            v: 1
          },
          nk2: {
            v: 2
          }
        }
      }
    }, {
      name: 'matching key',
      state: {
        byKey: {
          sk: {
            v: 0
          },
          nk: {
            v: 1
          },
          nk2: {
            v: 2
          }
        }
      },
      action: {
        type: 'CASES.MARK_DELETED',
        key: 'sk'
      },
      expectedResult: {
        byKey: {
          sk: {
            v: 0,
            removed: true
          },
          nk: {
            v: 1
          },
          nk2: {
            v: 2
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('setActive', function () {
    var tests = [{
      name: 'test',
      state: {
        activeKey: 'k1',
        activeKeys: ['ks1', 'ks2']
      },
      action: {
        type: 'CASES.SET_ACTIVE_KEY',
        key: 'ak'
      },
      expectedResult: {
        activeKey: 'ak',
        activeKeys: null
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('setActiveMultiple', function () {
    var tests = [{
      name: 'setActiveMultiple',
      state: {
        activeKey: 'k1',
        activeKeys: ['ks1', 'ks2']
      },
      action: {
        type: 'CASES.SET_ACTIVE_KEYS',
        keys: ['aks1', 'aks2']
      },
      expectedResult: {
        activeKey: null,
        activeKeys: ['aks1', 'aks2']
      }
    }];
    tests.forEach(function (test) {
      chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
    });
  });
  describe('useIndexedClear', function () {
    var tests = [{
      name: 'no index',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {
        type: 'CASES.USE.INDEXED.CLEAR',
        componentId: 'some2'
      },
      expectedResult: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      }
    }, {
      name: 'matched index',
      state: {
        inUse: {
          indexes: {
            some: 'some',
            some3: 'some3'
          }
        }
      },
      action: {
        type: 'CASES.USE.INDEXED.CLEAR',
        componentId: 'some3'
      },
      expectedResult: {
        inUse: {
          indexes: {
            some: 'some'
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('registerUseIndexed', function () {
    var tests = [{
      name: 'existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      },
      action: {
        type: 'CASES.USE.INDEXED.REGISTER',
        componentId: 'compId',
        filterByActive: 'fba',
        filter: 'f',
        order: 'asc',
        start: 4,
        length: 2
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      }
    }, {
      name: 'non existing',
      state: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      },
      action: {
        type: 'CASES.USE.INDEXED.REGISTER',
        componentId: 'compId',
        filterByActive: '_fba',
        filter: 'f',
        order: 'asc',
        start: 4,
        length: 2
      },
      expectedResult: {
        inUse: {
          indexes: {
            compId: [{
              filterByActive: 'fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }, {
              filterByActive: '_fba',
              filter: 'f',
              order: 'asc',
              start: 4,
              length: 2
            }]
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('useKeysRegister', function () {
    var tests = [{
      name: 'no initial keys',
      state: {
        inUse: {}
      },
      action: {
        type: 'CASES.USE.KEYS.REGISTER',
        componentId: 'comp',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k2']
          }
        }
      }
    }, {
      name: 'with initial keys',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3']
          }
        }
      },
      action: {
        type: 'CASES.USE.KEYS.REGISTER',
        componentId: 'comp',
        keys: ['k1', 'k2']
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('useKeysClear', function () {
    var tests = [{
      name: 'non existing',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      },
      action: {
        type: 'CASES.USE.KEYS.CLEAR',
        componentId: 'comp2'
      },
      expectedResult: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      }
    }, {
      name: 'single',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2'],
            comp2: ['kc']
          }
        }
      },
      action: {
        type: 'CASES.USE.KEYS.CLEAR',
        componentId: 'comp'
      },
      expectedResult: {
        inUse: {
          keys: {
            comp2: ['kc']
          }
        }
      }
    }, {
      name: 'last',
      state: {
        inUse: {
          keys: {
            comp: ['k1', 'k3', 'k2']
          }
        }
      },
      action: {
        type: 'CASES.USE.KEYS.CLEAR',
        componentId: 'comp'
      },
      expectedResult: {
        inUse: {
          keys: null
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('dataSetOutdated', function () {
    var tests = [{
      name: 'empty',
      state: {
        byKey: {}
      },
      action: {
        type: 'COMMON.DATA.SET_OUTDATED'
      },
      expectedResult: {
        byKey: {}
      }
    }, {
      name: 'non empty',
      state: {
        byKey: {
          k1: {
            data: {
              p: 1
            }
          },
          k2: {
            data: {
              p: 2
            }
          }
        }
      },
      action: {
        type: 'COMMON.DATA.SET_OUTDATED'
      },
      expectedResult: {
        byKey: {
          k1: {
            data: {
              p: 1
            },
            outdated: true
          },
          k2: {
            data: {
              p: 2
            },
            outdated: true
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
      });
    });
  });
  describe('cleanupOnLogout', function () {
    var tests = [{
      name: 'test',
      state: {
        byKey: {
          k1: {
            data: {
              p: 1
            },
            permissions: {
              guest: {
                get: true
              }
            }
          },
          k2: {
            data: {
              p: 2
            }
          },
          k3: {
            data: {
              p: 3
            },
            permissions: {
              guest: {
                get: true
              }
            }
          }
        }
      },
      action: {
        type: 'COMMON.DATA.CLEANUP_ON_LOGOUT'
      },
      expectedResult: {
        byKey: {
          k1: {
            data: {
              p: 1
            },
            permissions: {
              guest: {
                get: true
              }
            }
          },
          k3: {
            data: {
              p: 3
            },
            permissions: {
              guest: {
                get: true
              }
            }
          }
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(reducer$9(test.state, test.action), test.expectedResult);
      });
    });
  });
  it('unknown', function () {
    chai.assert.deepStrictEqual(reducer$9({}, {
      type: 'UNKNOWN_ACTION'
    }), {});
  });
});

describe('state/Cases/selectors', function () {
  describe('getActive', function () {
    var createState = function createState(activeKey) {
      return {
        cases: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          },
          activeKey: activeKey
        }
      };
    };

    it('select active', function () {
      chai.assert.deepStrictEqual(selectors$9.getActive(createState('k1')), {
        n: 1
      });
    });
    it('select inactive', function () {
      chai.assert.isNull(selectors$9.getActive(createState('k3')));
    });
  });
  it('getActiveKey', function () {
    var state = {
      cases: {
        activeKey: 'k'
      }
    };
    chai.assert.strictEqual(selectors$9.getActiveKey(state), 'k');
  });
  it('getActiveKeys', function () {
    var state = {
      cases: {
        activeKeys: ['k1', 'k2']
      }
    };
    chai.assert.deepStrictEqual(selectors$9.getActiveKeys(state), ['k1', 'k2']);
  });
  describe('getActiveModels', function () {
    var tests = [{
      name: 'none with null active keys',
      state: {
        cases: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          },
          activeKeys: null
        }
      },
      expectedResult: null
    }, {
      name: 'none with empty active keys',
      state: {
        cases: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          },
          activeKeys: []
        }
      },
      expectedResult: null
    }, {
      name: 'none with empty models',
      state: {
        cases: {
          byKey: {},
          activeKeys: ['k3']
        }
      },
      expectedResult: null
    }, {
      name: 'none',
      state: {
        cases: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          },
          activeKeys: ['k3']
        }
      },
      expectedResult: null
    }, {
      name: 'one',
      state: {
        cases: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          },
          activeKeys: ['k1', 'k3']
        }
      },
      expectedResult: [{
        n: 1
      }]
    }, {
      name: 'two',
      state: {
        cases: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          },
          activeKeys: ['k1', 'k2', 'k3']
        }
      },
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$9.getActiveModels(test.state), test.expectedResult);
      });
    });
  });
  describe('getAll', function () {
    var tests = [{
      name: 'null',
      state: {
        cases: {
          byKey: null
        }
      },
      expectedResult: []
    }, {
      name: 'empty',
      state: {
        cases: {
          byKey: {}
        }
      },
      expectedResult: []
    }, {
      name: 'some',
      state: {
        cases: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        }
      },
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$9.getAll(test.state), test.expectedResult);
      });
    });
  });
  describe('getAllAsObject', function () {
    var tests = [{
      name: 'null',
      state: {
        cases: {
          byKey: {}
        }
      },
      expectedResult: {}
    }, {
      name: 'empty',
      state: {
        cases: {
          byKey: {}
        }
      },
      expectedResult: {}
    }, {
      name: 'some',
      state: {
        cases: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        }
      },
      expectedResult: {
        k1: {
          n: 1
        },
        k2: {
          n: 2
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$9.getAllAsObject(test.state), test.expectedResult);
      });
    });
  });
  describe('getAllForActiveScope', function () {
    var tests = [{
      name: 'empty models',
      state: {
        cases: {},
        scopes: {
          activeKey: 'scopeK'
        }
      },
      expectedResult: null
    }, {
      name: 'empty indexes',
      state: {
        cases: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          },
          indexes: []
        },
        scopes: {
          activeKey: 'scopeK'
        }
      },
      expectedResult: null
    }, {
      name: 'no active skope key',
      state: {
        cases: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          },
          indexes: [{
            filter: 'fil',
            order: 'desc'
          }, {
            filter: {
              scopeKey: 'scopeK'
            },
            order: 'asc',
            count: 4,
            index: [null, 'k1', 'k2', 'k3']
          }]
        },
        scopes: {}
      },
      expectedResult: null
    }, {
      name: 'some',
      state: {
        cases: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            }
          },
          indexes: [{
            filter: 'fil',
            order: 'desc'
          }, {
            filter: {
              scopeKey: 'scopeK'
            },
            order: 'asc',
            count: 4,
            index: [null, 'k1', 'k2', 'k3']
          }]
        },
        scopes: {
          activeKey: 'scopeK'
        }
      },
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }, {
        key: 'k3'
      }, null]
    }];
    var order = 'asc';
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$9.getAllForActiveScope(test.state, order), test.expectedResult);
      });
    });
  });
  describe('getByKeys', function () {
    var tests = [{
      name: 'null keys',
      state: {
        cases: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: null,
      expectedResult: null
    }, {
      name: 'empty keys',
      state: {
        cases: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: [],
      expectedResult: null
    }, {
      name: 'none',
      state: {
        cases: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: ['k5', 'k6'],
      expectedResult: null
    }, {
      name: 'empty',
      state: {
        cases: {}
      },
      keys: ['k1', 'k2'],
      expectedResult: null
    }, {
      name: 'some',
      state: {
        cases: {
          byKey: {
            k1: {
              n: 1
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3
            }
          }
        }
      },
      keys: ['k1', 'k2'],
      expectedResult: [{
        n: 1
      }, {
        n: 2
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$9.getByKeys(test.state, test.keys), test.expectedResult);
      });
    });
  });
  describe('getDataByKey', function () {
    var tests = [{
      name: 'none',
      state: {
        cases: {
          byKey: {
            k1: {
              n: 1,
              data: 'data'
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: 'k5',
      expectedResult: null
    }, {
      name: 'some',
      state: {
        cases: {
          byKey: {
            k1: {
              n: 1,
              data: 'data'
            },
            k2: {
              n: 2
            }
          }
        }
      },
      key: 'k1',
      expectedResult: 'data'
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.strictEqual(selectors$9.getDataByKey(test.state, test.key), test.expectedResult);
      });
    });
  });
  describe('getDeletePermissionByKey', function () {
    var tests = [{
      name: 'user with access',
      state: {
        cases: {
          byKey: {
            k1: {
              permissions: {
                activeUser: {
                  "delete": true
                }
              }
            }
          }
        }
      },
      expectedResult: true
    }, {
      name: 'guest with access',
      state: {
        cases: {
          byKey: {
            k1: {
              permissions: {
                guest: {
                  "delete": true
                }
              }
            }
          }
        }
      },
      expectedResult: true
    }, {
      name: 'no access',
      state: {
        cases: {}
      },
      expectedResult: false
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.strictEqual(selectors$9.getDeletePermissionByKey(test.state, 'k1'), test.expectedResult);
      });
    });
  });
  describe('getEditedDataByKey', function () {
    var tests = [{
      name: 'none',
      state: {
        cases: {
          editedByKey: {
            k1: 'val1',
            k2: {
              data: 'datk2'
            }
          }
        }
      },
      key: 'k5',
      expectedResult: null
    }, {
      name: 'no data',
      state: {
        cases: {
          editedByKey: {
            k1: 'val1',
            k2: {
              data: 'datk2'
            }
          }
        }
      },
      key: 'k1',
      expectedResult: null
    }, {
      name: 'some',
      state: {
        cases: {
          editedByKey: {
            k1: 'val1',
            k2: {
              data: 'datk2'
            }
          }
        }
      },
      key: 'k2',
      expectedResult: 'datk2'
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.strictEqual(selectors$9.getEditedDataByKey(test.state, test.key), test.expectedResult);
      });
    });
  });
  it('getIndexed', function () {
    var state = {
      cases: {
        scopes: {
          activeKey: 'scopesKey'
        },
        byKey: {
          k1: {
            n: 1
          },
          k2: {
            n: 2
          },
          k3: {
            n: 3,
            removed: true
          }
        },
        indexes: [{
          filterByActive: {
            scope: true
          },
          filter: {
            scopeKey: 'scopesKey'
          },
          order: 'asc',
          count: 7,
          index: ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh']
        }]
      }
    };
    var filterByActive = {
      scope: true
    };
    var filter = {
      scopeKey: 'scopesKey'
    };
    var order = 'asc';
    var start = 3;
    var length = 2;
    var expectedResult = [{
      key: 'fourth'
    }, {
      key: 'fifth'
    }];
    chai.assert.deepStrictEqual(selectors$9.getIndexed(state, filterByActive, filter, order, start, length), expectedResult);
  });
  describe('getUpdatePermissionByKey', function () {
    var tests = [{
      name: 'user with access',
      state: {
        cases: {
          byKey: {
            k1: {
              permissions: {
                activeUser: {
                  update: true
                }
              }
            }
          }
        }
      },
      expectedResult: true
    }, {
      name: 'guest with access',
      state: {
        cases: {
          byKey: {
            k1: {
              permissions: {
                guest: {
                  update: true
                }
              }
            }
          }
        }
      },
      expectedResult: true
    }, {
      name: 'no access',
      state: {
        cases: {}
      },
      expectedResult: false
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.strictEqual(selectors$9.getUpdatePermissionByKey(test.state, 'k1'), test.expectedResult);
      });
    });
  });
  it('getSubstate', function () {
    chai.assert.strictEqual(selectors$9.getSubstate({
      cases: 'subst'
    }), 'subst');
  });
});

describe('state/Charts/actions', function () {
  var dispatchedActions = [];

  var dispatch = function dispatch(action) {
    dispatchedActions.push(action);
  };

  var clearDispatchedActions = function clearDispatchedActions() {
    dispatchedActions = [];
  };

  var runFunctionActions = function runFunctionActions(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return new Promise(function (resolve, reject) {
      var promises = [];

      for (var i = 0; i < dispatchedActions.length; i++) {
        var action = dispatchedActions[i];

        if (typeof action === 'function') {
          promises.push(action(dispatch, getState));
          dispatchedActions[i] = null;
        } else if (action instanceof Promise) {
          promises.push(action);
          dispatchedActions[i] = null;
        }
      }

      dispatchedActions = dispatchedActions.filter(function (a) {
        return a !== null;
      });

      if (promises.length > 0) {
        return Promise.all(promises).then(function () {
          return runFunctionActions({
            dispatch: dispatch,
            getState: getState
          });
        }).then(function () {
          return resolve();
        });
      }

      resolve();
    });
  };

  afterEach(function () {
    resetFetch();
    clearDispatchedActions();
  });
  describe('updateStateFromView', function () {
    var tests = [{
      name: 'no data',
      data: null,
      expectedResult: []
    }, {
      name: 'some data',
      data: {
        k: 'v'
      },
      expectedResult: [{
        type: 'CHARTS.UPDATE',
        data: {
          k: 'v'
        }
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        dispatch(actions$b.updateStateFromView(test.data));
        runFunctionActions({
          dispatch: dispatch,
          getState: function getState() {}
        });
        chai.assert.deepStrictEqual(dispatchedActions, test.expectedResult);
      });
    });
  });
  it('use', function () {
    var getState = function getState() {
      return {
        app: {
          localConfiguration: {
            apiBackendProtocol: 'http',
            apiBackendHost: 'localhost',
            apiBackendPath: ''
          }
        },
        scopes: {
          activeKey: 'sc1'
        },
        periods: {
          activeKey: 'sp1',
          activeKeys: ['sp1']
        },
        attributes: {
          activeKey: 'a1'
        },
        charts: {
          charts: {
            k1: {
              data: {
                scope: 's1',
                periods: ['p1'],
                attributes: ['a1'],
                layerTemplate: 't1'
              }
            }
          }
        },
        attributeRelations: {
          indexes: [{
            filter: {
              scopeKey: 's1',
              periodKey: 'p1',
              attributeKey: 'a1',
              layerTemplateKey: 't1'
            },
            order: null,
            count: 5
          }]
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    setFetch(function (url, options) {
      chai.assert.strictEqual('http://localhost/backend/rest/relations/filtered/attribute', slash__default['default'](url));
      chai.assert.deepStrictEqual(options, {
        body: JSON.stringify({
          filter: {
            scopeKey: 's1',
            periodKey: 'p1',
            attributeKey: 'a1',
            layerTemplateKey: 't1'
          },
          offset: 0,
          order: null,
          limit: 100
        }),
        credentials: 'include',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST'
      });
      var body = {
        data: {
          attribute: {
            k1: {},
            k2: {},
            k3: {},
            k4: {}
          }
        },
        total: 5,
        changes: {
          attribute: '2020-01-01'
        }
      };
      return Promise.resolve({
        ok: true,
        json: function json() {
          return Promise.resolve(body);
        },
        headers: {
          get: function get(name) {
            return {
              'Content-type': 'application/json'
            }[name];
          }
        },
        data: JSON.stringify(body)
      });
    });
    dispatch(actions$b.use('k1', false));
    return runFunctionActions({
      dispatch: dispatch,
      getState: getState
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        componentId: 'chart-k1',
        filter: {
          attributeKey: 'a1',
          layerTemplateKey: 't1',
          periodKey: 'p1',
          scopeKey: 's1'
        },
        filterByActive: {},
        length: 1000,
        order: null,
        start: 1,
        type: 'ATTRIBUTE_RELATIONS.USE.INDEXED.REGISTER'
      }]);
    });
  });
  it('useClear', function () {
    dispatch(actions$b.useClear('ck'));
    return runFunctionActions({
      dispatch: dispatch,
      getState: function getState() {
        return {};
      }
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        componentId: 'chart_ck',
        type: 'ATTRIBUTE_RELATIONS.USE.INDEXED.CLEAR'
      }]);
    });
  });
  it('setInitial', function () {
    actions$b.setInitial()(dispatch);
    chai.assert.deepStrictEqual(dispatchedActions, [{
      type: 'CHARTS.SET_INITIAL'
    }]);
  });
});

var INITIAL_STATE$a = {
  charts: {},
  sets: {}
};

function setInitial$2() {
  return _objectSpread2({}, INITIAL_STATE$a);
}

function update$2(state, action) {
  return _objectSpread2(_objectSpread2({}, state), action.data);
}

var reducer$a = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE$a;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case ActionTypes.CHARTS.UPDATE:
      return update$2(state, action);

    case ActionTypes.CHARTS.SET_INITIAL:
      return setInitial$2();

    default:
      return state;
  }
});

describe('state/Charts/reducers', function () {
  it('update', function () {
    chai.assert.deepStrictEqual(reducer$a({
      charts: {},
      sets: {}
    }, {
      type: 'CHARTS.UPDATE',
      data: {
        "new": true
      }
    }), {
      charts: {},
      sets: {},
      "new": true
    });
  });
  it('setInitial', function () {
    chai.assert.deepStrictEqual(reducer$a({}, {
      type: 'CHARTS.SET_INITIAL'
    }), {
      charts: {},
      sets: {}
    });
  });
  it('unknown', function () {
    chai.assert.deepStrictEqual(reducer$a({}, {
      type: 'UNKNOWN_ACTION'
    }), {});
  });
});

describe('state/Charts/selectors', function () {
  describe('getChartConfiguration', function () {
    var tests = [{
      name: 'with interesting properties (single value)',
      state: {
        scopes: {
          activeKey: 'sc1'
        },
        periods: {
          activeKey: 'sp1',
          activeKeys: ['sp1']
        },
        attributes: {
          activeKey: 'a1'
        },
        charts: {
          charts: {
            k1: {
              data: {
                scope: 's1',
                periods: ['p1'],
                attributes: ['a1'],
                layerTemplate: 't1'
              }
            }
          }
        }
      },
      key: 'k1',
      useActiveMetadataKeys: false,
      expectedResult: {
        data: {
          attributes: ['a1'],
          layerTemplate: 't1',
          periods: ['p1'],
          scope: 's1'
        },
        filter: {
          attributeKey: 'a1',
          layerTemplateKey: 't1',
          periodKey: 'p1',
          scopeKey: 's1'
        },
        filterByActive: {},
        mergedFilter: {
          attributeKey: 'a1',
          layerTemplateKey: 't1',
          periodKey: 'p1',
          scopeKey: 's1'
        }
      }
    }, {
      name: 'with interesting properties (multi value)',
      state: {
        scopes: {
          activeKey: 'sc1'
        },
        periods: {
          activeKey: 'sp1',
          activeKeys: ['sp1']
        },
        attributes: {
          activeKey: 'a1'
        },
        charts: {
          charts: {
            k1: {
              data: {
                scope: 's1',
                periods: ['p1', 'p2'],
                attributes: ['a1', 'a2'],
                layerTemplate: 't1'
              }
            }
          }
        }
      },
      key: 'k1',
      useActiveMetadataKeys: false,
      expectedResult: {
        data: {
          attributes: ['a1', 'a2'],
          layerTemplate: 't1',
          periods: ['p1', 'p2'],
          scope: 's1'
        },
        filter: {
          attributeKey: {
            "in": ['a1', 'a2']
          },
          layerTemplateKey: 't1',
          periodKey: {
            "in": ['p1', 'p2']
          },
          scopeKey: 's1'
        },
        filterByActive: {},
        mergedFilter: {
          attributeKey: {
            "in": ['a1', 'a2']
          },
          layerTemplateKey: 't1',
          periodKey: {
            "in": ['p1', 'p2']
          },
          scopeKey: 's1'
        }
      }
    }, {
      name: 'without interesting properties (single value)',
      state: {
        scopes: {
          activeKey: 'sc1'
        },
        periods: {
          activeKey: 'sp1',
          activeKeys: ['sp1']
        },
        attributes: {
          activeKey: 'a1'
        },
        charts: {
          charts: {
            k1: {
              data: {}
            }
          }
        }
      },
      key: 'k1',
      useActiveMetadataKeys: {
        scope: true,
        period: true,
        attribute: true
      },
      expectedResult: {
        data: {},
        filter: {},
        filterByActive: {
          attribute: true,
          period: true,
          scope: true
        },
        mergedFilter: {
          attributeKey: 'a1',
          periodKey: 'sp1',
          scopeKey: 'sc1'
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$a.getChartConfiguration(test.state, test.key, test.useActiveMetadataKeys), test.expectedResult);
      });
    });
  });
  describe('getChartsBySetKeyAsObject', function () {
    var tests = [{
      name: 'some',
      state: {
        charts: {
          charts: {
            c1: {
              key: 'c1'
            },
            c2: {
              key: 'c2'
            },
            c3: {
              key: 'c3'
            }
          },
          sets: {
            s1: {
              charts: ['c1', 'c3']
            }
          }
        }
      },
      key: 's1',
      expectedResult: {
        c1: {
          key: 'c1'
        },
        c3: {
          key: 'c3'
        }
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$a.getChartsBySetKeyAsObject(test.state, test.key), test.expectedResult);
      });
    });
  });
  describe('getDataForChart', function () {
    var tests = [{
      name: 'some',
      state: {
        attributeData: {
          byKey: {
            ad1: {
              n: 1,
              attributeData: {
                features: [{
                  properties: {
                    fid: 'f1'
                  }
                }]
              }
            },
            ad2: {
              n: 2
            },
            ad3: {
              n: 3,
              removed: true
            }
          }
        },
        attributeRelations: {
          byKey: {
            k1: {
              data: {
                v: 1,
                active: true,
                attributeDataSourceKey: 'ad1',
                fidColumnName: 'fid'
              }
            },
            k2: {
              data: {
                v: 2,
                active: true,
                attributeDataSourceKey: 'ad2',
                fidColumnName: 'fid'
              }
            },
            k3: {
              data: {
                v: 3,
                active: false
              }
            }
          }
        },
        filter: ['v', 1]
      },
      expectedResult: [{
        key: 'f1',
        data: {
          name: 'f1',
          values: []
        }
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$a.getDataForChart(test.state, 'filter', 'chartKey'), test.expectedResult);
      });
    });
  });
  describe('getNamesForChart', function () {
    var tests = [{
      name: 'some',
      state: {
        attributeData: {
          byKey: {
            k1: {
              n: 1,
              attributeData: {
                features: [{
                  properties: {
                    fid: 1,
                    p: 'v'
                  }
                }]
              }
            },
            k2: {
              n: 2
            },
            k3: {
              n: 3,
              removed: true
            }
          }
        },
        attributeRelations: {
          byKey: {
            r1: {
              data: {
                v: 1,
                attributeDataSourceKey: 'k1',
                fidColumnName: 'fid'
              }
            }
          }
        }
      },
      expectedResult: [{
        key: 1,
        data: {
          name: 'v'
        }
      }]
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$a.getNamesForChart(test.state, 'filter', 'ck'), test.expectedResult);
      });
    });
  });
  describe('getSetByKey', function () {
    var tests = [{
      name: 'some',
      state: {
        charts: {
          sets: {
            s1: {
              key: 's1'
            }
          }
        }
      },
      key: 's1',
      expectedResult: {
        key: 's1'
      }
    }];
    tests.forEach(function (test) {
      it(test.name, function () {
        chai.assert.deepStrictEqual(selectors$a.getSetByKey(test.state, test.key), test.expectedResult);
      });
    });
  });
});

describe('state/Components/actions', function () {
  var dispatchedActions = [];

  var dispatch = function dispatch(action) {
    dispatchedActions.push(action);
  };

  var clearDispatchedActions = function clearDispatchedActions() {
    dispatchedActions = [];
  };

  var runFunctionActions = function runFunctionActions(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return new Promise(function (resolve, reject) {
      var promises = [];

      for (var i = 0; i < dispatchedActions.length; i++) {
        var action = dispatchedActions[i];

        if (typeof action === 'function') {
          promises.push(action(dispatch, getState));
          dispatchedActions[i] = null;
        } else if (action instanceof Promise) {
          promises.push(action);
          dispatchedActions[i] = null;
        }
      }

      dispatchedActions = dispatchedActions.filter(function (a) {
        return a !== null;
      });

      if (promises.length > 0) {
        return Promise.all(promises).then(function () {
          return runFunctionActions({
            dispatch: dispatch,
            getState: getState
          });
        }).then(function () {
          return resolve();
        });
      }

      resolve();
    });
  };

  afterEach(function () {
    clearDispatchedActions();
  });
  it('update', function () {
    dispatch(actions$c.update('cmp', {
      k: 'v'
    }));
    return runFunctionActions({
      dispatch: dispatch,
      getState: function getState() {
        return {};
      }
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        component: 'cmp',
        type: 'COMPONENTS.UPDATE',
        update: {
          k: 'v'
        }
      }]);
    });
  });
  it('updateStateFromView', function () {
    dispatch(actions$c.updateStateFromView({
      cmp: {
        k: 'v'
      }
    }));
    return runFunctionActions({
      dispatch: dispatch,
      getState: function getState() {
        return {};
      }
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        component: 'cmp',
        type: 'COMPONENTS.UPDATE',
        update: {
          k: 'v'
        }
      }]);
    });
  });
  it('set', function () {
    dispatch(actions$c.set('cmp', 'k', 'v'));
    return runFunctionActions({
      dispatch: dispatch,
      getState: function getState() {
        return {};
      }
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'COMPONENTS.SET',
        component: 'cmp',
        path: 'k',
        value: 'v'
      }]);
    });
  });
});

var INITIAL_STATE$b = {};

function update$3(state, action) {
  return _objectSpread2(_objectSpread2({}, state), {}, _defineProperty({}, action.component, state[action.component] ? _objectSpread2(_objectSpread2({}, state[action.component]), action.update) : action.update));
}

function set(state, action) {
  var path = action.path.split('.');
  return _objectSpread2(_objectSpread2({}, state), {}, _defineProperty({}, action.component, setHelper$1(state[action.component], path, action.value)));
}

function setHelper$1(state, path, value) {
  var remainingPath = _toConsumableArray(path);

  var currentKey = remainingPath.shift();

  if (remainingPath.length) {
    return _objectSpread2(_objectSpread2({}, state), {}, _defineProperty({}, currentKey, setHelper$1(state[currentKey], remainingPath, value)));
  } else {
    return _objectSpread2(_objectSpread2({}, state), {}, _defineProperty({}, currentKey, value));
  }
}

var reducer$b = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE$b;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case ActionTypes.COMPONENTS.UPDATE:
      return update$3(state, action);

    case ActionTypes.COMPONENTS.SET:
      return set(state, action);

    default:
      return state;
  }
});

describe('state/Components/reducers', function () {
  it('update', function () {
    chai.assert.deepStrictEqual(reducer$b({}, {
      type: 'COMPONENTS.UPDATE',
      component: 'cmp',
      update: {
        k: 'v'
      }
    }), {
      cmp: {
        k: 'v'
      }
    });
  });
  it('set', function () {
    chai.assert.deepStrictEqual(reducer$b({
      cmp: {
        k: {
          v: 'old_v'
        }
      }
    }, {
      type: 'COMPONENTS.SET',
      component: 'cmp',
      path: 'k.v',
      value: 'v'
    }), {
      cmp: {
        k: {
          v: 'v'
        }
      }
    });
  });
  it('unknown', function () {
    chai.assert.deepStrictEqual(reducer$b({}, {
      type: 'UNKNOWN_ACTION'
    }), {});
  });
});

describe('state/Components/selectors', function () {
  it('get', function () {
    chai.assert.deepStrictEqual(selectors$b.get({
      components: {
        k1: {
          key: 'k1',
          data: {
            k: 'v1'
          }
        }
      }
    }, 'k1', 'data'), {
      k: 'v1'
    });
  });
  it('getDataByComponentKey', function () {
    chai.assert.deepStrictEqual(selectors$b.getDataByComponentKey({
      components: {
        k1: {
          key: 'k1',
          data: {
            k: 'v1'
          }
        }
      }
    }, 'k1'), {
      key: 'k1',
      data: {
        k: 'v1'
      }
    });
  });
  it('getStateToSave', function () {
    chai.assert.deepStrictEqual(selectors$b.getStateToSave({
      components: {
        k1: {
          key: 'k1',
          data: {
            k: 'v1'
          }
        }
      }
    }, 'k1'), {
      k1: {
        key: 'k1',
        data: {
          k: 'v1'
        }
      }
    });
  });
});

describe('state/Data/SpatialData/actions', function () {
  var dispatchedActions = [];

  var clearDispatchedActions = function clearDispatchedActions() {
    dispatchedActions = [];
  };

  var runFunctionActions = function runFunctionActions(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return new Promise(function (resolve, reject) {
      var promises = [];

      for (var i = 0; i < dispatchedActions.length; i++) {
        var action = dispatchedActions[i];

        if (typeof action === 'function') {
          promises.push(action(dispatch, getState));
          dispatchedActions[i] = null;
        } else if (action instanceof Promise) {
          promises.push(action);
          dispatchedActions[i] = null;
        } else if (Array.isArray(action)) {
          dispatchedActions = [].concat(_toConsumableArray(dispatchedActions), _toConsumableArray(action));
          dispatchedActions[i] = null;
        }
      }

      dispatchedActions = dispatchedActions.filter(function (a) {
        return a != null;
      });

      if (promises.length > 0) {
        return Promise.all(promises).then(function () {
          return runFunctionActions({
            dispatch: dispatch,
            getState: getState
          });
        }).then(function () {
          return resolve();
        });
      }

      resolve();
    });
  };

  afterEach(function () {
    clearDispatchedActions();
  });
  it('Dispatch empty data if recieved data are empty', function () {
    var getState = function getState() {
      return {
        data: {
          spatialData: {
            byDataSourceKey: null
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    var result = [];
    var filter = {};
    var order = null;
    var changes = null;
    dispatch(actions$f.receiveIndexed(result, filter, order, changes));
    var expectedResult = [{
      "changedOn": null,
      "dataByDataSourceKey": {},
      "indexData": [{}],
      "level": undefined,
      "order": null,
      "spatialFilter": {},
      "type": "DATA.SPATIAL_DATA.ADD_WITH_INDEX"
    }]; //empty array because of empty results

    return runFunctionActions({
      dispatch: dispatch,
      getState: getState
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, expectedResult);
    });
  });
  it('receiveIndexed and addDataWithIndex', function () {
    var getState = function getState() {
      return {
        data: {
          spatialData: {
            byDataSourceKey: {}
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    var results = {
      key1: {
        spatialIndex: {
          2: {
            '0,0': [1]
          }
        },
        data: {
          citizens: 1
        }
      },
      key2: {
        spatialIndex: {
          2: {
            '0,1': [2]
          }
        },
        data: {
          citizens: 2
        }
      }
    };
    var filter = {};
    var order = null;
    var changes = null;
    dispatch(actions$f.receiveIndexed(results, filter, order, changes));
    return runFunctionActions({
      dispatch: dispatch,
      getState: getState
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        "dataByDataSourceKey": {
          "key1": {
            "citizens": 1
          },
          "key2": {
            "citizens": 2
          }
        },
        "level": "2",
        "type": "DATA.SPATIAL_DATA.ADD_WITH_INDEX",
        "order": null,
        "spatialFilter": {},
        "changedOn": null,
        "indexData": [{
          "2": {
            "0,0": {
              "key1": [1]
            },
            "0,1": {
              "key2": [2]
            }
          }
        }]
      }]);
    });
  });
  it('receiveIndexed add new data and update current data', function () {
    var getState = function getState() {
      return {
        data: {
          spatialData: {
            byDataSourceKey: {
              "key1": {
                citizens: 4
              }
            }
          }
        }
      };
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    var results = {
      key1: {
        spatialIndex: {
          2: {
            '0,0': [1]
          }
        },
        data: {
          citizens: 1
        }
      },
      key2: {
        spatialIndex: {
          2: {
            '0,1': [2]
          }
        },
        data: {
          citizens: 2
        }
      }
    };
    var filter = {};
    var order = null;
    var changes = null;
    dispatch(actions$f.receiveIndexed(results, filter, order, changes));
    return runFunctionActions({
      dispatch: dispatch,
      getState: getState
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        "changedOn": null,
        "dataByDataSourceKey": {
          "key1": {
            "citizens": 1
          },
          "key2": {
            "citizens": 2
          }
        },
        "level": "2",
        "order": null,
        "type": "DATA.SPATIAL_DATA.ADD_WITH_INDEX",
        "spatialFilter": {},
        "indexData": [{
          "2": {
            "0,0": {
              "key1": [1]
            },
            "0,1": {
              "key2": [2]
            }
          }
        }]
      }]);
    });
  });
});

var INITIAL_STATE$c = _objectSpread2(_objectSpread2({}, DEFAULT_INITIAL_STATE), {}, {
  byDataSourceKey: {}
});

var getEmptyFeature = function getEmptyFeature() {
  return {
    geometries: {}
  };
};
/**
 * Add spatial data
 * @param state {Object}
 * @param action {Object}
 * @param action.key {String} Data source key
 * @param action.level {number} Zoom level
 * @param action.data {Object} Features as object
 * @return {Object}
 */


var add$j = function add(state, action) {
  var dataSourceKey = action.key;
  var updatedDataForDataSourceKey = getUpdatedDataForDataSourceKey(state, dataSourceKey, action.data, action.level);
  return _objectSpread2(_objectSpread2({}, state), {}, {
    byDataSourceKey: _objectSpread2(_objectSpread2({}, state.byDataSourceKey), {}, _defineProperty({}, dataSourceKey, updatedDataForDataSourceKey))
  });
};

var addWithIndex = function addWithIndex(state, action) {
  var updatedByDataSourceKey = getUpdatedByDataSourceKey(state, action.dataByDataSourceKey, action.level);
  var updatedIndexes = commonHelpers.getUpdatedIndexes(state, action.spatialFilter, action.order, action.indexData, action.changedOn);
  return _objectSpread2(_objectSpread2({}, state), {}, {
    byDataSourceKey: updatedByDataSourceKey,
    indexes: updatedIndexes
  });
};

var addIndex$4 = function addIndex(state, action) {
  var updatedIndexes = commonHelpers.getUpdatedIndexes(state, action.spatialFilter, action.order, action.indexData, action.changedOn);
  return _objectSpread2(_objectSpread2({}, state), {}, {
    indexes: updatedIndexes
  });
};
/**
 * Remove index that fit to filter and order from state.
 * @param {Object} state 
 * @param {Object} action 
 * @return {Object}
 */


var removeIndex$1 = function removeIndex(state, action) {
  var updatedIndexes = commonHelpers.removeIndex(state.indexes, action.filter, action.order);
  return _objectSpread2(_objectSpread2({}, state), {}, {
    indexes: updatedIndexes
  });
}; // helpers

/**
 * @param state {Object}
 * @param dataSourceKey {string} uuid
 * @param featuresAsObject {Object}
 * @param level {number}
 * @return {Object}
 */


function getUpdatedDataForDataSourceKey(state, dataSourceKey, featuresAsObject, level) {
  // TODO what about features adding without level?
  var dataFeaturesKeys = Object.keys(featuresAsObject);
  var updatedData = state.byDataSourceKey[dataSourceKey] ? _objectSpread2({}, state.byDataSourceKey[dataSourceKey]) : {};
  dataFeaturesKeys.forEach(function (featureKey) {
    if (updatedData.hasOwnProperty(featureKey)) {
      //add just level geometry to existing feature
      updatedData[featureKey].geometries[level] = featuresAsObject[featureKey];
    } else {
      //create new feature with geometry and add to state
      var newFeature = getEmptyFeature();
      newFeature.geometries[level] = featuresAsObject[featureKey];
      updatedData = _objectSpread2(_objectSpread2({}, updatedData), {}, _defineProperty({}, featureKey, _objectSpread2({}, newFeature)));
    }
  });
  return updatedData;
}

function getUpdatedByDataSourceKey(state, dataByDataSourceKey, level) {
  var updatedData = _objectSpread2({}, state.byDataSourceKey);

  _forIn__default['default'](dataByDataSourceKey, function (data, dataSourceKey) {
    if (!updatedData.hasOwnProperty(dataSourceKey)) {
      updatedData[dataSourceKey] = {};
    }

    _forIn__default['default'](data, function (geometry, featureKey) {
      var existingFeature = updatedData[dataSourceKey].hasOwnProperty(featureKey);

      if (existingFeature) {
        //add just level geometry to existing feature
        updatedData[dataSourceKey][featureKey].geometries[level] = geometry;
      } else {
        //create new feature with geometry and add to state
        var newFeature = getEmptyFeature();
        newFeature.geometries[level] = geometry;
        updatedData[dataSourceKey] = _objectSpread2(_objectSpread2({}, updatedData[dataSourceKey]), {}, _defineProperty({}, featureKey, newFeature));
      }
    });
  });

  return updatedData;
}

var reducer$c = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE$c;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case ActionTypes.DATA.SPATIAL_DATA.ADD:
      return add$j(state, action);

    case ActionTypes.DATA.SPATIAL_DATA.ADD_WITH_INDEX:
      return addWithIndex(state, action);

    case ActionTypes.DATA.SPATIAL_DATA.INDEX.ADD:
      return addIndex$4(state, action);

    case ActionTypes.DATA.SPATIAL_DATA.INDEX.REMOVE:
      return removeIndex$1(state, action);

    default:
      return state;
  }
});

describe('state/Data/SpatialData', function () {
  it('add new data', function () {
    chai.assert.deepStrictEqual(reducer$c({
      byDataSourceKey: {
        key2: {
          featureKey2: {
            geometries: {
              '2': {
                geom: ['geom']
              }
            }
          }
        }
      }
    }, {
      type: 'DATA.SPATIAL_DATA.ADD',
      key: 'key1',
      data: {
        "featureKey1": {
          geom: ['geom']
        }
      },
      level: 2
    }), {
      byDataSourceKey: {
        key1: {
          featureKey1: {
            geometries: {
              '2': {
                geom: ['geom']
              }
            }
          }
        },
        key2: {
          featureKey2: {
            geometries: {
              '2': {
                geom: ['geom']
              }
            }
          }
        }
      }
    });
  });
  it('add data on key that exists', function () {
    chai.assert.deepStrictEqual(reducer$c({
      byDataSourceKey: {
        ds1: {
          fk1: {
            geometries: {
              '2': {
                geom: ['geom']
              }
            }
          }
        }
      }
    }, {
      type: 'DATA.SPATIAL_DATA.ADD',
      key: 'ds1',
      data: {
        "fk2": {
          geom: ['geom']
        }
      },
      level: 3
    }), {
      byDataSourceKey: {
        ds1: {
          fk1: {
            geometries: {
              '2': {
                geom: ['geom']
              }
            }
          },
          fk2: {
            geometries: {
              '3': {
                geom: ['geom']
              }
            }
          }
        }
      }
    });
  });
  it('add new indexes', function () {
    var filter = {
      scope: 'cities'
    };
    var order = null;
    var level = 10;
    var tile = '15,51';
    var data = [_defineProperty({}, level, _defineProperty({}, tile, {
      dsKey: [1, 2, 3]
    }))];
    var changedOn = null;
    chai.assert.deepStrictEqual(reducer$c({}, {
      type: 'DATA.SPATIAL_DATA.INDEX.ADD',
      spatialFilter: filter,
      order: order,
      indexData: data,
      changedOn: changedOn
    }), {
      indexes: [{
        filter: filter,
        order: order,
        changedOn: changedOn,
        index: _defineProperty({}, level, _defineProperty({}, tile, {
          dsKey: [1, 2, 3]
        }))
      }]
    });
  });
  it('add new indexes', function () {
    var _level3, _level4;

    var filter = {
      scope: 'cities'
    };
    var order = null;
    var level = 10;
    var tile = '15,51';
    var tile2 = '15,52';
    var data = [_defineProperty({}, level, (_level3 = {}, _defineProperty(_level3, tile, [1, 2, 3]), _defineProperty(_level3, tile2, [1, 2, 5, 6]), _level3))];
    var changedOn = null;
    chai.assert.deepStrictEqual(reducer$c({}, {
      type: 'DATA.SPATIAL_DATA.INDEX.ADD',
      spatialFilter: filter,
      order: order,
      indexData: data,
      changedOn: changedOn
    }), {
      indexes: [{
        filter: filter,
        order: order,
        index: _defineProperty({}, level, (_level4 = {}, _defineProperty(_level4, tile, [1, 2, 3]), _defineProperty(_level4, tile2, [1, 2, 5, 6]), _level4)),
        changedOn: changedOn
      }]
    });
  });
  it('update index on add indexes', function () {
    var _level5, _level7;

    var filter = {
      scope: 'cities'
    };
    var order = null;
    var level = 10;
    var tile = '15,51';
    var tile2 = '15,52';

    var index = _defineProperty({}, level, (_level5 = {}, _defineProperty(_level5, tile, [1, 2, 9]), _defineProperty(_level5, tile2, [1, 2, 5, 6]), _level5));

    var updateIndex = [_defineProperty({}, level, _defineProperty({}, tile2, [1, 9, 11, 10, 89]))];
    var changedOn = null;
    chai.assert.deepStrictEqual(reducer$c({
      indexes: [{
        filter: filter,
        order: order,
        index: index,
        changedOn: changedOn
      }]
    }, {
      type: 'DATA.SPATIAL_DATA.INDEX.ADD',
      spatialFilter: filter,
      order: order,
      indexData: updateIndex,
      changedOn: changedOn
    }), {
      indexes: [{
        filter: filter,
        order: order,
        index: _defineProperty({}, level, (_level7 = {}, _defineProperty(_level7, tile, [1, 2, 9]), _defineProperty(_level7, tile2, [1, 9, 11, 10, 89]), _level7)),
        changedOn: changedOn
      }]
    });
  });
});

describe('state/Data/SpatialDataSources/actions', function () {
  var dispatchedActions = [];

  var clearDispatchedActions = function clearDispatchedActions() {
    dispatchedActions = [];
  };

  var runFunctionActions = function runFunctionActions(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return new Promise(function (resolve, reject) {
      var promises = [];

      for (var i = 0; i < dispatchedActions.length; i++) {
        var action = dispatchedActions[i];

        if (typeof action === 'function') {
          promises.push(action(dispatch, getState));
          dispatchedActions[i] = null;
        } else if (action instanceof Promise) {
          promises.push(action);
          dispatchedActions[i] = null;
        } else if (Array.isArray(action)) {
          dispatchedActions = [].concat(_toConsumableArray(dispatchedActions), _toConsumableArray(action));
          dispatchedActions[i] = null;
        }
      }

      dispatchedActions = dispatchedActions.filter(function (a) {
        return a != null;
      });

      if (promises.length > 0) {
        return Promise.all(promises).then(function () {
          return runFunctionActions({
            dispatch: dispatch,
            getState: getState
          });
        }).then(function () {
          return resolve();
        });
      }

      resolve();
    });
  };

  afterEach(function () {
    clearDispatchedActions();
  });
  it('receiveIndexed', function () {
    var getState = function getState() {
      return {};
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    var result = [];
    var filter = {};
    var order = null;
    var start = 0;
    var total = 10;
    var changes = null;
    dispatch(actions$e.receiveIndexed(result, filter, order, start, total, changes));
    return runFunctionActions({
      dispatch: dispatch,
      getState: getState
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'DATA.SPATIAL_DATA_SOURCES.INDEX.ADD',
        filter: filter,
        order: order,
        start: start,
        count: total,
        data: result,
        changedOn: changes
      }]);
    });
  });
  it('receiveIndexed with results', function () {
    var getState = function getState() {
      return {};
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    var results = [{
      key: 1
    }, {
      key: 2
    }];
    var filter = {};
    var order = null;
    var start = 0;
    var total = 10;
    var changes = null;
    dispatch(actions$e.receiveIndexed(results, filter, order, start, total, changes));
    return runFunctionActions({
      dispatch: dispatch,
      getState: getState
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        "data": results,
        "filter": filter,
        "type": "DATA.SPATIAL_DATA_SOURCES.ADD"
      }, {
        type: 'DATA.SPATIAL_DATA_SOURCES.INDEX.ADD',
        filter: filter,
        order: order,
        start: start,
        count: total,
        data: results,
        changedOn: changes
      }]);
    });
  });
});

describe('state/Data/spatialRealations/actions', function () {
  var dispatchedActions = [];

  var clearDispatchedActions = function clearDispatchedActions() {
    dispatchedActions = [];
  };

  var runFunctionActions = function runFunctionActions(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return new Promise(function (resolve, reject) {
      var promises = [];

      for (var i = 0; i < dispatchedActions.length; i++) {
        var action = dispatchedActions[i];

        if (typeof action === 'function') {
          promises.push(action(dispatch, getState));
          dispatchedActions[i] = null;
        } else if (action instanceof Promise) {
          promises.push(action);
          dispatchedActions[i] = null;
        } else if (Array.isArray(action)) {
          dispatchedActions = [].concat(_toConsumableArray(dispatchedActions), _toConsumableArray(action));
          dispatchedActions[i] = null;
        }
      }

      dispatchedActions = dispatchedActions.filter(function (a) {
        return a != null;
      });

      if (promises.length > 0) {
        return Promise.all(promises).then(function () {
          return runFunctionActions({
            dispatch: dispatch,
            getState: getState
          });
        }).then(function () {
          return resolve();
        });
      }

      resolve();
    });
  };

  afterEach(function () {
    clearDispatchedActions();
  });
  it('receiveIndexed', function () {
    var getState = function getState() {
      return {};
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    var result = [];
    var filter = {};
    var order = null;
    var start = 0;
    var total = 10;
    var changes = null;
    dispatch(actions$d.receiveIndexed(result, filter, order, start, total, changes));
    return runFunctionActions({
      dispatch: dispatch,
      getState: getState
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        type: 'DATA.SPATIAL_RELATIONS.INDEX.ADD',
        filter: filter,
        order: order,
        start: start,
        count: total,
        data: result,
        changedOn: changes
      }]);
    });
  });
  it('receiveIndexed with results', function () {
    var getState = function getState() {
      return {};
    };

    var dispatch = function dispatch(action) {
      if (typeof action === 'function') {
        var res = action(dispatch, getState);

        if (res != null) {
          dispatchedActions.push(res);
        }

        return res;
      }

      dispatchedActions.push(action);
    };

    var results = [{
      key: 1
    }, {
      key: 2
    }];
    var filter = {};
    var order = null;
    var start = 0;
    var total = 10;
    var changes = null;
    dispatch(actions$d.receiveIndexed(results, filter, order, start, total, changes));
    return runFunctionActions({
      dispatch: dispatch,
      getState: getState
    }).then(function () {
      chai.assert.deepStrictEqual(dispatchedActions, [{
        "data": results,
        "filter": filter,
        "type": "DATA.SPATIAL_RELATIONS.ADD"
      }, {
        type: 'DATA.SPATIAL_RELATIONS.INDEX.ADD',
        filter: filter,
        order: order,
        start: start,
        count: total,
        data: results,
        changedOn: changes
      }]);
    });
  });
});

describe('state/Data/SpatialRelations/selectors', function () {
  describe('getIndex', function () {
    var state = {
      data: {
        spatialRelations: {
          indexes: [{
            filter: {
              scopeKey: 'Europe',
              placeKey: 'Prague'
            },
            order: null,
            count: 3,
            index: {
              1: 'a',
              2: 'b',
              3: 'c'
            }
          }, {
            filter: {
              scopeKey: 'Europe',
              placeKey: 'Prague',
              caseKey: {
                "in": ["A", "B"]
              }
            },
            order: null,
            count: 3,
            index: {
              1: 'a',
              2: null,
              3: 'c'
            }
          }]
        }
      }
    };
    it('Should select index', function () {
      var filter = {
        scopeKey: 'Europe',
        placeKey: 'Prague'
      };
      var expectedResult = {
        filter: {
          scopeKey: 'Europe',
          placeKey: 'Prague'
        },
        order: null,
        count: 3,
        index: {
          1: 'a',
          2: 'b',
          3: 'c'
        }
      };
      chai.assert.deepStrictEqual(selectors$c.getIndex(state, filter, null), expectedResult);
    });
    it('Should select index, if multiple case keys', function () {
      var filter = {
        scopeKey: 'Europe',
        placeKey: 'Prague',
        caseKey: {
          "in": ["A", "B"]
        }
      };
      var expectedResult = {
        filter: {
          scopeKey: 'Europe',
          placeKey: 'Prague',
          caseKey: {
            "in": ["A", "B"]
          }
        },
        order: null,
        count: 3,
        index: {
          1: 'a',
          2: null,
          3: 'c'
        }
      };
      chai.assert.deepStrictEqual(selectors$c.getIndex(state, filter, null), expectedResult);
    });
    it('Should not select index', function () {
      var filter = {
        scopeKey: 'Europe',
        placeKey: 'Prague',
        caseKey: {
          "in": ["A", "B", "C"]
        }
      };
      var expectedResult = null;
      chai.assert.deepStrictEqual(selectors$c.getIndex(state, filter, null), expectedResult);
    });
  });
});

var INITIAL_STATE$d = {
  byAoiKey: {},
  byPlaceKey: {},
  byKey: {}
};

function requestForAoi(state, action) {
  var layerRecord = _objectSpread2(_objectSpread2({}, getLayerRecord(state, action.aoiKey, action.layerKey)), {}, {
    data: action.periods,
    loading: true
  });

  var byLayerKey = _objectSpread2(_objectSpread2({}, getByLayerKey(state, action.aoiKey)), {}, _defineProperty({}, action.layerKey, layerRecord));

  var aoiRecord = _objectSpread2(_objectSpread2({}, state.byAoiKey[action.aoiKey]), {}, {
    byLayerKey: byLayerKey
  });

  var byAoiKey = _objectSpread2(_objectSpread2({}, state.byAoiKey), {}, _defineProperty({}, action.aoiKey, aoiRecord));

  return _objectSpread2(_objectSpread2({}, state), {}, {
    byAoiKey: byAoiKey
  });
}

function requestForAoiError(state, action) {
  var layerRecord = _objectSpread2(_objectSpread2({}, getLayerRecord(state, action.aoiKey, action.layerKey)), {}, {
    loading: false
  }); //todo should we clear old data?


  var byLayerKey = _objectSpread2(_objectSpread2({}, getByLayerKey(state, action.aoiKey)), {}, _defineProperty({}, action.layerKey, layerRecord));

  var aoiRecord = _objectSpread2(_objectSpread2({}, state.byAoiKey[action.aoiKey]), {}, {
    byLayerKey: byLayerKey
  });

  var byAoiKey = _objectSpread2(_objectSpread2({}, state.byAoiKey), {}, _defineProperty({}, action.aoiKey, aoiRecord));

  return _objectSpread2(_objectSpread2({}, state), {}, {
    byAoiKey: byAoiKey
  });
}

function receiveForAoi(state, action) {
  var layerRecord = _objectSpread2(_objectSpread2({}, getLayerRecord(state, action.aoiKey, action.layerKey)), {}, {
    data: action.periods,
    loading: false
  });

  var byLayerKey = _objectSpread2(_objectSpread2({}, getByLayerKey(state, action.aoiKey)), {}, _defineProperty({}, action.layerKey, layerRecord));

  var aoiRecord = _objectSpread2(_objectSpread2({}, state.byAoiKey[action.aoiKey]), {}, {
    byLayerKey: byLayerKey
  });

  var byAoiKey = _objectSpread2(_objectSpread2({}, state.byAoiKey), {}, _defineProperty({}, action.aoiKey, aoiRecord));

  return _objectSpread2(_objectSpread2({}, state), {}, {
    byAoiKey: byAoiKey
  });
}

function requestForPlace(state, action) {
  var layerRecord = _objectSpread2(_objectSpread2({}, getLayerRecordForPlace(state, action.placeKey, action.layerKey)), {}, {
    data: action.periods,
    loading: true
  });

  var byLayerKey = _objectSpread2(_objectSpread2({}, getByLayerKeyForPlace(state, action.placeKey)), {}, _defineProperty({}, action.layerKey, layerRecord));

  var placeRecord = _objectSpread2(_objectSpread2({}, state.byPlaceKey[action.placeKey]), {}, {
    byLayerKey: byLayerKey
  });

  var byPlaceKey = _objectSpread2(_objectSpread2({}, state.byPlaceKey), {}, _defineProperty({}, action.placeKey, placeRecord));

  return _objectSpread2(_objectSpread2({}, state), {}, {
    byPlaceKey: byPlaceKey
  });
}

function requestForPlaceError(state, action) {
  var layerRecord = _objectSpread2(_objectSpread2({}, getLayerRecordForPlace(state, action.placeKey, action.layerKey)), {}, {
    loading: false
  });

  var byLayerKey = _objectSpread2(_objectSpread2({}, getByLayerKeyForPlace(state, action.placeKey)), {}, _defineProperty({}, action.layerKey, layerRecord));

  var placeRecord = _objectSpread2(_objectSpread2({}, state.byPlaceKey[action.placeKey]), {}, {
    byLayerKey: byLayerKey
  });

  var byPlaceKey = _objectSpread2(_objectSpread2({}, state.byPlaceKey), {}, _defineProperty({}, action.placeKey, placeRecord));

  return _objectSpread2(_objectSpread2({}, state), {}, {
    byPlaceKey: byPlaceKey
  });
}

function receiveForPlace(state, action) {
  var layerRecord = _objectSpread2(_objectSpread2({}, getLayerRecordForPlace(state, action.placeKey, action.layerKey)), {}, {
    data: action.periods,
    loading: false
  });

  var byLayerKey = _objectSpread2(_objectSpread2({}, getByLayerKeyForPlace(state, action.placeKey)), {}, _defineProperty({}, action.layerKey, layerRecord));

  var placeRecord = _objectSpread2(_objectSpread2({}, state.byPlaceKey[action.placeKey]), {}, {
    byLayerKey: byLayerKey
  });

  var byPlaceKey = _objectSpread2(_objectSpread2({}, state.byPlaceKey), {}, _defineProperty({}, action.placeKey, placeRecord));

  return _objectSpread2(_objectSpread2({}, state), {}, {
    byPlaceKey: byPlaceKey
  });
}

function requestForKey(state, action) {
  var layerRecord = _objectSpread2(_objectSpread2({}, getLayerRecordForKey(state, action.key, action.layerKey)), {}, {
    data: action.periods,
    loading: true
  });

  var byLayerKey = _objectSpread2(_objectSpread2({}, getByLayerKeyForKey(state, action.key)), {}, _defineProperty({}, action.layerKey, layerRecord));

  var record = _objectSpread2(_objectSpread2({}, state.byKey[action.key]), {}, {
    byLayerKey: byLayerKey
  });

  var byKey = _objectSpread2(_objectSpread2({}, state.byKey), {}, _defineProperty({}, action.key, record));

  return _objectSpread2(_objectSpread2({}, state), {}, {
    byKey: byKey
  });
}

function requestForKeyError(state, action) {
  var layerRecord = _objectSpread2(_objectSpread2({}, getLayerRecordForKey(state, action.key, action.layerKey)), {}, {
    loading: false
  });

  var byLayerKey = _objectSpread2(_objectSpread2({}, getByLayerKeyForKey(state, action.key)), {}, _defineProperty({}, action.layerKey, layerRecord));

  var record = _objectSpread2(_objectSpread2({}, state.byKey[action.key]), {}, {
    byLayerKey: byLayerKey
  });

  var byKey = _objectSpread2(_objectSpread2({}, state.byKey), {}, _defineProperty({}, action.key, record));

  return _objectSpread2(_objectSpread2({}, state), {}, {
    byKey: byKey
  });
}

function receiveForKey(state, action) {
  var layerRecord = _objectSpread2(_objectSpread2({}, getLayerRecordForKey(state, action.key, action.layerKey)), {}, {
    data: action.periods,
    loading: false
  });

  var byLayerKey = _objectSpread2(_objectSpread2({}, getByLayerKeyForKey(state, action.key)), {}, _defineProperty({}, action.layerKey, layerRecord));

  var record = _objectSpread2(_objectSpread2({}, state.byKey[action.key]), {}, {
    byLayerKey: byLayerKey
  });

  var byKey = _objectSpread2(_objectSpread2({}, state.byKey), {}, _defineProperty({}, action.key, record));

  return _objectSpread2(_objectSpread2({}, state), {}, {
    byKey: byKey
  });
}

var reducer$d = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE$d;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case ActionTypes.LAYER_PERIODS_AOI_LAYER_REQUEST:
      return requestForAoi(state, action);

    case ActionTypes.LAYER_PERIODS_AOI_LAYER_RECEIVE:
      return receiveForAoi(state, action);

    case ActionTypes.LAYER_PERIODS_AOI_LAYER_REQUEST_ERROR:
      return requestForAoiError(state, action);

    case ActionTypes.LAYER_PERIODS_PLACE_LAYER_REQUEST:
      return requestForPlace(state, action);

    case ActionTypes.LAYER_PERIODS_PLACE_LAYER_RECEIVE:
      return receiveForPlace(state, action);

    case ActionTypes.LAYER_PERIODS_PLACE_LAYER_REQUEST_ERROR:
      return requestForPlaceError(state, action);

    case ActionTypes.LAYER_PERIODS_KEY_LAYER_REQUEST:
      return requestForKey(state, action);

    case ActionTypes.LAYER_PERIODS_KEY_LAYER_RECEIVE:
      return receiveForKey(state, action);

    case ActionTypes.LAYER_PERIODS_KEY_LAYER_REQUEST_ERROR:
      return requestForKeyError(state, action);

    default:
      return state;
  }
});

function getByLayerKey(state, aoiKey) {
  return state && state.byAoiKey && state.byAoiKey[aoiKey] && state.byAoiKey[aoiKey].byLayerKey;
}

function getLayerRecord(state, aoiKey, layerKey) {
  return getByLayerKey(state, aoiKey) && state.byAoiKey[aoiKey].byLayerKey[layerKey];
}

function getByLayerKeyForPlace(state, placeKey) {
  return state && state.byPlaceKey && state.byPlaceKey[placeKey] && state.byPlaceKey[placeKey].byLayerKey;
}

function getLayerRecordForPlace(state, placeKey, layerKey) {
  return getByLayerKeyForPlace(state, placeKey) && state.byPlaceKey[placeKey].byLayerKey[layerKey];
}

function getByLayerKeyForKey(state, key) {
  return state && state.byKey && state.byKey[key] && state.byKey[key].byLayerKey;
}

function getLayerRecordForKey(state, key, layerKey) {
  return getByLayerKeyForKey(state, key) && state.byKey[key].byLayerKey[layerKey];
}

describe('state/LayerPeriods/reducers', function () {
  it('requestForAoi', function () {
    chai.assert.deepStrictEqual(reducer$d({
      byAoiKey: {
        ak1: {
          byLayerKey: {
            lk1: {
              layerKey: 'lk1'
            }
          }
        }
      }
    }, {
      type: 'LAYER_PERIODS_AOI_LAYER_REQUEST',
      periods: {
        p1: 'v1'
      },
      layerKey: 'lk1',
      aoiKey: 'ak1'
    }), {
      byAoiKey: {
        ak1: {
          byLayerKey: {
            lk1: {
              data: {
                p1: 'v1'
              },
              layerKey: 'lk1',
              loading: true
            }
          }
        }
      }
    });
  });
  it('receiveForAoi', function () {
    chai.assert.deepStrictEqual(reducer$d({
      byAoiKey: {
        ak1: {
          byLayerKey: {
            lk1: {
              layerKey: 'lk1'
            }
          }
        }
      }
    }, {
      type: 'LAYER_PERIODS_AOI_LAYER_RECEIVE',
      periods: {
        p1: 'v1'
      },
      layerKey: 'lk1',
      aoiKey: 'ak1'
    }), {
      byAoiKey: {
        ak1: {
          byLayerKey: {
            lk1: {
              data: {
                p1: 'v1'
              },
              layerKey: 'lk1',
              loading: false
            }
          }
        }
      }
    });
  });
  it('requestForAoiError', function () {
    chai.assert.deepStrictEqual(reducer$d({
      byAoiKey: {
        ak1: {
          byLayerKey: {
            lk1: {
              layerKey: 'lk1'
            }
          }
        }
      }
    }, {
      type: 'LAYER_PERIODS_AOI_LAYER_REQUEST_ERROR',
      periods: {
        p1: 'v1'
      },
      layerKey: 'lk1',
      aoiKey: 'ak1'
    }), {
      byAoiKey: {
        ak1: {
          byLayerKey: {
            lk1: {
              layerKey: 'lk1',
              loading: false
            }
          }
        }
      }
    });
  });
  it('requestForPlace', function () {
    chai.assert.deepStrictEqual(reducer$d({
      byPlaceKey: {
        pk1: {
          byLayerKey: {
            lk1: {
              layerKey: 'lk1'
            }
          }
        }
      }
    }, {
      type: 'LAYER_PERIODS_PLACE_LAYER_REQUEST',
      periods: {
        p1: 'v1'
      },
      layerKey: 'lk1',
      placeKey: 'pk1'
    }), {
      byPlaceKey: {
        pk1: {
          byLayerKey: {
            lk1: {
              data: {
                p1: 'v1'
              },
              layerKey: 'lk1',
              loading: true
            }
          }
        }
      }
    });
  });
  it('receiveForPlace', function () {
    chai.assert.deepStrictEqual(reducer$d({
      byPlaceKey: {
        pk1: {
          byLayerKey: {
            lk1: {
              layerKey: 'lk1'
            }
          }
        }
      }
    }, {
      type: 'LAYER_PERIODS_PLACE_LAYER_RECEIVE',
      periods: {
        p1: 'v1'
      },
      layerKey: 'lk1',
      placeKey: 'pk1'
    }), {
      byPlaceKey: {
        pk1: {
          byLayerKey: {
            lk1: {
              data: {
                p1: 'v1'
              },
              layerKey: 'lk1',
              loading: false
            }
          }
        }
      }
    });
  });
  it('requestForPlaceError', function () {
    chai.assert.deepStrictEqual(reducer$d({
      byPlaceKey: {
        ak1: {
          byLayerKey: {
            lk1: {
              layerKey: 'lk1'
            }
          }
        }
      }
    }, {
      type: 'LAYER_PERIODS_PLACE_LAYER_REQUEST_ERROR',
      periods: {
        p1: 'v1'
      },
      layerKey: 'lk1',
      placeKey: 'ak1'
    }), {
      byPlaceKey: {
        ak1: {
          byLayerKey: {
            lk1: {
              layerKey: 'lk1',
              loading: false
            }
          }
        }
      }
    });
  });
  it('requestForKey', function () {
    chai.assert.deepStrictEqual(reducer$d({
      byKey: {
        k1: {
          byLayerKey: {
            lk1: {
              layerKey: 'lk1'
            }
          }
        }
      }
    }, {
      type: 'LAYER_PERIODS_KEY_LAYER_REQUEST',
      periods: {
        p1: 'v1'
      },
      layerKey: 'lk1',
      key: 'k1'
    }), {
      byKey: {
        k1: {
          byLayerKey: {
            lk1: {
              data: {
                p1: 'v1'
              },
              layerKey: 'lk1',
              loading: true
            }
          }
        }
      }
    });
  });
  it('receiveForKey', function () {
    chai.assert.deepStrictEqual(reducer$d({
      byKey: {
        k1: {
          byLayerKey: {
            lk1: {
              layerKey: 'lk1'
            }
          }
        }
      }
    }, {
      type: 'LAYER_PERIODS_KEY_LAYER_RECEIVE',
      periods: {
        p1: 'v1'
      },
      layerKey: 'lk1',
      key: 'k1'
    }), {
      byKey: {
        k1: {
          byLayerKey: {
            lk1: {
              data: {
                p1: 'v1'
              },
              layerKey: 'lk1',
              loading: false
            }
          }
        }
      }
    });
  });
  it('requestForKeyError', function () {
    chai.assert.deepStrictEqual(reducer$d({
      byKey: {
        k1: {
          byLayerKey: {
            lk1: {
              layerKey: 'lk1'
            }
          }
        }
      }
    }, {
      type: 'LAYER_PERIODS_KEY_LAYER_REQUEST_ERROR',
      periods: {
        p1: 'v1'
      },
      layerKey: 'lk1',
      key: 'k1'
    }), {
      byKey: {
        k1: {
          byLayerKey: {
            lk1: {
              layerKey: 'lk1',
              loading: false
            }
          }
        }
      }
    });
  });
  it('unknown', function () {
    chai.assert.deepStrictEqual(reducer$d({}, {
      type: 'UNKNOWN_ACTION'
    }), {});
  });
});

describe('state/LayerPeriods/selectors', function () {
  it('getActiveAoiData', function () {
    chai.assert.deepStrictEqual(selectors$d.getActiveAoiData({
      layerPeriods: {
        byAoiKey: {
          ak1: {
            key: 'ak1'
          }
        }
      },
      aoi: {
        activeKey: 'ak1'
      }
    }), {
      key: 'ak1'
    });
  });
  it('getActivePlaceData', function () {
    chai.assert.deepStrictEqual(selectors$d.getActivePlaceData({
      layerPeriods: {
        byPlaceKey: {
          pk1: {
            key: 'pk1'
          }
        }
      },
      places: {
        activeKey: 'pk1'
      }
    }), {
      key: 'pk1'
    });
  });
  it('getForActiveLpisCase', function () {
    chai.assert.deepStrictEqual(selectors$d.getForActiveLpisCase({
      layerPeriods: {
        byKey: {
          lpisCaselk1: {
            key: 'lk1'
          }
        }
      },
      specific: {
        lpisChangeReviewCases: {
          activeCaseKey: 'lk1'
        }
      }
    }), {
      key: 'lk1'
    });
  });
});

describe('state/Maps/selectorHelpers', function () {
  describe('getBackgroundLayerAsLayer', function () {
    var backgroundLayer = {
      layerTemplateKey: "layerTemplate-uuid"
    };
    var expectedResult = {
      key: "pantherBackgroundLayer",
      layerTemplateKey: "layerTemplate-uuid"
    };
    it('should return backgroundLayer as layer', function () {
      // check structure
      chai.assert.deepStrictEqual(selectorHelpers.getBackgroundLayerAsLayer(backgroundLayer), expectedResult);
    });
    testHelpers.testCache(selectorHelpers.getBackgroundLayerAsLayer, [backgroundLayer], expectedResult);
  });
  describe('mergeBackgroundLayerWithLayers', function () {
    var backgroundLayer = {
      layerTemplateKey: "layerTemplate-uuid"
    };
    var layers = [{
      key: "layer-1",
      metadataModifiers: {
        caseKey: "case-1"
      }
    }];
    var expectedResult = [{
      key: "pantherBackgroundLayer",
      layerTemplateKey: "layerTemplate-uuid"
    }, {
      key: "layer-1",
      metadataModifiers: {
        caseKey: "case-1"
      }
    }];
    it('should return merged layers', function () {
      // check structure
      chai.assert.deepStrictEqual(selectorHelpers.mergeBackgroundLayerWithLayers(backgroundLayer, layers), expectedResult);
    });
    testHelpers.testCache(selectorHelpers.mergeBackgroundLayerWithLayers, [backgroundLayer, layers], expectedResult);
    it('should return null, if both backgroundLayer and layers are null', function () {
      // check structure
      chai.assert.isNull(selectorHelpers.mergeBackgroundLayerWithLayers(null, null));
    });
    it('should return layer with one item, if layers are null, but backgroundLayer', function () {
      // check structure
      chai.assert.deepStrictEqual(selectorHelpers.mergeBackgroundLayerWithLayers(backgroundLayer), [expectedResult[0]]);
    });
  });
  describe('getView', function () {
    var defaultView = ptrCore.mapConstants.defaultMapView;
    it('should merge map view with set view', function () {
      var map = {
        key: "map1",
        data: {
          view: {
            center: {
              lat: 50,
              lon: 15
            }
          }
        }
      };
      var set = {
        maps: ["map1"],
        sync: {
          boxRange: true
        },
        data: {
          view: {
            boxRange: 5000
          }
        }
      };

      var expectedResult = _objectSpread2(_objectSpread2({}, defaultView), {
        center: {
          lat: 50,
          lon: 15
        },
        boxRange: 5000
      });

      var output = selectorHelpers.getView(map, set);
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should use set boxRange, if the param is synced', function () {
      var map = {
        key: "map1",
        data: {
          view: {
            center: {
              lat: 50,
              lon: 15
            },
            boxRange: 1000
          }
        }
      };
      var set = {
        maps: ["map1"],
        sync: {
          boxRange: true
        },
        data: {
          view: {
            boxRange: 5000
          }
        }
      };

      var expectedResult = _objectSpread2(_objectSpread2({}, defaultView), {
        center: {
          lat: 50,
          lon: 15
        },
        boxRange: 5000
      });

      var output = selectorHelpers.getView(map, set);
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should not  use set boxRange, if a param is not synced', function () {
      var map = {
        key: "map1",
        data: {
          view: {
            center: {
              lat: 50,
              lon: 15
            },
            boxRange: 1000
          }
        }
      };
      var set = {
        maps: ["map1"],
        data: {
          view: {
            boxRange: 5000
          }
        }
      };

      var expectedResult = _objectSpread2(_objectSpread2({}, defaultView), {
        center: {
          lat: 50,
          lon: 15
        },
        boxRange: 1000
      });

      var output = selectorHelpers.getView(map, set);
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return map view, if set is not defined', function () {
      var map = {
        key: "map1",
        data: {
          view: {
            center: {
              lat: 50,
              lon: 15
            }
          }
        }
      };

      var expectedResult = _objectSpread2(_objectSpread2({}, defaultView), {
        center: {
          lat: 50,
          lon: 15
        }
      });

      var output = selectorHelpers.getView(map, null);
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return map view, if map is not defined', function () {
      var set = {
        maps: ["mapXYZ"],
        data: {
          view: {
            boxRange: 5000
          }
        }
      };
      var output = selectorHelpers.getView(null, null);
      chai.assert.isNull(output);
      var output2 = selectorHelpers.getView(null, set);
      chai.assert.isNull(output2);
    });
    it('should return set view, if view is not defined & param is synced', function () {
      var map = {
        key: "map1",
        data: {
          view: null
        }
      };
      var set = {
        maps: ["mapXYZ"],
        sync: {
          boxRange: true
        },
        data: {
          view: {
            boxRange: 5000
          }
        }
      };

      var expectedResult = _objectSpread2(_objectSpread2({}, defaultView), {
        boxRange: 5000
      });

      var output = selectorHelpers.getView(map, set);
      chai.assert.deepStrictEqual(output, expectedResult);
    });
  });
});

describe('state/Maps/selectors', function () {
  var state = {
    maps: {
      maps: {
        map1: {
          key: "map1",
          name: "Map 1",
          data: {
            backgroundLayer: {
              layerTemplateKey: "layerTemplateBackground"
            },
            layers: [{
              key: "layer1",
              name: "Layer 1",
              layerTemplateKey: "layerTemplate1",
              styleKey: "style1",
              metadataModifiers: {
                placeKey: "place1",
                scenarioKeys: ["scenario1", "scenario2"]
              },
              filterByActive: {
                place: true,
                layerTemplateKey: true,
                applicationKey: true
              }
            }, {
              key: "layerDefinition1",
              name: "Layer with definitions",
              type: "vector",
              options: {
                features: [],
                style: {
                  styles: [{
                    fill: "#ff0000"
                  }]
                }
              }
            }],
            metadataModifiers: null,
            filterByActive: {
              period: true
            },
            view: {
              boxRange: 500000,
              center: {
                lat: 49,
                lon: 10
              }
            }
          }
        },
        map2: {
          key: "map2",
          name: "Map 2",
          data: {
            backgroundLayer: null,
            layers: [{
              key: "layer3",
              name: "Layer 3",
              layerTemplateKey: "layerTemplate3",
              styleKey: "style3",
              metadataModifiers: {
                placeKey: "place2"
              }
            }],
            view: {
              boxRange: 1000000
            },
            metadataModifiers: {
              periodKey: "period2"
            }
          }
        }
      },
      sets: {
        set1: {
          key: "set1",
          activeMapKey: "map1",
          maps: ["map1", "map2"],
          sync: {
            center: true
          },
          data: {
            backgroundLayer: {
              type: "wmts",
              options: {
                url: "http://backgroundLayer.no"
              }
            },
            layers: [{
              key: "layer2",
              layerTemplateKey: "layerTemplate2",
              metadataModifiers: {
                periodKey: "period1"
              }
            }],
            metadataModifiers: {
              scopeKey: "scope1"
            },
            filterByActive: null,
            view: {
              center: {
                lat: 50,
                lon: 10
              }
            },
            viewLimits: [500, 500000]
          }
        }
      }
    }
  };
  describe('getMapByKey', function () {
    it('should return data for given mapKey, if map exists', function () {
      var expectedResult = state.maps.maps.map1;
      var output = Select.maps.getMapByKey(state, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null, if map does not exist', function () {
      var output = Select.maps.getMapByKey(state, "mapXYZ");
      chai.assert.isNull(output);
    });
  });
  describe('getMapSets', function () {
    it('should return collection of all existing map sets', function () {
      var expectedResult = Object.values(state.maps.sets);
      var output = Select.maps.getMapSets(state);
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null, if no sets exist', function () {
      var output = Select.maps.getMapSets(_objectSpread2(_objectSpread2({}, state), {}, {
        maps: _objectSpread2(_objectSpread2({}, state.maps), {}, {
          sets: null
        })
      }));
      chai.assert.isNull(output);
    });
  });
  describe('getMapSetByMapKey', function () {
    it('should return data of the map set for given mapKey, if map exists', function () {
      var expectedResult = state.maps.sets.set1;
      var output = Select.maps.getMapSetByMapKey(state, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null, if no sets exist', function () {
      var output = Select.maps.getMapSetByMapKey(_objectSpread2(_objectSpread2({}, state), {}, {
        maps: _objectSpread2(_objectSpread2({}, state.maps), {}, {
          sets: null
        })
      }), "map1");
      chai.assert.isNull(output);
    });
    it('should return null, if map set for given map key does not exist', function () {
      var output = Select.maps.getMapSetByMapKey(state, "mapXYZ");
      chai.assert.isNull(output);
    });
  });
  describe('getMapSetByKey', function () {
    it('should return data for given setKey, if set exists', function () {
      var expectedResult = state.maps.sets.set1;
      var output = Select.maps.getMapSetByKey(state, "set1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null, if map does not exist', function () {
      var output = Select.maps.getMapSetByKey(state, "setXYZ");
      chai.assert.isNull(output);
    });
  });
  describe('getMapSetActiveMapKey', function () {
    it('should return data active map key, if it is defined in map set', function () {
      var expectedResult = state.maps.sets.set1.activeMapKey;
      var output = Select.maps.getMapSetActiveMapKey(state, "set1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return global map key, if map set does not have active key, but map exists in given map set', function () {
      var updatedState = _objectSpread2(_objectSpread2({}, state), {}, {
        maps: _objectSpread2(_objectSpread2({}, state.maps), {}, {
          activeMapKey: "map2",
          sets: _objectSpread2(_objectSpread2({}, state.maps.sets), {}, {
            set1: _objectSpread2(_objectSpread2({}, state.maps.sets.set1), {}, {
              activeMapKey: null
            })
          })
        })
      });

      var output = Select.maps.getMapSetActiveMapKey(updatedState, "set1");
      chai.assert.deepStrictEqual(output, "map2");
    });
    it('should return null if map set does not exist', function () {
      var output = Select.maps.getMapSetActiveMapKey(state, "setXYZ");
      chai.assert.isNull(output);
    });
  });
  describe('getMapSetActiveMapView', function () {
    it('should return null, if there is no activeMapKey for map set', function () {
      var updatedState = _objectSpread2(_objectSpread2({}, state), {}, {
        maps: _objectSpread2(_objectSpread2({}, state.maps), {}, {
          sets: _objectSpread2(_objectSpread2({}, state.maps.sets), {}, {
            set1: _objectSpread2(_objectSpread2({}, state.maps.sets.set1), {}, {
              activeMapKey: null
            })
          })
        })
      });

      var output = Select.maps.getMapSetActiveMapView(updatedState, "set1");
      chai.assert.isNull(output);
    });
    it('should return null if map set does not exist', function () {
      var output = Select.maps.getMapSetActiveMapView(state, "setXYZ");
      chai.assert.isNull(output);
    });
    it('should return view', function () {
      var expectedResult = {
        boxRange: 500000,
        center: {
          lat: 50,
          lon: 10
        },
        heading: 0,
        tilt: 0,
        roll: 0
      };
      var output = Select.maps.getMapSetActiveMapView(state, "set1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
  });
  describe('getViewByMapKey', function () {
    it('should return view for given map key', function () {
      var expectedResult = {
        boxRange: 500000,
        center: {
          lat: 50,
          lon: 10
        },
        heading: 0,
        tilt: 0,
        roll: 0
      };
      var output = Select.maps.getViewByMapKey(state, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
  });
  describe('getViewLimitsByMapKey', function () {
    it('should return null, if map for given key does not exist', function () {
      var output = Select.maps.getViewLimitsByMapKey(state, "mapXYZ");
      chai.assert.isNull(output);
    });
    it('should return map view limits only, if a map is not in any set', function () {
      var updatedState = _objectSpread2(_objectSpread2({}, state), {}, {
        maps: _objectSpread2(_objectSpread2({}, state.maps), {}, {
          sets: _objectSpread2(_objectSpread2({}, state.maps.sets), {}, {
            set1: _objectSpread2(_objectSpread2({}, state.maps.sets.set1), {}, {
              maps: []
            })
          }),
          maps: _objectSpread2(_objectSpread2({}, state.maps.maps), {}, {
            map1: _objectSpread2(_objectSpread2({}, state.maps.maps.map1), {}, {
              data: _objectSpread2(_objectSpread2({}, state.maps.maps.map1.data), {}, {
                viewLimits: [500, 5000]
              })
            })
          })
        })
      });

      var expectedResult = [500, 5000];
      var output = Select.maps.getViewLimitsByMapKey(updatedState, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return set view limits', function () {
      var expectedResult = state.maps.sets.set1.data.viewLimits;
      var output = Select.maps.getViewLimitsByMapKey(state, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
  });
  describe('getMapSetMapKeys', function () {
    it('should return map set keys for given setKey, if set exists', function () {
      var expectedResult = state.maps.sets.set1.maps;
      var output = Select.maps.getMapSetMapKeys(state, "set1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null, maps is empty array', function () {
      var updatedState = _objectSpread2(_objectSpread2({}, state), {}, {
        maps: _objectSpread2(_objectSpread2({}, state.maps), {}, {
          sets: _objectSpread2(_objectSpread2({}, state.maps.sets), {}, {
            set1: _objectSpread2(_objectSpread2({}, state.maps.sets.set1), {}, {
              maps: []
            })
          })
        })
      });

      var output = Select.maps.getMapSetMapKeys(updatedState, "set1");
      chai.assert.isNull(output);
    });
    it('should return null, map set does not exist', function () {
      var output = Select.maps.getMapSetMapKeys(state, "setXYZ");
      chai.assert.isNull(output);
    });
  });
  describe('getMapSetView', function () {
    it('should return map set view for given setKey, if set exists', function () {
      var expectedResult = _objectSpread2(_objectSpread2({}, ptrCore.mapConstants.defaultMapView), state.maps.sets.set1.data.view);

      var output = Select.maps.getMapSetView(state, "set1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null, map set does not exist', function () {
      var output = Select.maps.getMapSetView(state, "setXYZ");
      chai.assert.isNull(output);
    });
  });
  describe('getMapSetViewLimits', function () {
    it('should return map set view limits for given setKey, if set exists', function () {
      var expectedResult = state.maps.sets.set1.data.viewLimits;
      var output = Select.maps.getMapSetViewLimits(state, "set1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null, map set does not exist', function () {
      var output = Select.maps.getMapSetViewLimits(state, "setXYZ");
      chai.assert.isNull(output);
    });
  });
  describe('getMapBackgroundLayerStateByMapKey', function () {
    it('should return backgroundLayer data', function () {
      var expectedResult = {
        layerTemplateKey: "layerTemplateBackground"
      };
      var output = Select.maps.getMapBackgroundLayerStateByMapKey(state, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null, if no background layer data exist', function () {
      var output = Select.maps.getMapBackgroundLayerStateByMapKey(_objectSpread2(_objectSpread2({}, state), {}, {
        maps: _objectSpread2(_objectSpread2({}, state.maps), {}, {
          maps: _objectSpread2(_objectSpread2({}, state.maps.maps), {}, {
            map1: _objectSpread2(_objectSpread2({}, state.maps.maps.map1), {}, {
              data: _objectSpread2(_objectSpread2({}, state.maps.maps.map1.data), {}, {
                backgroundLayer: null
              })
            })
          })
        })
      }), "map1");
      chai.assert.isNull(output);
    });
  });
  describe('getMapLayersStateByMapKey', function () {
    it('should return layers data', function () {
      var expectedResult = state.maps.maps.map1.data.layers;
      var output = Select.maps.getMapLayersStateByMapKey(state, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null, if no layers exist', function () {
      var output = Select.maps.getMapLayersStateByMapKey(_objectSpread2(_objectSpread2({}, state), {}, {
        maps: _objectSpread2(_objectSpread2({}, state.maps), {}, {
          maps: _objectSpread2(_objectSpread2({}, state.maps.maps), {}, {
            map1: _objectSpread2(_objectSpread2({}, state.maps.maps.map1), {}, {
              data: _objectSpread2(_objectSpread2({}, state.maps.maps.map1.data), {}, {
                layers: null
              })
            })
          })
        })
      }), "map1");
      chai.assert.isNull(output);
    });
  });
  describe('getMapSetBackgroundLayerStateByMapKey', function () {
    it('should return backgroundLayer data', function () {
      var expectedResult = {
        type: "wmts",
        options: {
          url: "http://backgroundLayer.no"
        }
      };
      var output = Select.maps.getMapSetBackgroundLayerStateByMapKey(state, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null, if no background layer data exist', function () {
      var output = Select.maps.getMapSetBackgroundLayerStateByMapKey(_objectSpread2(_objectSpread2({}, state), {}, {
        maps: _objectSpread2(_objectSpread2({}, state.maps), {}, {
          sets: _objectSpread2(_objectSpread2({}, state.maps.sets), {}, {
            set1: _objectSpread2(_objectSpread2({}, state.maps.sets.set1), {}, {
              data: _objectSpread2(_objectSpread2({}, state.maps.sets.set1.data), {}, {
                backgroundLayer: null
              })
            })
          })
        })
      }), "map1");
      chai.assert.isNull(output);
    });
  });
  describe('getMapSetLayersStateByMapKey', function () {
    it('should return layers data', function () {
      var expectedResult = state.maps.sets.set1.data.layers;
      var output = Select.maps.getMapSetLayersStateByMapKey(state, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null, if no layers exist', function () {
      var output = Select.maps.getMapSetLayersStateByMapKey(_objectSpread2(_objectSpread2({}, state), {}, {
        maps: _objectSpread2(_objectSpread2({}, state.maps), {}, {
          sets: _objectSpread2(_objectSpread2({}, state.maps.sets), {}, {
            set1: _objectSpread2(_objectSpread2({}, state.maps.sets.set1), {}, {
              data: _objectSpread2(_objectSpread2({}, state.maps.sets.set1.data), {}, {
                layers: null
              })
            })
          })
        })
      }), "map1");
      chai.assert.isNull(output);
    });
  });
  describe('getMapMetadataModifiersByMapKey', function () {
    it('should return metadata modifiers', function () {
      var expectedResult = {
        periodKey: "period2"
      };
      var output = Select.maps.getMapMetadataModifiersByMapKey(state, "map2");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null, if no layers exist', function () {
      var output = Select.maps.getMapMetadataModifiersByMapKey(state, "map1");
      chai.assert.isNull(output);
    });
  });
  describe('getMapSetMetadataModifiersByMapKey', function () {
    it('should return metadata modifiers', function () {
      var expectedResult = {
        scopeKey: "scope1"
      };
      var output = Select.maps.getMapSetMetadataModifiersByMapKey(state, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null, if no metadata modifiers exist', function () {
      var output = Select.maps.getMapSetMetadataModifiersByMapKey(_objectSpread2(_objectSpread2({}, state), {}, {
        maps: _objectSpread2(_objectSpread2({}, state.maps), {}, {
          sets: _objectSpread2(_objectSpread2({}, state.maps.sets), {}, {
            set1: _objectSpread2(_objectSpread2({}, state.maps.sets.set1), {}, {
              data: _objectSpread2(_objectSpread2({}, state.maps.sets.set1.data), {}, {
                metadataModifiers: null
              })
            })
          })
        })
      }), "map1");
      chai.assert.isNull(output);
    });
  });
  describe('getMetadataModifiersByMapKey', function () {
    it('should return merged map modifiers', function () {
      var expectedResult = {
        scopeKey: "scope1",
        periodKey: "period2"
      };
      var output = Select.maps.getMetadataModifiersByMapKey(state, "map2");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return map set modifiers, if map modifiers does not exist', function () {
      var expectedResult = {
        scopeKey: "scope1"
      };
      var output = Select.maps.getMetadataModifiersByMapKey(state, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null, if no modifiers exist', function () {
      var output = Select.maps.getMetadataModifiersByMapKey(state, "map3");
      chai.assert.isNull(output);
    });
    testHelpers.testCache(Select.maps.getMetadataModifiersByMapKey, [state, "map2"], {
      scopeKey: "scope1",
      periodKey: "period2"
    }, [state, "map2"]);
  });
  describe('getMapFilterByActiveByMapKey', function () {
    it('should return filter by active', function () {
      var expectedResult = {
        period: true
      };
      var output = Select.maps.getMapFilterByActiveByMapKey(state, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null, if no filter by active exists', function () {
      var output = Select.maps.getMapFilterByActiveByMapKey(state, "map2");
      chai.assert.isNull(output);
    });
  });
  describe('getMapSetFilterByActiveByMapKey', function () {
    it('should return filter by active', function () {
      var expectedResult = {
        period: true
      };
      var output = Select.maps.getMapSetFilterByActiveByMapKey(_objectSpread2(_objectSpread2({}, state), {}, {
        maps: _objectSpread2(_objectSpread2({}, state.maps), {}, {
          sets: _objectSpread2(_objectSpread2({}, state.maps.sets), {}, {
            set1: _objectSpread2(_objectSpread2({}, state.maps.sets.set1), {}, {
              data: _objectSpread2(_objectSpread2({}, state.maps.sets.set1.data), {}, {
                filterByActive: {
                  period: true
                }
              })
            })
          })
        })
      }), "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null, if no filter by active exists', function () {
      var output = Select.maps.getMapSetFilterByActiveByMapKey(state, "map2");
      chai.assert.isNull(output);
    });
  });
  describe('getFilterByActiveByMapKey', function () {
    it('should return merged filter by active', function () {
      var expectedResult = {
        period: true
      };
      var output = Select.maps.getFilterByActiveByMapKey(state, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return merged filter by active 2', function () {
      var expectedResult = {
        period: true,
        scope: true
      };

      var updatedState = _objectSpread2(_objectSpread2({}, state), {}, {
        maps: _objectSpread2(_objectSpread2({}, state.maps), {}, {
          sets: _objectSpread2(_objectSpread2({}, state.maps.sets), {}, {
            set1: _objectSpread2(_objectSpread2({}, state.maps.sets.set1), {}, {
              data: _objectSpread2(_objectSpread2({}, state.maps.sets.set1), {}, {
                filterByActive: {
                  scope: true
                }
              })
            })
          })
        })
      });

      var output = Select.maps.getFilterByActiveByMapKey(updatedState, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    testHelpers.testCache(Select.maps.getFilterByActiveByMapKey, [state, "map1"], {
      period: true
    });
    it('should return null, if no modifiers exist', function () {
      var output = Select.maps.getFilterByActiveByMapKey(state, "map2");
      chai.assert.isNull(output);
    });
  });
  describe('getBackgroundLayerStateByMapKey', function () {
    it('should return map background layer', function () {
      var expectedResult = {
        layerTemplateKey: "layerTemplateBackground"
      };
      var output = Select.maps.getBackgroundLayerStateByMapKey(state, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return map set background layer', function () {
      var expectedResult = {
        type: "wmts",
        options: {
          url: "http://backgroundLayer.no"
        }
      };
      var output = Select.maps.getBackgroundLayerStateByMapKey(state, "map2");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null', function () {
      var output = Select.maps.getBackgroundLayerStateByMapKey(state, "map3");
      chai.assert.isNull(output);
    });
  });
  describe('getMapSetLayersStateWithModifiersByMapKey', function () {
    var expectedResult = [{
      key: "layer2",
      layerTemplateKey: "layerTemplate2",
      metadataModifiers: {
        periodKey: "period1",
        scopeKey: "scope1"
      },
      filterByActive: null
    }];
    it('should return map set layers for map 1', function () {
      var output = Select.maps.getMapSetLayersStateWithModifiersByMapKey(state, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    testHelpers.testCache(Select.maps.getMapSetLayersStateWithModifiersByMapKey, [state, "map1"], expectedResult);
  });
  describe('getMapLayersStateWithModifiersByMapKey', function () {
    var expectedResult = [{
      key: "layer1",
      name: "Layer 1",
      layerTemplateKey: "layerTemplate1",
      styleKey: "style1",
      metadataModifiers: {
        placeKey: "place1",
        scopeKey: "scope1",
        scenarioKeys: ["scenario1", "scenario2"]
      },
      filterByActive: {
        place: true,
        period: true,
        layerTemplateKey: true,
        applicationKey: true
      }
    }, {
      key: "layerDefinition1",
      name: "Layer with definitions",
      type: "vector",
      options: {
        features: [],
        style: {
          styles: [{
            fill: "#ff0000"
          }]
        }
      },
      filterByActive: {
        period: true
      },
      metadataModifiers: {
        scopeKey: "scope1"
      }
    }];
    it('should return map layers for map 1', function () {
      var output = Select.maps.getMapLayersStateWithModifiersByMapKey(state, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    testHelpers.testCache(Select.maps.getMapLayersStateWithModifiersByMapKey, [state, "map1"], expectedResult);
  });
  describe('getLayersStateByMapKey', function () {
    var expectedResult = [{
      key: "layer2",
      layerTemplateKey: "layerTemplate2",
      metadataModifiers: {
        periodKey: "period1",
        scopeKey: "scope1"
      },
      filterByActive: null
    }, {
      key: "layer1",
      name: "Layer 1",
      layerTemplateKey: "layerTemplate1",
      styleKey: "style1",
      metadataModifiers: {
        placeKey: "place1",
        scopeKey: "scope1",
        scenarioKeys: ["scenario1", "scenario2"]
      },
      filterByActive: {
        place: true,
        period: true,
        layerTemplateKey: true,
        applicationKey: true
      }
    }, {
      key: "layerDefinition1",
      name: "Layer with definitions",
      type: "vector",
      options: {
        features: [],
        style: {
          styles: [{
            fill: "#ff0000"
          }]
        }
      },
      filterByActive: {
        period: true
      },
      metadataModifiers: {
        scopeKey: "scope1"
      }
    }];
    var expectedResult2 = [{
      key: "layer2",
      layerTemplateKey: "layerTemplate2",
      metadataModifiers: {
        periodKey: "period1",
        scopeKey: "scope1"
      },
      filterByActive: null
    }, {
      key: "layer3",
      name: "Layer 3",
      layerTemplateKey: "layerTemplate3",
      styleKey: "style3",
      metadataModifiers: {
        placeKey: "place2",
        periodKey: "period2",
        scopeKey: "scope1"
      },
      filterByActive: null
    }];
    it('should return map layers for map 1', function () {
      var output = Select.maps.getLayersStateByMapKey(state, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return map layers for map 2', function () {
      var output = Select.maps.getLayersStateByMapKey(state, "map2");
      chai.assert.deepStrictEqual(output, expectedResult2);
    });
    testHelpers.testCache(Select.maps.getLayersStateByMapKey, [state, "map1"], expectedResult, [state, "map2"]);
    it('should return just map layers, if set layers do not exist', function () {
      var updatedState = _objectSpread2(_objectSpread2({}, state), {}, {
        maps: _objectSpread2(_objectSpread2({}, state.maps), {}, {
          sets: _objectSpread2(_objectSpread2({}, state.maps.sets), {}, {
            set1: _objectSpread2(_objectSpread2({}, state.maps.sets.set1), {}, {
              data: _objectSpread2(_objectSpread2({}, state.maps.sets.set1.data), {}, {
                layers: null
              })
            })
          })
        })
      });

      var output = Select.maps.getLayersStateByMapKey(updatedState, "map2");
      chai.assert.deepStrictEqual(output, [expectedResult2[1]]);
    });
    it('should return just set layers, if map layers do not exist', function () {
      var updatedState = _objectSpread2(_objectSpread2({}, state), {}, {
        maps: _objectSpread2(_objectSpread2({}, state.maps), {}, {
          maps: _objectSpread2(_objectSpread2({}, state.maps.maps), {}, {
            map2: _objectSpread2(_objectSpread2({}, state.maps.maps.map2), {}, {
              data: _objectSpread2(_objectSpread2({}, state.maps.maps.map2.data), {}, {
                layers: null
              })
            })
          })
        })
      });

      var output = Select.maps.getLayersStateByMapKey(updatedState, "map2");
      chai.assert.deepStrictEqual(output, [expectedResult2[0]]);
    });
    it('should return null, if both set layers and map layers is null', function () {
      var updatedState = _objectSpread2(_objectSpread2({}, state), {}, {
        maps: _objectSpread2(_objectSpread2({}, state.maps), {}, {
          sets: _objectSpread2(_objectSpread2({}, state.maps.sets), {}, {
            set1: _objectSpread2(_objectSpread2({}, state.maps.sets.set1), {}, {
              data: _objectSpread2(_objectSpread2({}, state.maps.sets.set1.data), {}, {
                layers: null
              })
            })
          }),
          maps: _objectSpread2(_objectSpread2({}, state.maps.maps), {}, {
            map2: _objectSpread2(_objectSpread2({}, state.maps.maps.map2), {}, {
              data: _objectSpread2(_objectSpread2({}, state.maps.maps.map2.data), {}, {
                layers: null
              })
            })
          })
        })
      });

      var output = Select.maps.getLayersStateByMapKey(updatedState, "map2");
      chai.assert.isNull(output);
    });
  });
  describe('getAllLayersStateByMapKey', function () {
    var expectedResult = [{
      key: "pantherBackgroundLayer",
      layerTemplateKey: "layerTemplateBackground"
    }, {
      key: "layer2",
      layerTemplateKey: "layerTemplate2",
      metadataModifiers: {
        periodKey: "period1",
        scopeKey: "scope1"
      },
      filterByActive: null
    }, {
      key: "layer1",
      name: "Layer 1",
      layerTemplateKey: "layerTemplate1",
      styleKey: "style1",
      metadataModifiers: {
        placeKey: "place1",
        scopeKey: "scope1",
        scenarioKeys: ["scenario1", "scenario2"]
      },
      filterByActive: {
        place: true,
        period: true,
        layerTemplateKey: true,
        applicationKey: true
      }
    }, {
      key: "layerDefinition1",
      name: "Layer with definitions",
      type: "vector",
      options: {
        features: [],
        style: {
          styles: [{
            fill: "#ff0000"
          }]
        }
      },
      filterByActive: {
        period: true
      },
      metadataModifiers: {
        scopeKey: "scope1"
      }
    }];
    it('should return all map layers for map 1', function () {
      var output = Select.maps.getAllLayersStateByMapKey(state, "map1");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    testHelpers.testCache(Select.maps.getAllLayersStateByMapKey, [state, "map1"], expectedResult);
    it('should return all map layers for map 2', function () {
      var expectedResult = [{
        key: "pantherBackgroundLayer",
        type: "wmts",
        options: {
          url: "http://backgroundLayer.no"
        }
      }, {
        key: "layer2",
        layerTemplateKey: "layerTemplate2",
        metadataModifiers: {
          periodKey: "period1",
          scopeKey: "scope1"
        },
        filterByActive: null
      }, {
        key: "layer3",
        name: "Layer 3",
        layerTemplateKey: "layerTemplate3",
        styleKey: "style3",
        metadataModifiers: {
          placeKey: "place2",
          periodKey: "period2",
          scopeKey: "scope1"
        },
        filterByActive: null
      }];
      var output = Select.maps.getAllLayersStateByMapKey(state, "map2");
      chai.assert.deepStrictEqual(output, expectedResult);
    });
    it('should return null, if both backgroundLayer and layers is null', function () {
      var updatedState = _objectSpread2(_objectSpread2({}, state), {}, {
        maps: _objectSpread2(_objectSpread2({}, state.maps), {}, {
          sets: _objectSpread2(_objectSpread2({}, state.maps.sets), {}, {
            set1: _objectSpread2(_objectSpread2({}, state.maps.sets.set1), {}, {
              data: _objectSpread2(_objectSpread2({}, state.maps.sets.set1.data), {}, {
                layers: null,
                backgroundLayer: null
              })
            })
          }),
          maps: _objectSpread2(_objectSpread2({}, state.maps.maps), {}, {
            map1: _objectSpread2(_objectSpread2({}, state.maps.maps.map1), {}, {
              data: _objectSpread2(_objectSpread2({}, state.maps.maps.map1.data), {}, {
                layers: null,
                backgroundLayer: null
              })
            })
          })
        })
      });

      var output = Select.maps.getAllLayersStateByMapKey(updatedState, "map1");
      chai.assert.isNull(output);
    });
  });
});

describe('state/selections/selectors', function () {
  var state = {
    styles: {
      byKey: {
        "style1": {
          key: 'style1',
          data: {
            definition: {
              rules: [{
                styles: [{
                  "fill": "#aab5ff"
                }]
              }]
            }
          }
        }
      }
    },
    selections: {
      byKey: {
        "selection1": {
          key: "selection1",
          data: {
            styleKey: "style1"
          }
        }
      }
    }
  };
  describe('getAllAsObjectWithStyles', function () {
    var noStyleState = _objectSpread2(_objectSpread2({}, state), {}, {
      styles: {}
    });

    var noMatchStyleState = _objectSpread2(_objectSpread2({}, state), {}, {
      styles: {
        byKey: {
          'styleXXX': {}
        }
      }
    });

    var emptyStyleState = _objectSpread2(_objectSpread2({}, state), {}, {
      styles: {
        byKey: {
          'style1': {
            key: 'style1',
            data: {}
          }
        }
      }
    });

    var noSelectionState = _objectSpread2(_objectSpread2({}, state), {}, {
      selections: {}
    });

    it('should return selections with styles', function () {
      var result = {
        "selection1": {
          key: "selection1",
          data: {
            styleKey: "style1",
            style: {
              "fill": "#aab5ff"
            }
          }
        }
      };
      chai.assert.deepEqual(Select.selections.getAllAsObjectWithStyles(state), result);
    });
    it('should return original selections', function () {
      var result = _objectSpread2({}, state.selections.byKey);

      chai.assert.deepEqual(Select.selections.getAllAsObjectWithStyles(noStyleState), result);
      chai.assert.deepEqual(Select.selections.getAllAsObjectWithStyles(noMatchStyleState), result);
      chai.assert.deepEqual(Select.selections.getAllAsObjectWithStyles(emptyStyleState), result);
    });
    it('should return empty object', function () {
      chai.assert.deepEqual(Select.selections.getAllAsObjectWithStyles(noSelectionState), {});
    });
  });
});
//# sourceMappingURL=bundle-tests.js.map
